<!DOCTYPE HTML>
<html lang="zh-CN" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tiny-LSM-Lab</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tiny-LSM-Lab</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Vanilla-Beauty/tiny-lsm" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tiny-lsm-lab"><a class="header" href="#tiny-lsm-lab">Tiny-LSM Lab</a></h1>
<p><img src="./logo/logo1-compact.jpg" alt="logo" /></p>
<hr />
<h1 id="0-tiny-lsm是什么"><a class="header" href="#0-tiny-lsm是什么">0 Tiny-LSM是什么?</a></h1>
<p><a href="https://github.com/Vanilla-Beauty/tiny-lsm">Tiny-LSM</a>是一个基于<code>LSM Tree</code>的开源教学<code>KV</code>存储引擎, 除<code>LSM Tree</code>的基础功能外, 还支持<code>MVCC</code>、<code>WAL</code>、崩溃恢复、<code>Redis</code>兼容等功能。本实验是基于作者原本实验的代码进行改造后的<code>Lab</code>课程。</p>
<p><code>LSM Tree</code>（<code>Log-Structured Merge-Tree</code>）是一种适用于磁盘存储的数据结构，特别适合于需要高吞吐量的写操作的场景。它由Patrick O'Neil等人于1996年提出，广泛应用于NoSQL数据库和文件系统中，如<code>LevelDB</code>、<code>RocksDB</code>和<code>Cassandra</code>等。<code>LSM Tree</code>的主要思想是将数据写入操作日志（Log），然后定期将日志中的数据合并到磁盘上的有序不可变文件（SSTable）中。这些SSTable文件按层次结构组织，数据在多个层次之间逐步合并和压缩，以减少读取时的查找次数和磁盘I/O操作。</p>
<p>有关<code>LSM Tree</code>的进一步背景和介绍请参见<a href="lab0-background.html">LSM Tree 概览</a></p>
<p>本实现项目<code>Tiny-LSM</code>完成了包括<code>内存表（MemTable）</code>、<code>不可变表（SSTable）</code>、<code>布隆过滤器（Bloom Filter）</code>、<code>合并和压缩（Compaction）</code>等<code>LSM Tree</code>的核心组件，并在此基础上添加了额外的功能博客, 包括:</p>
<ul>
<li>实现了<code>ACID</code>事务</li>
<li>实现了<code>MVCC</code>多版本并发控制</li>
<li>实现了<code>WAL</code>日志和崩溃恢复</li>
<li>基于<code>KV</code>存储实现了<code>Redis</code>的<code>Resp</code>协议兼容层</li>
<li>基于<code>Resp</code>协议兼容层实现了<code>redis-server</code>服务</li>
</ul>
<h3 id="-请支持我们的项目"><a class="header" href="#-请支持我们的项目">⭐ 请支持我们的项目！</a></h3>
<blockquote>
<p>如果您觉得本<code>Lab</code>不错, 请为<a href="https://github.com/Vanilla-Beauty/tiny-lsm">Tiny-LSM</a>点一个⭐。项目实验制作耗费了我很大精力，作者非常需要您的鼓励❤️, 您的支持是我更新的动力😆</p>
</blockquote>
<h1 id="1-本实验的目的是什么"><a class="header" href="#1-本实验的目的是什么">1 本实验的目的是什么?</a></h1>
<p>本实验的最终目标是实现一个基于<code>LSM Tree</code>的单机<code>KV Store</code>引擎。其功能包括:</p>
<ol>
<li>基本的<code>KV</code>存储功能，包括<code>put</code>、<code>get</code>、<code>remove</code>等。</li>
<li>持久化功能，构建的存储引擎的数据将持久化到磁盘中。</li>
<li>事务功能，构建的存储引擎将支持<code>ACID</code>等基本事务特性</li>
<li><code>MVCC</code>, 构建的存储引擎将支持<code>MVCC</code>对数据进行查询。</li>
<li><code>WAL</code>与崩溃恢复, 数据写入前会先预写到<code>WAL</code>日志以支持崩溃恢复</li>
<li><code>Redis</code>兼容, 本实验将实现<code>Redis</code>的<code>Resp</code>兼容层, 作为<code>Redis</code>后端。</li>
</ol>
<h1 id="2-本实验适合哪些人"><a class="header" href="#2-本实验适合哪些人">2 本实验适合哪些人？</a></h1>
<p>通过本实验，你可以学习到<code>LSM Tree</code>这一工业界广泛使用的<code>KV</code>存储架构, 适合数据库、存储领域的入门学习者。同时本实验包含了<code>Redis</code>的<code>Resp</code>协议兼容层、网络服务器搭建等内容，也适合后端开发的求职者。同时，本项目使用<code>C++ 17</code>特性, 使用<code>Xmake</code>作为构建工具，并具备完善的单元测试，也适合想通过项目进一步学习现代<code>C++</code>的同学。</p>
<h1 id="3-本实验的前置知识"><a class="header" href="#3-本实验的前置知识">3 本实验的前置知识？</a></h1>
<p>本项目的知识包括：</p>
<ol>
<li><strong>(必备)</strong>: 到<code>C++17</code>为止的常见<code>C++</code>新特性，（项目的配置文件指定的标准为<code>C++20</code>, 但其只在单元测试中使用, 项目核心代码只要求<code>C++17</code>即可）</li>
<li><strong>(必备)</strong>：常见的数据结构与算法知识</li>
<li><strong>(建议)</strong>: 数据库的基本知识，包括事务特性、<code>MVCC</code>的基本概念</li>
<li><strong>(建议)</strong>: <code>Linux</code>系统编程知识，本实验使用了系统底层的<code>mmap</code>等IO相关的系统调用</li>
<li><strong>(可选)</strong>：<code>Xmake</code>的使用, 本实验的构建工具为<a href="https://xmake.io/#/zh-cn/"><code>Xmake</code></a>, 若你想自定义单元测试或引入别的库, 需要手动在<code>Xmake</code>中配置。</li>
<li><strong>(可选)</strong>: <code>Redis</code>基本知识, 本实验将利用<code>kv</code>存储接口实现<code>Redis</code>后端, 熟悉<code>Redis</code>有助于实验的理解。</li>
<li><strong>(可选)</strong>: 单元测试框架<code>gtest</code>的使用, 如果你想自定义单元测试, 需要自行改配置。</li>
</ol>
<h1 id="4-实验流程"><a class="header" href="#4-实验流程">4 实验流程</a></h1>
<p>本实验的组织类似<a href="https://github.com/cmu-db/bustub"><code>CMU15445 bustub</code></a>, <code>Lab</code>提供了整体的代码框架, 并将其中某些组件的关键函数挖空并标记为<code>TODO</code>, 参与<code>Lab</code>的同学需要按照每一个<code>Lab</code>的指南补全缺失的函数, 并通过对应的单元测试。</p>
<p>同样类似<code>CMU 15445</code>, 后面的<code>Lab</code>依赖于前一个<code>Lab</code>的正确性, 而实验提供的单元测试知识尽量考虑到了各种边界情况, 但不能完全确保你的代码正确, 因此必要时, 你需要自行进行单元测试补充以及<code>debug</code>。</p>
<blockquote>
<p>在目前的<code>Lab</code>中, 你确实可以从原仓库<a href="https://github.com/Vanilla-Beauty/tiny-lsm">Tiny-LSM</a>的<code>complete</code>分支直接查看<code>Lab</code>实验的答案, 但作者不希望你如此做, 这样你将无法深刻理解实验设计的思路和相关知识。并且, 作者自己实现的代码中的崩溃恢复部分存在<code>bug</code>, 且其余部分并非最佳方案。（猜猜作者是不是故意的😏）</p>
</blockquote>
<p>在了解完这些以后, 你可以开启下一章<a href="./lab0-env.html">Lab 0 环境准备</a>的学习。</p>
<h1 id="5-项目交流与讨论"><a class="header" href="#5-项目交流与讨论">5 项目交流与讨论</a></h1>
<p>如果你对本<code>Lab</code>有疑问, 欢迎在<a href="https://github.com/Vanilla-Beauty/tiny-lsm/issues">GitHub Issues</a>中提出问题。也欢迎加入次实验的<a href="https://qm.qq.com/q/wDZQfaNNw6">QQ讨论群</a> 。如果你想参与<code>Lab</code>的开发, 欢迎通过QQ群或者作者邮件: <a href="mailto:807077266@qq.com">📧邮件</a>  联系。</p>
<h1 id="6-推荐课程"><a class="header" href="#6-推荐课程">6 推荐课程</a></h1>
<p>这里给出作者推荐的相关开源课程, 供你参考学习:</p>
<ol>
<li><a href="https://github.com/skyzh/mini-lsm">mini-lsm</a> 迟先生用<code>Rust</code>实现的<code>LSM Tree</code>课程, 其代码质量非常高, 本课程的很多设计也参考了<code>Mini-LSM</code>, 适合想用<code>Rust</code>实现<code>LSM Tree</code>的同学学习。</li>
<li><a href="https://sakurs2.gitbook.io/tinycorolab-docs/">TinyCoroLab</a>, 基于<code>io_uring</code>的现代<code>C++</code>协程的开源课程, 适合学习协程及的各种现代C++新特性。</li>
<li><a href="https://15445.courses.cs.cmu.edu/fall2024/">CMU 15445</a> 经典CMU的数据库课程, 不解释了。</li>
<li><a href="https://pdos.csail.mit.edu/6.824/">MIT 6.824</a> MIT的经典分布式课程。</li>
<li><a href="https://github.com/talent-plan/tinykv">Tiny-KV</a> PingCap出品的分布式KV数据库教程, 算是MIT 6.824的升级版。</li>
</ol>
<h1 id="7-贡献者"><a class="header" href="#7-贡献者">7 贡献者</a></h1>
<p>非常感谢本项目贡献过源码的网友:</p>
<a href="https://github.com/Vanilla-Beauty/tiny-lsm/contributors">
  <img src="https://contrib.rocks/image?repo=Vanilla-Beauty/tiny-lsm" />
</a>
<p>如果你在阅读本教程文档中发现错误, 可以直接点击文档右上角的<img src="./images/intro/edit.png" alt="edit" />, 其会引导你进入对应分支对当前的<code>md</code>文件进行编辑和修改, 然后提交<code>PR</code>即可。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-lsm-tree-简介"><a class="header" href="#1-lsm-tree-简介">1. LSM Tree 简介</a></h1>
<p>在具体进入本实验之前，我们先来简单介绍<code>LSM Tree</code>。</p>
<p><code>LSM Tree</code>是一种<code>KV</code>存储架构。其核心思想是，将<code>KV</code>存储的数据以<code>SSTable</code>的形式进行持久化，并通过<code>MemTable</code>进行内存缓存，当<code>MemTable</code>的数据量达到一定阈值时，将其持久化到磁盘中，并重新创建一个<code>MemTable</code>。<code>LSM Tree</code>的核心思想是，将<code>KV</code>存储的数据以<code>SSTable</code>的形式进行持久化，并通过<code>MemTable</code>进行内存缓存。并且， 数据以追加写入的方式进行，删除数据也是通过更新的数据进行覆盖的方式实现。</p>
<p><img src="images/intro/tiny-lsm-arch.drawio.png" alt="Fig 1" /></p>
<p>如图所示为<code>LSM Tree</code>的核心架构。我们通过<code>Put</code>, <code>Remove</code>和<code>Get</code>操作的流程对其进行介绍。</p>
<h2 id="11-put-操作流程"><a class="header" href="#11-put-操作流程">1.1 Put 操作流程</a></h2>
<p><code>Put</code>操作流程如下：</p>
<ol>
<li>将<code>Put</code>操作的数据写入<code>MemTable</code>中
<ol>
<li><code>MemTable</code>中包括多个键值存储容器(本项目是采用的跳表<code>SkipList</code>)
<ol>
<li>其中有一份称为<code>current_table</code>, 即活跃跳表, 其可读可写</li>
<li>其余的多份跳表均为<code>frozen_tables</code>, 即即冻结跳表, 其只能进行读操作</li>
</ol>
</li>
<li><code>Put</code>的键值对首先插入到<code>current_table</code>中
<ol>
<li>如果<code>current_table</code>的数据量未达到阈值, 直接返回给客户端</li>
<li>如果<code>current_table</code>的数据量达到阈值, 则将<code>current_table</code>被冻结称为<code>frozen_tables</code>中的一份, 并重新初始化一份<code>current_table</code></li>
</ol>
</li>
</ol>
</li>
<li>如果前述步骤导致了新的<code>frozen_table</code>产生, 判断<code>frozen_table</code>的容量是否超出阈值</li>
<li>如果超出阈值, 则将<code>frozen_table</code>持久化到磁盘中, 形成<code>SST</code>(全程是<code>Sorted String Table</code>), 单个<code>SST</code>是有序的。
<ol>
<li><code>SST</code>按照不同的层级进行划分, 内存中的<code>MemTable</code>刷出的<code>SST</code>位于<code>Level 0</code>, <code>Level 0</code>的<code>SST</code>是存在重叠的。（例如<code>SST 0</code>的<code>key</code>范围是<code>[0, 100)</code>, <code>SST 1</code>的<code>key</code>范围是<code>[50, 150)</code>, 那么<code>SST 0</code>和<code>SST 1</code>的<code>key</code>在<code>50, 100)</code>范围是重叠的, 因此无法在整个层级进行二分查询）</li>
<li>当<code>Level 0</code>的<code>SST</code>数量达到一定阈值时, 会进行<code>Level 0</code>的<code>SST</code>合并, 将<code>SST</code>进行<code>compact</code>操作, 新的<code>SST</code>将放在<code>Level 1</code>中。同时，为保证此层所有<code>SST</code>的<code>key</code>有序且不重叠, <code>compact</code>的<code>SST</code>需要与原来<code>Level 1</code>的<code>SST</code>进行重新排序。由于<code>compact</code>时将上一层所有的<code>SST</code>合并到了下一层, 因此每层单个<code>SST</code>的容量是呈指数增长的。</li>
<li>当每一层的<code>SST</code>数量达到一定阈值时, <code>compact</code>操作会递归地向下一层进行。</li>
</ol>
</li>
</ol>
<h2 id="12-remove-操作流程"><a class="header" href="#12-remove-操作流程">1.2 Remove 操作流程</a></h2>
<p>由于<code>LSM Tree</code>的操作是追加写入的, 因此<code>Remove</code>操作与<code>Put</code>操作本质上没有区别, 只是<code>Remove</code>的<code>value</code>被设定为空以标识数据的删除。</p>
<h2 id="13-get-操作流程"><a class="header" href="#13-get-操作流程">1.3 Get 操作流程</a></h2>
<p><code>Get</code>操作流程如下:</p>
<ol>
<li>先在<code>Memtable</code>中查找, 如果找到则直接返回。
<ol>
<li>优先查找活跃跳表<code>current_table</code></li>
<li>其次尝试查找<code>frozen_tables</code>, 按照<code>id</code>倒序查找(因为<code>id</code>越小, 表示<code>SkipList</code>越旧)</li>
</ol>
</li>
<li>如果在<code>Memtable</code>中未找到, 则在<code>SST</code>中查找。
<ol>
<li>先在<code>Level 0</code>层查找, 如果找到则直接返回。注意的是, <code>Level 0</code>层不懂的<code>SST</code>没有进行排序, 因此需要按照<code>SST</code>的<code>id</code>倒序逐个查找(因为<code>id</code>越小, 表示<code>SST</code>越旧, 优先级越低)</li>
<li>随后逐个在后面的<code>Level</code>层查找, 此时所有的<code>SST</code>都已经进行过排序, 因此可在<code>Level</code>层面进行二分查询。</li>
</ol>
</li>
<li>如果<code>SST</code>中为查询到, 返回。</li>
</ol>
<p>至此，你对<code>LSM Tree</code>的<code>CRUD</code>操作流程有了一个初步的印象, 如果你现在看不懂的话, 没关系。后续的<code>Lab</code>中会对每个模块有详细的讲解。</p>
<h1 id="2-lsm-tree-vs-b-tree"><a class="header" href="#2-lsm-tree-vs-b-tree">2. LSM Tree VS B-Tree</a></h1>
<p>接下来对比分析一下LSM Tree 和 B-Tree。B-Tree 和 LSM-Tree 是两种最常用的存储数据结构，广泛应用于各种数据库和存储引擎中。</p>
<h2 id="21-b-tree-概述"><a class="header" href="#21-b-tree-概述">2.1 B-Tree 概述</a></h2>
<h3 id="211-基本结构"><a class="header" href="#211-基本结构">2.1.1 基本结构</a></h3>
<p>B-Tree 是一种多路平衡搜索树，具有如下特点：</p>
<ul>
<li><strong>多路搜索</strong>：每个节点可包含多个 key 和多个指向子节点的指针，典型的阶为 M 的 B-Tree 每个节点最多包含 M-1 个 key 和 M 个子指针。</li>
<li><strong>有序性</strong>：节点内的 key 是有序排列的，满足搜索树的性质（左子树所有 key 小于当前 key，右子树所有 key 大于当前 key）。</li>
<li><strong>节点平衡</strong>：B-Tree 总是保持所有叶子节点在同一深度，避免了不平衡树造成的性能劣化。</li>
<li><strong>磁盘优化</strong>：B-Tree 节点设计与磁盘页大小（如 4KB）对齐，尽量减少 I/O 次数。一个节点一般映射为一个磁盘页。</li>
</ul>
<h3 id="212-操作流程"><a class="header" href="#212-操作流程">2.1.2 操作流程</a></h3>
<h4 id="查找操作"><a class="header" href="#查找操作">查找操作</a></h4>
<ol>
<li>从根节点开始，顺序查找当前节点内的 key；</li>
<li>若找到对应 key，返回其值；</li>
<li>若未找到，确定 key 所属范围并跳转到对应子节点；</li>
<li>重复上述步骤，直到叶子节点。</li>
</ol>
<h4 id="插入操作"><a class="header" href="#插入操作">插入操作</a></h4>
<ol>
<li>先定位插入位置；</li>
<li>若目标页未满，直接插入；</li>
<li>若目标页已满，触发分裂操作，将节点拆分为两个，并将中间 key 上移至父节点；</li>
<li>如果父节点也满，则递归向上分裂，可能导致树高度加一。</li>
</ol>
<h4 id="删除操作简略"><a class="header" href="#删除操作简略">删除操作（简略）</a></h4>
<ol>
<li>查找要删除的 key；</li>
<li>若为叶子节点直接删除，若为内部节点需用前驱/后继替换；</li>
<li>若删除导致节点 key 数小于最小值（通常是 M/2），需借 key 或合并兄弟节点，保持平衡。</li>
</ol>
<h3 id="213-性能特点"><a class="header" href="#213-性能特点">2.1.3 性能特点</a></h3>
<div class="table-wrapper"><table><thead><tr><th>操作类型</th><th>时间复杂度</th><th>备注</th></tr></thead><tbody>
<tr><td>查找</td><td>O(logₘN)</td><td>树高取决于扇出 M，M 越大树越矮</td></tr>
<tr><td>插入</td><td>O(logₘN)</td><td>最多向上分裂至根节点</td></tr>
<tr><td>删除</td><td>O(logₘN)</td><td>包含调整和合并操作</td></tr>
</tbody></table>
</div>
<ul>
<li><strong>优势</strong>：查找路径短，适用于 OLTP 事务型数据库；</li>
<li><strong>劣势</strong>：写入为页内更新和<strong>随机写</strong>， 且可能导致<strong>写放大</strong>,不适合写密集型负载。</li>
</ul>
<blockquote>
<p>🌪️ “随机写”是什么意思？</p>
<p>在 B-Tree 中，每次写入（插入、更新或删除）都必须找到对应位置，比如一个叶子节点中的第 n 个 key：</p>
<ol>
<li>B-Tree 会从根节点一路查找，定位到目标页（也就是磁盘上的一个节点）。</li>
<li>如果该页满了，还要分裂成两个页，再更新父节点指针，可能一直递归到根。</li>
<li>每一个操作，可能都要读写不同位置的磁盘页——这些页不在相邻磁盘位置上，就叫“随机写”。</li>
</ol>
<p>而磁盘（特别是传统 HDD）最慢的操作就是随机写。</p>
</blockquote>
<blockquote>
<p>🔥 “写放大”又是什么？</p>
<p>你本来只是想写入一个 key-value 对，结果 B-Tree 却可能会因为：</p>
<ol>
<li>页满而分裂；</li>
<li>父节点也满而再分裂；</li>
<li>更新多个索引路径节点；</li>
</ol>
<p>导致你实际上要写入多个节点、多个页——一次小写入导致多次磁盘写入，这就叫写放大（Write Amplification）。</p>
<p>比如你写了 1KB 数据，磁盘实际写了 16KB，甚至 64KB，这种浪费，就是放大了。</p>
</blockquote>
<h2 id="22-lsm-tree-概述"><a class="header" href="#22-lsm-tree-概述">2.2. LSM-Tree 概述</a></h2>
<h3 id="221-设计动机"><a class="header" href="#221-设计动机">2.2.1 设计动机</a></h3>
<p>为了解决传统 B-Tree 在写密集场景下的随机写和高写放大问题，LSM-Tree 采取“先内存写、再后台合并”的思路，以空间换时间，提升写入吞吐。</p>
<h3 id="222-主要组件与流程"><a class="header" href="#222-主要组件与流程">2.2.2 主要组件与流程</a></h3>
<ol>
<li><strong>MemTable（内存表）</strong>：所有写操作首先追加到内存中的有序结构（如跳表）。</li>
<li><strong>SSTable（磁盘表）</strong>：当 MemTable 达到阈值时，将其定期刷新为只读的磁盘文件。</li>
<li><strong>后台 Compaction（合并）</strong>：将多个旧的 SSTable 合并、去重，并生成新的 SSTable，控制文件数量与数据冗余。</li>
</ol>
<h3 id="223-优化手段"><a class="header" href="#223-优化手段">2.2.3 优化手段</a></h3>
<ul>
<li><strong>Bloom Filter</strong>：快速判断某 key 是否存在于某个 SSTable，减少不必要的磁盘查找。</li>
<li><strong>Index Block / Block Cache</strong>：缓存热点数据页，加速读请求。</li>
<li><strong>Tiered / Leveled Compaction</strong>：通过分层或分阶段合并，平衡写放大与读放大。</li>
</ul>
<hr />
<h2 id="23-b-tree-vs-lsm-tree-对比"><a class="header" href="#23-b-tree-vs-lsm-tree-对比">2.3. B-Tree vs. LSM-Tree 对比</a></h2>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>B-Tree</th><th>LSM-Tree</th></tr></thead><tbody>
<tr><td>写入模式</td><td>随机写，页内更新，可能分裂节点</td><td>顺序写（追加），后台合并</td></tr>
<tr><td>写放大</td><td>较低</td><td>较高（受合并策略影响）</td></tr>
<tr><td>读取路径</td><td>单次树搜索</td><td>多级查找（MemTable + 多个 SSTable + 合并）</td></tr>
<tr><td>读写性能场景</td><td>读密集型</td><td>写密集型</td></tr>
<tr><td>磁盘友好性</td><td>随机 I/O</td><td>顺序 I/O，更适合 SSD</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>小结</strong>：LSM-Tree 在写入吞吐上优于 B-Tree，但读取延迟与 I/O 成本相对更高。
更深入的对比分析可以阅读：
<a href="https://tikv.org/deep-dive/key-value-engine/b-tree-vs-lsm/">https://tikv.org/deep-dive/key-value-engine/b-tree-vs-lsm/</a></p>
</blockquote>
<hr />
<h2 id="24-常见系统及应用场景"><a class="header" href="#24-常见系统及应用场景">2.4 常见系统及应用场景</a></h2>
<div class="table-wrapper"><table><thead><tr><th>存储引擎 / 数据库</th><th>类型</th></tr></thead><tbody>
<tr><td>LevelDB</td><td>嵌入式 KV 存储引擎</td></tr>
<tr><td>RocksDB</td><td>KV 存储引擎</td></tr>
<tr><td>HyperLevelDB</td><td>分布式 KV 存储</td></tr>
<tr><td>PebbleDB</td><td>嵌入式 KV 存储</td></tr>
<tr><td>Cassandra</td><td>分布式列存储数据库</td></tr>
<tr><td>ClickHouse</td><td>分析型数据库</td></tr>
<tr><td>InfluxDB</td><td>时间序列数据库</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="25-lsm-tree-优化研究"><a class="header" href="#25-lsm-tree-优化研究">2.5 LSM-Tree 优化研究</a></h2>
<p>LSM Tree自1997年提出后，有很多研究人员在LSM Tree的基础上进行了改进，部分代表性工作比如：</p>
<p><a href="">RocksDB</a>, <a href="">LevelDB</a>：经典的LSM Based KV存储引擎.</p>
<p><a href="https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf">WiscKey: Separating Keys from Values in SSD-Conscious Storage</a>：分离 Key 和 Value，降低写放大</p>
<p><a href="https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf">Monkey: Optimal Bloom Filters and Tuning for LSM-Trees</a>：优化布隆过滤器分配策略，减少读放大</p>
<p>这里不再进行详细介绍，感兴趣的可以阅读相关论文。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-0-环境准备"><a class="header" href="#lab-0-环境准备">Lab 0 环境准备</a></h1>
<h1 id="1-os和编译器环境"><a class="header" href="#1-os和编译器环境">1 OS和编译器环境</a></h1>
<p>本实验目前最高使用的<code>C++</code>标准是<code>C++20</code>, 所以需要使用<code>g++</code>或者<code>clang++</code>进行编译, 因此只要是支持<code>C++20</code>的编译器都可以. 我这里使用的操作系统是<code>kali linux</code>, 其和<code>Ubuntu</code>一样, 都是基于<code>Debian</code>, 且都使用<code>apt</code>作为系统包管理工具, 所以你使用<code>Ubuntu</code>或者<code>Debian</code>执行我之后的安装指令肯定也没有什么问题。</p>
<blockquote>
<p>我使用<code>WSL2</code>的<code>kali linux</code>作为开发环境, <code>WSL2</code>相关内容可以参考<a href="https://zhuanlan.zhihu.com/p/682583573">WSL入门到入土</a>
经个人验证, <code>WSL2</code>的<code>kali-linux</code>和<code>Ubuntu 22.04</code>均能正常完成本实验</p>
</blockquote>
<h2 id="11-编译器安装"><a class="header" href="#11-编译器安装">1.1 编译器安装</a></h2>
<pre><code class="language-bash">sudo apt install -y gcc
sudo apt install -y g++
</code></pre>
<p>经测试, 只要支持<code>C++20</code>的编译器均可以正常构建本项目, 我测试通过的编译器版本包括:</p>
<ul>
<li><code>g++-11/12/13/14/15</code></li>
<li><code>clang++-16/17/18/19</code></li>
</ul>
<h2 id="12-语言服务器"><a class="header" href="#12-语言服务器">1.2 语言服务器</a></h2>
<p>本实验推荐使用<code>clangd</code>作为语言服务器, <code>clangd</code>是一个<code>C/C++</code>语言服务器, 其可以提供代码补全、代码跳转、代码高亮等功能。</p>
<pre><code class="language-bash"># Ubuntu/Debian/Kali
sudo apt update
sudo apt install -y clangd

# Arch Linux / Manjaro
sudo pacman -S clang # 安装的是最新版本的 clang 包，clangd 自动包含在其中。

# Fedora / CentOS / RHEL
sudo dnf install clang-tools-extra # langd 在 clang-tools-extra 包中

# openSUSE
sudo zypper install clang-tools
</code></pre>
<h1 id="2-项目管理工具"><a class="header" href="#2-项目管理工具">2 项目管理工具</a></h1>
<h2 id="21-xmake"><a class="header" href="#21-xmake">2.1 Xmake</a></h2>
<h3 id="211-安装"><a class="header" href="#211-安装">2.1.1 安装</a></h3>
<p>本实验使用<code>Xmake</code>作为项目管理工具, <code>Xmake</code>是一个<code>C/C++</code>项目管理工具, 其可以看做<code>Make</code>+<code>CMake</code>+<code>vcpkg</code>的集合, 包括构建、依赖管理和项目运行等功能。</p>
<p><strong>安装Xmake</strong></p>
<pre><code class="language-bash">curl -fsSL https://xmake.io/shget.text | bash
</code></pre>
<p><code>Xmake</code>官网参考: https://xmake.io/#/getting_started</p>
<h3 id="212-xmake语法简介"><a class="header" href="#212-xmake语法简介">2.1.2 Xmake语法简介</a></h3>
<p><code>Xmake</code>使用<code>Lua</code>作为脚本语言，其语法简单易学，支持<code>C/C++</code>的依赖管理、构建、运行等功能。以下是一些基本的内置函数：</p>
<ul>
<li><strong>项目配置</strong>：通过 <code>add_rules</code> 添加规则，如添加 C++11 支持。</li>
<li><strong>目标定义</strong>：使用 <code>target</code> 定义构建目标，包括可执行文件或库。</li>
<li><strong>源文件指定</strong>：通过 <code>set_sources</code> 指定源代码文件。</li>
<li><strong>依赖管理</strong>：定义项目时使用<code>add_requires</code>添加依赖, 定义目标时用 <code>add_deps</code> 声明本地依赖的目标, 使用 <code>add_packages</code> 添加第三方包依赖。</li>
<li><strong>宏定义与包含路径</strong>：分别通过 <code>add_defines</code> 和 <code>add_includedirs</code> 设置。</li>
</ul>
<p>这里说起来比较抽象, 直接看一个示例：</p>
<pre><code class="language-lua">-- 定义项目
set_project("tiny-lsm")
set_version("0.0.1")
set_languages("c++20")

add_rules("mode.debug", "mode.release")
add_requires("gtest") -- 添加gtest依赖
add_requires("muduo") -- 添加Muduo库

target("utils")
    set_kind("static")  -- 生成静态库
    add_files("src/utils/*.cpp") -- 指定源代码文件
    add_includedirs("include", {public = true})

target("example")
    set_kind("binary")  -- 生成可执行文件
    add_files("example/main.cpp") -- 指定源代码文件
    add_deps("utils") -- 声明依赖目标
    add_includedirs("include", {public = true})
    set_targetdir("$(buildir)/bin")
    add_packages("gtest")  -- 添加gtest包
</code></pre>
<p>常用的</p>
<p>以上是 <code>Xmake</code> 的基本语法概览，更多细节可以参考官方文档: https://xmake.io/#/getting_started</p>
<h2 id="22-可选vcpkg安装"><a class="header" href="#22-可选vcpkg安装">2.2 (可选)vcpkg安装</a></h2>
<p>正常情况下, <code>Xmake</code>已经足够本项目的构建需求。但是可能存在系统依赖不兼容导致<code>Xmake</code>无法从<code>xrepo</code>拉取依赖的情况, 此时建议使用<code>vcpkg</code>进行第三方的依赖管理。</p>
<p><code>vcpkg</code>是一个跨平台依赖管理工具, 其可以自动下载、编译和安装<code>C/C++</code>依赖库。虽然<code>Xmake</code>自带一个依赖管理库, 但上面的库还是比较少, 作为补充, 我们可以再安装<code>vcpkg</code>, 这使得我们可以使用<code>vcpkg</code>来安装更多<code>Xmake</code>没有的依赖库。</p>
<p><code>vcpkg</code>这里不过多介绍, 可以直接看我另一篇文章: https://zhuanlan.zhihu.com/p/849150169</p>
<h1 id="3-vscode配置"><a class="header" href="#3-vscode配置">3 VSCode配置</a></h1>
<h2 id="31-代码智能提示和跳转"><a class="header" href="#31-代码智能提示和跳转">3.1 代码智能提示和跳转</a></h2>
<p>这里使用<code>clangd</code>作为语言服务器, 我们之前已经安装了<code>clangd</code>, 现在只需要在<code>VSCode</code>中安装<code>clangd</code>插件即可:</p>
<p><img src="images/lab0/clangd-isntall.png" alt="clangd-isntall" /></p>
<h2 id="32-集成xmake"><a class="header" href="#32-集成xmake">3.2 集成Xmake</a></h2>
<p><code>VScode</code>中支持<code>Xmake</code>项目管理工具, 我们可以安装<code>Xmake</code>插件, 使得在<code>VSCode</code>中可以更方便的使用<code>Xmake</code>项目管理工具:</p>
<p><img src="images/lab0/Xmake-VSC.png" alt="Xmake-VSC" /></p>
<p>这里有一点需要说明, 如果你安装了<code>Xmake</code>插件, 但是在调试时卡死不懂, 建议禁用<code>Code Runner</code>和<code>C/C++ Runner</code>两个插件, 如果还行不将<code>CMake</code>插件也一起禁用了:</p>
<img src="images/lab0/ban-extensions.png" width="400">
<p>如果你的<code>Xmake</code>在调试时进入的是<code>gdb</code>的页面, 请在设置中将<code>Debug Config Type</code>设置为<code>lldb</code>:</p>
<img src="images/lab0/xmake-lldb.png" width="800">
<p>当然你需要先安装<code>CodeLLdb</code>插件:</p>
<img src="images/lab0/CodeLLdb.png" width="400">
<h2 id="33-代码高亮"><a class="header" href="#33-代码高亮">3.3 代码高亮</a></h2>
<p>如果你经常用<code>C++</code>开发, 那么你可能经常会遇到第三方包导致代码高亮跳转失效的问题:</p>
<img src="images/lab0/clangd-error.png" width="500">
<p>这是因为语言服务器找不到第三方包的头文件, 由于我们使用的语言服务器是<code>clangd</code>, 我们可以在项目根目录中添加<code>.clangd</code>配置文件, 让<code>clangd</code>知道我们的第三方包头文件的位置:</p>
<pre><code class="language-yaml">CompileFlags:            # 编译标志部分
  Add:
    - "-std=c++20"      # 添加 C++17 支持
    - "-isystem/home/vanilla-beauty/proj/vcpkg/installed/x64-linux/include" # 包含头文件, 绝对路径
    - "-isystem/home/vanilla-beauty/.xmake/packages/m/muduo/2022.11.01/e9382a25649e4e43bf04f01f925d9c2f/include" # 包含头文件, 绝对路径
</code></pre>
<p>这样一来之前的告警就不复存在了</p>
<h2 id="34-其他实用插件"><a class="header" href="#34-其他实用插件">3.4 其他实用插件</a></h2>
<h3 id="341-better-comments--todotree"><a class="header" href="#341-better-comments--todotree">3.4.1 Better Comments &amp;&amp; TodoTree</a></h3>
<p><code>Better Comments</code>是一个<code>VSCode</code>插件, 它可以提供代码注释高亮和语法高亮功能, 使得代码更加易读。比如像<code>TODO</code>, <code>!</code>这样的符号:</p>
<img src="images/lab0/Better-Comments.png" width="400">
<p>当我们实现一个功能但其后续需要更新时, 我们可以在代码中添加<code>TODO</code>注释, 以便后续更新时更醒目。</p>
<p><code>TodoTree</code>则会在侧边栏展开我们标记了<code>TODO</code>的注释的位置</p>
<img src="images/lab0/TODO.png" width="400">
<h3 id="342-ai插件"><a class="header" href="#342-ai插件">3.4.2 AI插件</a></h3>
<p>如果你有钱, 直接用<code>Cusor</code>, <code>Windsurf</code>, 他们的体验更好</p>
<p>如果和我一样不够钱, 那么你可以使用<code>通义灵码</code>, <code>Cline</code>或者<code>GitHub Copilot</code>:</p>
<img src="images/lab0/lingma.png" width="400">
<img src="images/lab0/Copilot.png" width="400">
<img src="images/lab0/Cline.png" width="400">
<h1 id="4-lab代码仓库说明"><a class="header" href="#4-lab代码仓库说明">4 Lab代码仓库说明</a></h1>
<p>按照下面的命令拉取实验代码仓库:</p>
<pre><code class="language-bash">git clone https://github.com/Vanilla-Beauty/tiny-lsm.git --depth 1 -b lab
</code></pre>
<p>如果你之前的环境配置没有问题的话, 编译项目能够正常进行:</p>
<pre><code class="language-bash">cd tiny-lsm
mkdir build
xmake
</code></pre>
<h3 id="项目目录结构"><a class="header" href="#项目目录结构">项目目录结构</a></h3>
<pre><code class="language-bash">tiny-lsm/
├── doc/           # 项目文档
├── example/       # 示例程序
├── include/       # 公共头文件
├── sdk/           # SDK 接口
├── server/        # 服务器端实现
├── src/           # 核心源代码
├── test/          # 测试代码
├── .clangd        # Clangd 配置文件
├── .gitignore     # Git 忽略文件配置
├── Readme.md      # 项目说明文档
└── xmake.lua      # xmake 构建配置文件
</code></pre>
<p>其中src目录下包含以下子目录：</p>
<pre><code class="language-bash">src/
├── block/           # 数据块的编码与解码
├── iterator/        # 统一的迭代器接口
├── lsm/             # LSM 引擎的核心逻辑
├── memtable/        # 内存表（MemTable）管理
├── redis_wrapper/   # Redis 协议兼容层
├── skiplist/        # 跳表实现
├── sst/             # SSTable 的读写与管理
├── utils/           # 工具函数与通用组件
├── wal/             # Write Ahead Log管理
```</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-1-跳表实现"><a class="header" href="#lab-1-跳表实现">Lab 1 跳表实现</a></h1>
<blockquote>
<p>提示: 强烈建议你自己创建一个分组实现<code>Lab</code>的内容, 并在每次新的<code>Lab</code>开始时进行如下同步操作:</p>
<pre><code class="language-bash">git pull origin lab
git checkout your_branch
git merge lab
</code></pre>
<p>如果你发现项目仓库的代码没有指导书中的 TODO 标记的话, 证明你需要运行上述命令更新代码了</p>
</blockquote>
<h2 id="1-跳表在-lsm-tree-中的作用"><a class="header" href="#1-跳表在-lsm-tree-中的作用">1 跳表在 LSM Tree 中的作用</a></h2>
<p>本<code>Lab</code>中, 你将实现内存的基础数据结构作为<code>MemTable</code>的容器, 这里使用基于红黑树的<code>std::map</code>也是可行的, 但<code>LSM Tree</code>的原始论文中使用的是跳表, 因此我们选择使用跳表作为<code>MemTable</code>的容器，并且正好实现以下这个数据结构 (造轮子是<code>C++</code>的快乐)。</p>
<p>我们再次回顾下面的这张架构图:</p>
<p><img src="lab1/../images/intro/tiny-lsm-arch.drawio.png" alt="Fig 1" /></p>
<p>这里的<code>MemTable</code>用于存储内存中的键值对数据, 其存储的基础容器即为<code>Skiplist</code>。<code>SkipList</code>被划分为2组: <code>current_table</code>和<code>frozen_table</code>。<code>current_table</code>可读可写, 并是唯一写入的<code>SkipList</code>, <code>frozen_table</code>是只读状态, 用于存储已经写入的键值对数据。<code>current_table</code>容量超出阈值即转化为<code>frozen_table</code>中的一个。</p>
<h2 id="2-跳表的原理"><a class="header" href="#2-跳表的原理">2 跳表的原理</a></h2>
<p>这里简单介绍一下跳表是什么, 跳表就是过个链表, 每个链表的步长不同, 且链表节点是排序的, 查找或插入时, 先使用最大步长层级的链表, 然后定位大区间后, 转入下层低步长层级的链表继续查询, 是不是非常简单? :smile:</p>
<p><img src="lab1/../images/lab1/skipList.png" alt="SkipList-Arc" /></p>
<p>上图所示为跳表的简单示意图, 可以看出跳表由多层链表组成，每一层都是一个有序链表。最底层的链表包含所有元素，而上层的链表只包含部分元素，这些元素作为“索引”加速查找过程。</p>
<h3 id="21-查找过程"><a class="header" href="#21-查找过程">2.1 查找过程</a></h3>
<p>假设我们要查找值为6的节点：</p>
<ol>
<li><strong>从最高层开始</strong>：从最高层的头节点开始，沿着水平指针向右移动，直到遇到大于目标值的节点或到达该层的末尾。</li>
<li><strong>向下移动</strong>：如果当前层没有找到目标值，则沿着垂直指针向下移动到下一层，重复上述步骤。</li>
<li><strong>继续查找</strong>：在每一层中重复这个过程，直到在最底层找到目标值或确定目标值不存在。</li>
</ol>
<h3 id="22-插入过程"><a class="header" href="#22-插入过程">2.2 插入过程</a></h3>
<p>假设我们要插入值为6的节点：</p>
<ol>
<li><strong>查找插入位置</strong>：首先按照查找过程找到值为6应该插入的位置。在这个例子中，值为6应该插入在4和7之间。</li>
<li><strong>创建新节点</strong>：在最底层创建一个新节点，值为6，并将其插入到正确的位置。</li>
<li><strong>随机决定层数</strong>：使用随机算法决定新节点的层数。例如，可以以50%的概率决定是否将新节点添加到上一层。</li>
<li><strong>更新指针</strong>：在每一层中更新指针，确保新节点被正确地链接到链表中。</li>
</ol>
<h3 id="23-删除过程"><a class="header" href="#23-删除过程">2.3 删除过程</a></h3>
<p>假设我们要删除值为6的节点：</p>
<ol>
<li><strong>查找要删除的节点</strong>：首先按照查找过程找到值为6的节点。</li>
<li><strong>逐层删除</strong>：从最底层开始，逐层删除该节点，并更新相应的指针。</li>
<li><strong>调整层数</strong>：如果某一层只剩下头节点和尾节点，则可以考虑删除这一层以优化空间。</li>
</ol>
<h2 id="3-还欠缺什么"><a class="header" href="#3-还欠缺什么">3 还欠缺什么?</a></h2>
<p>在你了解到了上述<code>LSM</code>的基础知识后, 你可能觉得<code>SkipList</code>的实现不过如此, 很简单吧。但实际上也没有那么简单，首先你需要思考下面几个问题：</p>
<ol>
<li>不同<code>Level</code>的链表的步长如何确定?
<ul>
<li>最底层<code>Level 0</code>的链表步长肯定是1, 那么<code>Level 1</code>呢, <code>Level 2</code>呢?</li>
</ul>
</li>
<li>什么时候我们需要创建新的<code>Level</code>的?
<ul>
<li>一开始的时候, <code>SkipList</code>的<code>Level</code>是多少?</li>
<li>新创建的<code>Level</code>是逐层创建的吗? 还是说一次性提升好几层?</li>
</ul>
</li>
<li>上面演示的<code>SkipList</code>仅仅是单向链表, 如果是双向链表, 有什么区别呢?</li>
</ol>
<p>带着疑问, 你可以开启下一章<a href="lab1/lab2-skiplist-put.html">跳表 put/remove 的实现</a>的<code>Lab</code>实验了</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-11-跳表的-crud"><a class="header" href="#lab-11-跳表的-crud">Lab 1.1 跳表的 CRUD</a></h1>
<h1 id="1-准备工作"><a class="header" href="#1-准备工作">1 准备工作</a></h1>
<p>本<code>Lab</code>中, 你需要修改的代码文件为</p>
<ul>
<li><code>src/skiplist/skipList.cpp</code></li>
<li><code>include/skiplist/skiplist.h</code> (optional)</li>
</ul>
<p>这里首先简单介绍本<code>Lab</code>已有的<code>SkipList</code>头文件定义:</p>
<pre><code class="language-cpp">// include/skiplist/skiplist.h
struct SkipListNode {
  std::string key_;   // 节点存储的键
  std::string value_; // 节点存储的值
  uint64_t tranc_id_; // 事务 id, 目前可以忽略
  std::vector&lt;std::shared_ptr&lt;SkipListNode&gt;&gt;
      forward_; // 指向不同层级的下一个节点的指针数组
  std::vector&lt;std::weak_ptr&lt;SkipListNode&gt;&gt;
      backward_; // 指向不同层级的下一个节点的指针数组
  // ...
};
</code></pre>
<p>这里定义了跳表节点的基础数据, 包括<code>key</code>, <code>value</code>和目前可以忽略的事务<code>tranc_id_</code></p>
<p>这里定义的跳表节点使用的是双向链表, <code>forward_</code>和<code>backward_</code>分别存储了各层链表节点的前向指针和后向指针, 其中为了避免循环引用, 这里结合使用了<code>weak_ptr</code>和<code>shared_ptr</code>, 详细熟悉现代<code>C++</code>的同学对此非常熟悉。</p>
<blockquote>
<p>这里补充说明一下<code>weak_ptr</code>, 它的作用是避免<code>shared_ptr</code>循环引用, 即一个节点的<code>shared_ptr</code>指针指向另一个节点, 另一个节点的<code>shared_ptr</code>指针指向前者, 这样就会造成两个节点的析构都无法进行, 因为在析构时互相持有对方的引用计数, 类似死锁。但<code>weak_ptr</code>不参与类似<code>shared_ptr</code>的引用计数, 保证了析构的正确进行。但也正因为如此，<code>weak_ptr</code>不保证指针的有效性, 需要想使用<code>.lock()</code>判断该指针是否有效。</p>
</blockquote>
<p>然后我们看<code>SkipList</code>的头文件定义：</p>
<pre><code class="language-cpp">
class SkipList {
private:
  std::shared_ptr&lt;SkipListNode&gt;
      head;              // 跳表的头节点，不存储实际数据，用于遍历跳表
  int max_level;         // 跳表的最大层级数，限制跳表的高度
  int current_level;     // 跳表当前的实际层级数，动态变化
  size_t size_bytes = 0; // 跳表当前占用的内存大小（字节数），用于跟踪内存使用
  // std::shared_mutex rw_mutex; // ! 目前看起来这个锁是冗余的, 在上层控制即可,
  // 后续考虑是否需要细粒度的锁

  std::uniform_int_distribution&lt;&gt; dis_01;  // 随机层数的辅助生成器
  std::uniform_int_distribution&lt;&gt; dis_level;
  std::mt19937 gen;
};
</code></pre>
<p>这里我们定义了最大的链表层数<code>max_level</code>, 你的实现不能有超过<code>max_level</code>的链表数量, <code>current_level</code>定义当前链表的层数(注意是层数, 不是索引), 最后介绍最重要的<code>head</code>, 其只是个哨兵节点, 并不实际存储键值对。</p>
<p>后面三行的<code>gen</code>和<code>dis_01</code>和<code>dis_level</code>是随机数生成器，你可以使用它们来生成随机数。回想我们之前提到的问题, 你应该如何确定每一此插入节点时起最高的连接链表的<code>Level</code>呢? 这里你可以利用这些随机生成器来确定这些层数, 当然你也可以选择自己的方式来实现。</p>
<h1 id="2-put-的实现"><a class="header" href="#2-put-的实现">2 put 的实现</a></h1>
<p>你需要实现下面的<code>put</code>函数:</p>
<pre><code class="language-cpp">// 插入或更新键值对
void SkipList::put(const std::string &amp;key, const std::string &amp;value,
                   uint64_t tranc_id) {
  spdlog::trace("SkipList--put({}, {}, {})", key, value, tranc_id);

  // TODO: Lab1.1  任务：实现插入或更新键值对
  // ? Hint: 你需要保证不同`Level`的步长从底层到高层逐渐增加
  // ? 你可能需要使用到`random_level`函数以确定层数, 其注释中为你通公路一种思路
}
</code></pre>
<p>目前, 你可以先忽略<code>tranc_id</code>这个参数。</p>
<p>此外，之前提到过，跳表的层数是动态增加的， 因此你实现下面的函数可能对你有帮助：</p>
<pre><code class="language-cpp">int SkipList::random_level() {
  // TODO: 实现随机生成level函数
  // 通过"抛硬币"的方式随机生成层数：
  // - 每次有50%的概率增加一层
  // - 确保层数分布为：第1层100%，第2层50%，第3层25%，以此类推
  // - 层数范围限制在[1, max_level]之间，避免浪费内存
  return -1;
}
</code></pre>
<p>这里给出一个提示, 生成的整型值的每一个二级制位只包含0或1, 可以表示为<code>bool</code>类型, 因此你可以利用它来判断这个节点的最高层数:</p>
<ol>
<li><code>Level 0</code>底层链表: 一定连接新节点</li>
<li><code>Level 1</code>链表: 判断<code>random_level()</code>生成整型数的第1位是否为1, 有<code>50%</code>的概率连接新节点, 为0则跳出该判断链</li>
<li><code>Level 2</code>链表: 判断<code>random_level()</code>生成整型数的第2位是否为1, 有<code>50% * 50% =25%</code>的概率连接新节点, 为0则跳出该判断链</li>
<li>...</li>
</ol>
<blockquote>
<p>当然, 上述只是一个建议的方案, 你可以选择别的实现方案, 并删除<code>random_level</code>函数
另外, 别忘记了更新<code>size_bytes</code>这个统计信息, 如果你不知道这个统计信息的运作规则, 你可以查看单元测试<code>SkipListTest.MemorySizeTracking</code></p>
</blockquote>
<h1 id="3-remove-的实现"><a class="header" href="#3-remove-的实现">3 remove 的实现</a></h1>
<p>虽然我们的<code>LSM Tree</code>是以仅追加写入的方式使用我们的<code>SkipList</code>, 但为了这个数据结构的完整性, 也是一次手搓底层跳表的体验, 你需要实现正儿八经的<code>remove</code>函数:</p>
<pre><code class="language-cpp">// 删除键值对
// ! 这里的 remove 是跳表本身真实的 remove,  lsm 应该使用 put 空值表示删除,
// ! 这里只是为了实现完整的 SkipList 不会真正被上层调用
void SkipList::remove(const std::string &amp;key) {
  // TODO: Lab1.1 任务：实现删除键值对
}
</code></pre>
<p><code>remove</code>函数的实现的第一步是查询到指定的节点位置, 因此你可以尝试先实现<code>get</code>函数。</p>
<h1 id="4-get-实现"><a class="header" href="#4-get-实现">4 get 实现</a></h1>
<p>接下来实现<code>get</code>函数:</p>
<pre><code class="language-cpp">// 查找键值对
SkipListIterator SkipList::get(const std::string &amp;key, uint64_t tranc_id) {
  // spdlog::trace("SkipList--get({}) called", key);
  // ? 你可以参照上面的注释完成日志输出以便于调试
  // ? 日志为输出到你执行二进制所在目录下的log文件夹

  // TODO: Lab1.1 任务：实现查找键值对,
  // TODO: 并且你后续需要额外实现SkipListIterator中的TODO部分(Lab1.2)
  return SkipListIterator{};
}
</code></pre>
<p>可以看到, 我们的<code>get</code>返回的是一个<code>SkipListIterator</code>, 它是一个迭代器, 可以用来遍历<code>SkipList</code>中的元素。这一部分涉及<code>SkipList Iterator</code>的实现不会在文档中进行展开, 你需要阅读源码, 这也是一项基本能力(这部分代码很简单, 别怕:smile:)</p>
<blockquote>
<p>这里的迭代器调用构造函数就可以了, 目前的<code>SkipListIterator</code>实现了一部分, 关于自增等运算符重载, 你将在后续的任务中实现。</p>
</blockquote>
<h1 id="4-测试"><a class="header" href="#4-测试">4 测试</a></h1>
<p>当你完成上述操作后, <code>test/test_skiplist.cpp</code>中的部分单元测试你应该能够通过:</p>
<pre><code class="language-bash">✗ cd tiny-lsm
✗ xmake
✗ xmake run test_skiplist
[==========] Running 12 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 12 tests from SkipListTest
[ RUN      ] SkipListTest.BasicOperations
[       OK ] SkipListTest.BasicOperations (0 ms)
[ RUN      ] SkipListTest.LargeScaleInsertAndGet
[       OK ] SkipListTest.LargeScaleInsertAndGet (6 ms)
[ RUN      ] SkipListTest.LargeScaleRemove
[       OK ] SkipListTest.LargeScaleRemove (6 ms)
[ RUN      ] SkipListTest.DuplicateInsert
[       OK ] SkipListTest.DuplicateInsert (0 ms)
[ RUN      ] SkipListTest.EmptySkipList
[       OK ] SkipListTest.EmptySkipList (0 ms)
[ RUN      ] SkipListTest.RandomInsertAndRemove
[       OK ] SkipListTest.RandomInsertAndRemove (5 ms)
[ RUN      ] SkipListTest.MemorySizeTracking
[       OK ] SkipListTest.MemorySizeTracking (0 ms)
[ RUN      ] SkipListTest.Iterator
^C
</code></pre>
<p>到<code>SkipListTest.Iterator</code>前的单元测试你应该都能够通过, 卡在<code>SkipListTest.Iterator</code>是因为我们很没有实现迭代器相关功能。</p>
<p>恭喜你, 你已经完成了<code>SkipList</code>的基础<code>CRUD</code>实现。接下来你可以进行<a href="lab1/./lab1.2-Iterator-query.html">Lab1.2</a>了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-12-迭代器"><a class="header" href="#lab-12-迭代器">Lab 1.2 迭代器</a></h1>
<h1 id="1-概述"><a class="header" href="#1-概述">1 概述</a></h1>
<p>这一部分的内容很简单, 只需要补全跳表迭代器即可。跳表的迭代器基本上就是对<code>SkiplistNode</code>的最简化封装, 这一小节的代码量非常少, 也很简单, 不过重点是迭代器的设计和基类的继承关系。</p>
<p>我们先来看它继承了什么基类：</p>
<pre><code class="language-cpp">class SkipListIterator : public BaseIterator
</code></pre>
<p>这里的<code>BaseIterator</code>是所有组件的基类, 它的声明在<code>include/iterator/iterator.h</code>中。它是后续我们不同组件之间交互的桥梁。建议同学们认真读一下相关代码，很简单但很重要。</p>
<h1 id="2-迭代器补全"><a class="header" href="#2-迭代器补全">2 迭代器补全</a></h1>
<p>你需要补全<code>src/skiplist/skipList.cpp</code>中标记为<code>// TODO: Lab1.2</code>的迭代器函数：</p>
<pre><code class="language-cpp">
BaseIterator &amp;SkipListIterator::operator++() {
  // TODO: Lab1.2 任务：实现SkipListIterator的++操作符
  return *this;
}

bool SkipListIterator::operator==(const BaseIterator &amp;other) const {
  // TODO: Lab1.2 任务：实现SkipListIterator的==操作符
  return true;
}

bool SkipListIterator::operator!=(const BaseIterator &amp;other) const {
  // TODO: Lab1.2 任务：实现SkipListIterator的!=操作符
  return true;
}

SkipListIterator::value_type SkipListIterator::operator*() const {
  // TODO: Lab1.2 任务：实现SkipListIterator的*操作符
  return {"", ""};
}

IteratorType SkipListIterator::get_type() const {
  // TODO: Lab1.2 任务：实现SkipListIterator的get_type
  // ? 主要是为了熟悉基类的定义和继承关系
  return IteratorType::Undefined;
}
</code></pre>
<h1 id="3-测试"><a class="header" href="#3-测试">3 测试</a></h1>
<p>现在你应该能通过<code>test/test_skiplist.cpp</code>中的<code>SkipListTest.Iterator</code>单元测试了</p>
<p>没问题我们开始<code>Lab 1</code>的最后一部分: <a href="lab1/./lab1.3-range-query.html">Lab 1.3 范围查询</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-13-范围查询"><a class="header" href="#lab-13-范围查询">Lab 1.3 范围查询</a></h1>
<h1 id="1-范围查询的特性"><a class="header" href="#1-范围查询的特性">1 范围查询的特性</a></h1>
<p>根据之前的介绍我们了解到, 我们实现的跳表是一个有序数据结构, 而我们构建的数据库是<code>K00V00</code>数据库, 因此除了最基础的<code>CRUD</code>操作外, 我们还需要实现一个范围查询的功能。这些范围查询包括:</p>
<ol>
<li>前缀查询: 通过前缀查询, 我们可以查询以某个前缀开头的所有键值对。比如, 我们数据库中如果<code>k00ey</code>用<code>userxxx</code>标识用户数据, 可以查询以<code>"userxx"</code>开头的所有用户数据的键值对。</li>
<li>范围查询: 通过范围查询, 我们可以查询某个范围内的键值对。比如, 我们数据库中如果<code>k00ey</code>是学生的学号, 那么我们可以查询某个学号范围内的学生数据<code>[100, 200)</code>。</li>
</ol>
<p>以上的查询都存在一个特性: 他们是单调的查询, 也就是说在全局数据库中只会出现一个这样的区间。</p>
<p>例如我们有下面的键值对:</p>
<pre><code class="language-text">(k001, v001), (k002, v002), (k003, v003), (k004, v004), (k005, v005), (k006, v006), (k007, v007), (k008, v008), (k009, v009), (k010, v010)
</code></pre>
<ul>
<li>我们查询<code>key &gt;= k005 &amp;&amp; key &lt; k008</code>的范围, 我们可以得到:</li>
</ul>
<pre><code class="language-text">(k005, v005), (k006, v006), (k007, v007)`。
</code></pre>
<ul>
<li>我们查询<code>key前缀为k00</code>的键值对, 我们可以得到:</li>
</ul>
<pre><code class="language-text">`(k001, v001), (k002, v002), (k003, v003), (k004, v004), (k005, v005), (k006, v006), (k007, v007), (k008, v008), (k009, v009)`。
</code></pre>
<p>可以看到, 这些查询都是单调的, 也就是说, 全局数据库中只会出现一个这样的区间。而考虑到我们的数据库是有序的, 因此可以使用二分查询的方式, 确定查询区间的开始位置和结束位置, 以迭代器的形式返回查询结果即可。</p>
<h1 id="2-实现"><a class="header" href="#2-实现">2 实现</a></h1>
<h2 id="21-前缀查询"><a class="header" href="#21-前缀查询">2.1 前缀查询</a></h2>
<p>你需要实现这两个函数：</p>
<pre><code class="language-cpp">// 找到前缀的起始位置
// 返回第一个前缀匹配或者大于前缀的迭代器
SkipListIterator SkipList::begin_preffix(const std::string &amp;preffix) {
  // TODO: Lab1.3 任务：实现前缀查询的起始位置
  return SkipListIterator{};
}

// 找到前缀的终结位置
SkipListIterator SkipList::end_preffix(const std::string &amp;prefix) {
  // TODO: Lab1.3 任务：实现前缀查询的终结位置
  return SkipListIterator{};
}
</code></pre>
<p>注意的是, 这里迭代器返回的定义类似<code>STL</code>中迭代器<code>end</code>, 其并不属于指定的区间类, 也就是说区间的数学表达是<code>[begin, end)</code></p>
<h2 id="22-谓词查询"><a class="header" href="#22-谓词查询">2.2 谓词查询</a></h2>
<p>这里除了前缀查询外, 还包括各种其他的查询, 只要他们是单调的即可。因此我们给出了一种更通用的接口, 谓词查询, 只需要上层调用者提供一个谓词(<code>lambda</code>函数或者仿函数均可), 我们就可以实现各种单调区间的范围查询。</p>
<p>因此, 我们可以设计这样一个查询接口, 其接收一个谓词, 这个谓词的具体函数体说明此次查询是普通的范围查询、前缀匹配或者是其他的单条区间查询, 但要求结果一定在全局只位于一个连续区间中就可以。同时该谓词不能返回<code>bool</code>值, 而是类似字符串比较那样返回一个<code>int</code>值, 0 表示不匹配, 1 表示大于, -1 表示小于。这样我们才可以根据返回值确定下一步二分查找的方向。</p>
<p>我们需要逐层次实现这个支持谓词的查询接口，其返回一组迭代器表示<code>start</code>和<code>end</code>, 这里我们还是要利用<code>SkipList</code>的有序性多层不同步长的链表来实现快速的匹配查询。</p>
<p>你需要实现下面的函数:</p>
<pre><code class="language-cpp">// ? 这里单调谓词的含义是, 整个数据库只会有一段连续区间满足此谓词
// ? 例如之前特化的前缀查询，以及后续可能的范围查询，都可以转化为谓词查询
// ? 返回第一个满足谓词的位置和最后一个满足谓词的迭代器
// ? 如果不存在, 范围nullptr
// ? 谓词作用于key, 且保证满足谓词的结果只在一段连续的区间内, 例如前缀匹配的谓词
// ? predicate返回值:
// ?   0: 满足谓词
// ?   &gt;0: 不满足谓词, 需要向右移动
// ?   &lt;0: 不满足谓词, 需要向左移动
// ! Skiplist 中的谓词查询不会进行事务id的判断, 需要上层自己进行判断
std::optional&lt;std::pair&lt;SkipListIterator, SkipListIterator&gt;&gt;
SkipList::iters_monotony_predicate(
    std::function&lt;int(const std::string &amp;)&gt; predicate) {
  // TODO: Lab1.3 任务：实现谓词查询的起始位置
  return std::nullopt;
}
</code></pre>
<blockquote>
<p>Hint: 这里的思路其实也很简单, 推荐的思路如下:</p>
<ol>
<li>先逐次使用高<code>Level</code>的链表, 逐次降低, 找到满足谓词的区间的某一个节点<code>node1</code></li>
<li>根据找到的节点<code>node1</code>, 逐次向左移动, 直到找到第一个满足谓词的节点<code>node0</code></li>
<li>根据找到的节点<code>node1</code>, 逐次向右移动, 直到找到最后一个满足谓词的节点<code>node2</code></li>
<li>返回找到的节点<code>node0</code>和<code>node2</code></li>
</ol>
</blockquote>
<blockquote>
<p>看到这里你应该也明白了, 为什么实验的<code>Skiplist</code>的头文件定义采用了双向链表, 目的就是方便这里谓词查询链表节点方向移动的便捷性</p>
</blockquote>
<h1 id="3-测试-1"><a class="header" href="#3-测试-1">3 测试</a></h1>
<p>完成上面的函数后, 你应该可以通过除了<code>SkipListTest.TransactionId</code>外所有的<code>test/test_skiplist.cpp</code>的单元测试:</p>
<pre><code class="language-cpp">✗ xmake
[100%]: build ok, spent 5.785s
✗ xmake run test_skiplist
[==========] Running 12 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 12 tests from SkipListTest
[ RUN      ] SkipListTest.BasicOperations
[       OK ] SkipListTest.BasicOperations (0 ms)
[ RUN      ] SkipListTest.LargeScaleInsertAndGet
[       OK ] SkipListTest.LargeScaleInsertAndGet (7 ms)
[ RUN      ] SkipListTest.LargeScaleRemove
[       OK ] SkipListTest.LargeScaleRemove (6 ms)
[ RUN      ] SkipListTest.DuplicateInsert
[       OK ] SkipListTest.DuplicateInsert (0 ms)
[ RUN      ] SkipListTest.EmptySkipList
[       OK ] SkipListTest.EmptySkipList (0 ms)
[ RUN      ] SkipListTest.RandomInsertAndRemove
[       OK ] SkipListTest.RandomInsertAndRemove (6 ms)
[ RUN      ] SkipListTest.MemorySizeTracking
[       OK ] SkipListTest.MemorySizeTracking (0 ms)
[ RUN      ] SkipListTest.Iterator
[       OK ] SkipListTest.Iterator (0 ms)
[ RUN      ] SkipListTest.IteratorPreffix
[       OK ] SkipListTest.IteratorPreffix (0 ms)
[ RUN      ] SkipListTest.ItersPredicate_Base
[       OK ] SkipListTest.ItersPredicate_Base (0 ms)
[ RUN      ] SkipListTest.ItersPredicate_Large
[       OK ] SkipListTest.ItersPredicate_Large (5 ms)
[ RUN      ] SkipListTest.TransactionId^
</code></pre>
<blockquote>
<p><code>SkipListTest.TransactionId</code>单元测试是<code>Lab 5.1</code>的内容, 你可以先忽略它。</p>
</blockquote>
<p>此外, 单元测试目前并没有规定你的实现的效率, 但你的实现在<code>release</code>模式下, 不应该超过<code>100ms</code>, (<code>30ms</code>以内最佳)</p>
<p>到此为止, <code>Lab1</code>的实验结束, 恭喜你完成本实验!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-2-memtabele"><a class="header" href="#lab-2-memtabele">Lab 2 MemTabele</a></h1>
<p>本<code>Lab</code>中, 你将基于之前实现的<code>Skiplist</code>, 将其组织成内存中负责存储键值对的组件<code>MemTable</code>。</p>
<blockquote>
<p>提示: 强烈建议你自己创建一个分组实现<code>Lab</code>的内容, 并在每次新的<code>Lab</code>开始时进行如下同步操作:</p>
<pre><code class="language-bash">git pull origin lab
git checkout your_branch
git merge lab
</code></pre>
<p>如果你发现项目仓库的代码没有指导书中的 TODO 标记的话, 证明你需要运行上述命令更新代码了</p>
</blockquote>
<h2 id="1-memtable的构造原理"><a class="header" href="#1-memtable的构造原理">1 MemTable的构造原理</a></h2>
<p>再次回顾我们的整体架构图：</p>
<p><img src="lab2/../images/intro/tiny-lsm-arch.drawio.png" alt="Fig 1" /></p>
<p><code>MemTable</code>负责存储内存中的键值对数据，其存储的基础容器即为<code>Skiplist</code>。<code>SkipList</code>被划分为2组：<code>current_table</code>和<code>frozen_table</code>。<code>current_table</code>可读可写，并是唯一写入的<code>SkipList</code>，<code>frozen_table</code>是只读状态，用于存储已经写入的键值对数据。<code>current_table</code>容量超出阈值即转化为<code>frozen_table</code>中的一个。</p>
<p>为什么要如此设计呢? 答案是为了提升并发性, 我们的查询与写入的逻辑如下图所示:</p>
<p><img src="lab2/../images/Lab2/MemTable.drawio.png" alt="Fig 2" /></p>
<p>我们在写入时始终只对活跃的<code>current_table</code>进行写入，而查询时则同时对<code>current_table</code>和<code>frozen_table</code>进行查询。这样, 如果我们不将内存表进行划分的话, 查询和写入将同时对一张大的<code>SkipList</code>进行操作, 这将导致并发度降低。反之, 我们将<code>MemTable</code>划分为<code>current_table</code>和<code>frozen_tables</code>后, 我们可以在写入<code>current_table</code>的同时对<code>frozen table</code>进行查询, 大幅度提升了并发量。</p>
<h2 id="2-skiplist查询的优先级"><a class="header" href="#2-skiplist查询的优先级">2 <code>SkipList</code>查询的优先级</a></h2>
<p>由之前的理论描述所知, 我们的<code>frozen_tables</code>包含多份<code>Skiplist</code>, 而<code>LSM Tree</code>的写入是追加写入, 后写入的数据会覆盖前面的数据。因此，查询时，我们应该按照从新到旧的顺序查询<code>frozen_tables</code>。如同架构图中<code>Get</code>的查询路径中<code>Path 1.1, Path 1.2, Path 1.3, Path 1.4</code>分别按照从新到旧的顺序查询<code>Skiplist</code>, 一旦查询成功即返回。</p>
<h2 id="3-思考"><a class="header" href="#3-思考">3 思考</a></h2>
<blockquote>
<p>本实验的惯例是先介绍对应<code>Lab</code>的基本原理, 再抛出一些思考题，你可以简单地对思考题给出一个心智层面的解决方案, 然后开启后续的<code>Lab</code>。</p>
</blockquote>
<p>现在又到了我们的思考环节, 根据之前的描述, 将<code>SkipList</code>组织为<code>MemTable</code>好像很简单。但是别忘了，我们之前讲述的都是最基本的单点查询和写入，如果是更复杂的情形呢？ 比如：</p>
<ol>
<li>要查询前缀为<code>xxx</code>的所有键值对
<ol>
<li>很多个<code>Skiplist</code>中都可能存在这样的键值对, 我们需要依次遍历吗?</li>
<li>有些旧<code>Skiplist</code>中的键值对已经被更新的<code>Skiplist</code>的数据覆盖了, 是否需要过滤? 如何过滤?</li>
</ol>
</li>
<li>如何为<code>MemTable</code>实现迭代器?
<ol>
<li><code>KV</code>数据库的迭代器肯定是按照<code>key</code>的顺序从小大大排布</li>
<li>多个<code>Skiplist</code>的键值对如何进行整合, 从而也实现从小大大的排布?</li>
</ol>
</li>
</ol>
<p>通过本节对<code>MemTable</code>的基本介绍, 以及进阶问题的思考, 你可以开始[Lab ]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-21-简单-crud"><a class="header" href="#lab-21-简单-crud">Lab 2.1 简单 CRUD</a></h1>
<h1 id="1-准备工作-1"><a class="header" href="#1-准备工作-1">1 准备工作</a></h1>
<p>本小节需要你修改的代码：
-<code>src/memtable/memtable.cpp</code></p>
<ul>
<li><code>include/memtable/memtable.h</code> (Optional)</li>
</ul>
<p>同样的，我们先看看代码的头文件东一，从而了解我们的<code>MemTable</code>的整体实现思路:</p>
<pre><code class="language-cpp">class MemTable {
    // ...
private:
  std::shared_ptr&lt;SkipList&gt; current_table;
  std::list&lt;std::shared_ptr&lt;SkipList&gt;&gt; frozen_tables;
  size_t frozen_bytes;
  std::shared_mutex frozen_mtx; // 冻结表的锁
  std::shared_mutex cur_mtx;    // 活跃表的锁
};
</code></pre>
<p>这里我们根据之前的原理介绍, 对之前的<code>SkipList</code>简单包装, 使用<code>list</code>保证一系列冻结的<code>Skiplist</code>。这里建议的规定是：
<strong>最新的<code>Skiplist</code>放在<code>list</code>的<code>head</code>位置，最旧的<code>Skiplist</code>放在<code>list</code>的<code>tail</code>位置。</strong></p>
<p>此外, 你在头文件中除了基础的<code>CRUD</code>函数外, 还会看到这个函数:</p>
<pre><code class="language-cpp">  std::shared_ptr&lt;SST&gt; flush_last(SSTBuilder &amp;builder, std::string &amp;sst_path,
                                  size_t sst_id,
                                  std::shared_ptr&lt;BlockCache&gt; block_cache);
</code></pre>
<p>这个函数不是本<code>Lab</code>要求实现的函数, 但可以先进行简单的介绍便于认知整体架构。当<code>MemTable</code>中的数据量达到阈值时, 会调用这个函数将最古老的一个<code>SST</code>进行持久化, 形成一个<code>Level 0</code>的<code>SST</code>, 因此你可以理解为, <code>Skiplist</code>是和<code>Level 0 SST</code>的数据来源。</p>
<h1 id="2-put-的实现-1"><a class="header" href="#2-put-的实现-1">2 put 的实现</a></h1>
<p>你首先要实现的是<code>put</code>系列的函数:</p>
<pre><code class="language-cpp">void MemTable::put_(const std::string &amp;key, const std::string &amp;value,
                    uint64_t tranc_id) {
  // TODO: Lab2.1 无锁版本的 put
}

void MemTable::put(const std::string &amp;key, const std::string &amp;value,
                   uint64_t tranc_id) {
  // TODO: Lab2.1 有锁版本的 put
}

void MemTable::put_batch(
    const std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; &amp;kvs,
    uint64_t tranc_id) {
  // TODO: Lab2.1 有锁版本的 put_batch
}
</code></pre>
<p>这里的<code>put</code>有多个版本, 分别是无锁版本和有锁版本的单次<code>put</code>以及有锁版本的批量<code>put</code>, 你必须按照语义实现这些函数, 因为后续上层组件调用的函数默认携带<code>_</code>后缀的函数版本是无锁操作版本。</p>
<p>同时简单讲述以下如此设计的原因，某些并发控制只需要当前的<code>MemTable</code>组件控制即可, 但有些并发控制场景设计多个组件, 需要再上层进行, 例如后续事务提交时的冲突检测就是一个典型的案例。</p>
<blockquote>
<p>Hint: 你不仅仅需要做简单的<code>API</code>调用, 还需要判断什么时候<code>Skiplist</code>的容量超出阈值需要进行冻结</p>
</blockquote>
<h1 id="3-get-的实现"><a class="header" href="#3-get-的实现">3 get 的实现</a></h1>
<p>接下来实现<code>get</code>的一系列函数, 同样包括无锁版本与有锁版本, 并且你还需要实现不同部分的分阶段查询:</p>
<pre><code class="language-cpp">SkipListIterator MemTable::cur_get_(const std::string &amp;key, uint64_t tranc_id) {
  // 检查当前活跃的memtable
  // TODO: Lab2.1 从活跃跳表中查询
  return SkipListIterator{};
}

SkipListIterator MemTable::frozen_get_(const std::string &amp;key,
                                       uint64_t tranc_id) {
  // TODO: Lab2.1 从冻结跳表中查询
  // ? 你需要尤其注意跳表的遍历顺序
  // ? tranc_id 参数可暂时忽略, 直接插入即可
  return SkipListIterator{};
  ;
}

SkipListIterator MemTable::get(const std::string &amp;key, uint64_t tranc_id) {
  // TODO: Lab2.1 查询, 建议复用 cur_get_ 和 frozen_get_
  // ? 注意并发控制

  return SkipListIterator{};
}

SkipListIterator MemTable::get_(const std::string &amp;key, uint64_t tranc_id) {
  // TODO: Lab2.1 查询, 无锁版本
}
</code></pre>
<h1 id="4-remove-实现"><a class="header" href="#4-remove-实现">4 remove 实现</a></h1>
<p>最后, 插入<code>value</code>为空的键值对表示对数据的删除标记, 同样有不同的版本:</p>
<pre><code class="language-cpp">void MemTable::remove_(const std::string &amp;key, uint64_t tranc_id) {
  // TODO Lab2.1 无锁版本的remove
}

void MemTable::remove(const std::string &amp;key, uint64_t tranc_id) {
  // TODO Lab2.1 有锁版本的remove
}

void MemTable::remove_batch(const std::vector&lt;std::string&gt; &amp;keys,
                            uint64_t tranc_id) {
  // TODO Lab2.1 有锁版本的remove_batch
}
</code></pre>
<h1 id="5-冻结活跃表"><a class="header" href="#5-冻结活跃表">5 冻结活跃表</a></h1>
<p><code>Skiplist</code>的容量超出阈值需要进行冻结时需要调用下述函数。</p>
<p>至于这个函数的调用实际，作者建议是在每次<code>put</code>后检查容量是否超出阈值, 然后同步地调用该函数, 当然你也可以启用一个后台线程进行周期性检查。</p>
<pre><code class="language-cpp">void MemTable::frozen_cur_table_() {
  // TODO: 冻结活跃表
}

void MemTable::frozen_cur_table() {
  // TODO: 冻结活跃表, 有锁版本
}
</code></pre>
<blockquote>
<p><strong><code>Hint</code></strong></p>
<ol>
<li><code>src/config/config.cpp</code>中定义了一个配置文件的单例, 其会解析项目目录中的<code>config.toml</code>配置文件, 其中包含了各种阈值的推荐值</li>
<li>你可以使用类似<code>TomlConfig::getInstance().getLsmPerMemSizeLimit()</code>的方法获取配置文件中定义的常量</li>
<li>你可以修改<code>config.toml</code>配置文件的值, 但尽量不要新增配置项, 否则你需要自行修改<code>src/config/config.cpp</code>中的解析函数</li>
</ol>
</blockquote>
<h1 id="6-测试"><a class="header" href="#6-测试">6 测试</a></h1>
<p>当你完成上述所有功能后, 你可以通过如下测试:</p>
<pre><code class="language-bash">✗ xmake
✗ xmake run test_memtable
[==========] Running 9 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 9 tests from MemTableTest
[ RUN      ] MemTableTest.BasicOperations
[       OK ] MemTableTest.BasicOperations (2 ms)
[ RUN      ] MemTableTest.RemoveOperations
[       OK ] MemTableTest.RemoveOperations (0 ms)
[ RUN      ] MemTableTest.FrozenTableOperations
[       OK ] MemTableTest.FrozenTableOperations (0 ms)
[ RUN      ] MemTableTest.LargeScaleOperations
[       OK ] MemTableTest.LargeScaleOperations (0 ms)
[ RUN      ] MemTableTest.MemorySizeTracking
[       OK ] MemTableTest.MemorySizeTracking (0 ms)
[ RUN      ] MemTableTest.MultipleFrozenTables
[       OK ] MemTableTest.MultipleFrozenTables (0 ms)
[ RUN      ] MemTableTest.ConcurrentOperations
^C
</code></pre>
<p><code>ConcurrentOperations</code>需要你实现后续的迭代器功能。</p>
<p>接下来你可以开启下一小节的<a href="lab2/./lab2.2-iterator.html">Lab</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-22-迭代器"><a class="header" href="#lab-22-迭代器">Lab 2.2 迭代器</a></h1>
<h1 id="1-迭代器的作用"><a class="header" href="#1-迭代器的作用">1 迭代器的作用</a></h1>
<p>我们需要实现整个<code>MemTable</code>的迭代器, 这算是本<code>Lab</code>的一个难点, 因为新的<code>SkipList</code>中的元素会导致旧的<code>SkipList</code>的部分元素失效, 因此不能简单地将不同<code>SkipList</code>的遍历结果拼接起来就完事儿。</p>
<p>试想下面这个场景：</p>
<pre><code class="language-bash">SkipList0: ("k1", "v1") -&gt; ("k4", "") -&gt; ("k5", "v3")
SkipList1: ("k2", "v2") -&gt; ("k3", "v3") -&gt; ("k4", "v4")
</code></pre>
<p><code>SkipList0</code>中的<code>("k4", "")</code>表示删除了<code>"k4"</code>, 因此如果我们先消耗了<code>SkipList0</code>的迭代器, 那么<code>SkipList1</code>中就无法获取<code>"k4"</code>的不合法性, 因此需要对不同<code>SkipList</code>的迭代器进行<code>merge</code>操作来删除这些无效的元素。</p>
<p>本实验的建议方案是:
可以维护一个堆，堆首先根据<code>key</code>排序, 然后根据<code>SkipList id</code>排序, 因此相同的<code>key</code>, 后插入的记录肯定更靠近堆顶(因为<code>SkipList id</code>越小表示其越新), 因此堆顶的某个<code>key</code>一定是整个<code>MemTable</code>中该<code>key</code>的最新记录, 迭代器对该<code>key</code>只需要堆顶的这一个元素, 其余在取出堆顶后即可全部移除(因为首先按照<code>key</code>排序, 所以他们一定连续出现在堆顶)</p>
<h1 id="2-堆去重的原理"><a class="header" href="#2-堆去重的原理">2 堆去重的原理</a></h1>
<p>我们假设有以下两个 <code>SkipList：</code></p>
<pre><code class="language-text">SkipList0 (id=0): ("k1", "v1") -&gt; ("k4", "") -&gt; ("k5", "v3")   // 最新的
SkipList1 (id=1): ("k2", "v2") -&gt; ("k3", "v3") -&gt; ("k4", "v4")
</code></pre>
<p>我们借助之前<code>Skiplist</code>的迭代器, 遍历各个<code>Skiplist</code>, 把所有键值对按 <code>key</code> 排序后放入堆，排序依据是：</p>
<ul>
<li>先按 <code>key</code> 升序，即<code>key</code>越小越靠近堆顶</li>
<li>对于相同的 <code>key</code>，选择<code>tranc_id</code> 较大（越新）的优先（越靠近堆顶）(这一条你可暂时哦忽略, 测试中<code>tranc_id</code>都是0)</li>
<li>按照<code>SkipList</code>来源的新旧排序, 新<code>SkipList</code>的键值对更靠近堆顶(这里的<code>id</code>是构建堆时手动赋予的)</li>
</ul>
<blockquote>
<p>最后的排序依据中, 这个新旧的顺序需要你手动指定, 无论你实现的排序是更大的<code>id</code>表示更新的<code>SKiplist</code>还是更小的<code>id</code>表示更新的<code>SKiplist</code>, 自身逻辑自洽即可
建议将更新的<code>Skiplist</code>用更大的<code>id</code>标识, 因为<code>id</code>随新的<code>Skiplist</code>增长是很正常的事情</p>
</blockquote>
<p>遍历迭代器, 并逐一构建堆元素插入堆中, 最终的堆的示意图为:</p>
<div align="center">
  <img src="lab2/../images/Lab2/Heap.png" width="400">
</div>
<p>这里可以看到, <code>k4</code>的键值对中, 更新的跳表中的键值对更靠近堆顶, 当我们遍历这个堆并不断弹出元素时, 相同<code>key</code>的元素只能被迭代器(这个堆肯定是迭代器封装的一个成员变量)对外暴露一次, 其余相同<code>key</code>的键值对进行丢弃即可, 这样我们就能利用类似堆排序的功能, 同时完成了排序和去重。</p>
<h1 id="3-基于堆的迭代器实现"><a class="header" href="#3-基于堆的迭代器实现">3 基于堆的迭代器实现</a></h1>
<h2 id="31-代码框架介绍"><a class="header" href="#31-代码框架介绍">3.1 代码框架介绍</a></h2>
<p>因此，本实验你首先要基于上述原理的介绍实现一个基于堆的迭代器。</p>
<p>本小节需要你修改的代码：</p>
<ul>
<li><code>src/iterator/iterator.cpp</code></li>
<li><code>include/iterator/iterator.h</code> (Optional)</li>
<li><code>src/memtable/memtable.cpp</code></li>
<li><code>include/memtable/memtable.h</code> (Optional)</li>
</ul>
<p>首先是<code>SearchItem</code>, 我们来看定义:</p>
<pre><code class="language-cpp">// *************************** SearchItem ***************************
struct SearchItem {
  std::string key_;
  std::string value_;
  uint64_t tranc_id_;
  int idx_;
  int level_; // 来自sst的level

  SearchItem() = default;
  SearchItem(std::string k, std::string v, int i, int l, uint64_t tranc_id)
      : key_(std::move(k)), value_(std::move(v)), idx_(i), level_(l),
        tranc_id_(tranc_id) {}
};

bool operator&lt;(const SearchItem &amp;a, const SearchItem &amp;b);
bool operator&gt;(const SearchItem &amp;a, const SearchItem &amp;b);
bool operator==(const SearchItem &amp;a, const SearchItem &amp;b);
</code></pre>
<p>其就是我们之前提到的每个堆节点的数据结构, 这里的构造函数中, <code>k, v, i</code>即为<code>key</code>, <code>value</code>, <code>id</code>(跳表的), <code>l</code>表示来源的层级, 现在我们都是在内存操作, 设为<code>0</code>即可, <code>tranc_id</code>不需要你理解, 直接赋值即可。</p>
<p>然后是你要实现的迭代器<code>HeapIterator</code>的定义:</p>
<pre><code class="language-cpp">class HeapIterator : public BaseIterator {
public:
  HeapIterator() = default;
  HeapIterator(std::vector&lt;SearchItem&gt; item_vec, uint64_t max_tranc_id);

  // ...

private:
  std::priority_queue&lt;SearchItem, std::vector&lt;SearchItem&gt;,
                      std::greater&lt;SearchItem&gt;&gt;
      items;
  mutable std::shared_ptr&lt;value_type&gt; current; // 用于存储当前元素
  uint64_t max_tranc_id_ = 0;
};
</code></pre>
<p>这里的<code>priority_queue</code>就是我们之前提到的堆, <code>C++</code>的堆实际上就是优先队列。</p>
<blockquote>
<p>在<code>C++</code>中，当使用<code> std::priority_queue</code> 来实现小根堆（min-heap）时，你需要使用<code> std::greater&lt;SearchItem&gt;</code> 作为比较函数对象。感兴趣的同学可以查一查为什么要这么设计。</p>
</blockquote>
<h2 id="32-实现-searchitem-的比较规则"><a class="header" href="#32-实现-searchitem-的比较规则">3.2 实现 <code>SearchItem</code> 的比较规则</a></h2>
<pre><code class="language-cpp">bool operator&lt;(const SearchItem &amp;a, const SearchItem &amp;b) {
  // TODO: Lab2.2 实现比较规则
  return true;
}

bool operator&gt;(const SearchItem &amp;a, const SearchItem &amp;b) {
  // TODO: Lab2.2 实现比较规则
  return true;
}

bool operator==(const SearchItem &amp;a, const SearchItem &amp;b) {
  // TODO: Lab2.2 实现比较规则
  return true;
}
</code></pre>
<p>这里你需要按照之前介绍的比较规则进行代码补全。</p>
<h2 id="33-实现构造函数"><a class="header" href="#33-实现构造函数">3.3 实现构造函数</a></h2>
<p>接下来你需要实现<code>HeapIterator</code>的构造函数, 其参数就是已经遍历了所有<code>Skiplist</code>的迭代器构造的<code>vector</code>, <code>max_tranc_id</code>你可以暂时忽略:</p>
<pre><code class="language-cpp">HeapIterator::HeapIterator(std::vector&lt;SearchItem&gt; item_vec,
                           uint64_t max_tranc_id)
    : max_tranc_id_(max_tranc_id) {
  // TODO: Lab2.2 实现 HeapIterator 构造函数
}
</code></pre>
<blockquote>
<p>Hint: 构造完堆后, 是否需要额外的一些初始化的滤除?</p>
</blockquote>
<h2 id="34-实现自增函数"><a class="header" href="#34-实现自增函数">3.4 实现自增函数</a></h2>
<p>接下来自增函数是最重要的, 自增函数的逻辑是:</p>
<ol>
<li>自增后的<code>key</code>不能是之前相同的<code>key</code>, 如果是(以为着实际上被前者覆写了), 则跳过</li>
<li>自增后的键值对不能是删除标记, 即<code>value</code>为空</li>
</ol>
<pre><code class="language-cpp">BaseIterator &amp;HeapIterator::operator++() {
  // TODO: Lab2.2 实现 ++ 重载
  return *this;
}
</code></pre>
<p>同时, 这些辅助函数的实现有助于你完成<code>:operator++()</code>和之前的构造函数:</p>
<pre><code class="language-cpp">bool HeapIterator::top_value_legal() const {
  // TODO: Lab2.2 判断顶部元素是否合法
  // ? 被删除的值是不合法
  // ? 不允许访问的事务创建或更改的键值对不合法(暂时忽略)
  return true;
}

void HeapIterator::skip_by_tranc_id() {
  // TODO: Lab2.2 后续的Lab实现, 只是作为标记提醒
}
</code></pre>
<h2 id="34-其他运算符重载函数"><a class="header" href="#34-其他运算符重载函数">3.4 其他运算符重载函数</a></h2>
<p>其他运算符重载函数就简单了很多, 但仍然是对你代码理解的考验:</p>
<pre><code class="language-cpp">HeapIterator::pointer HeapIterator::operator-&gt;() const {
  // TODO: Lab2.2 实现 -&gt; 重载
  return nullptr;
}

HeapIterator::value_type HeapIterator::operator*() const {
  // TODO: Lab2.2 实现 * 重载
  return {};
}

BaseIterator &amp;HeapIterator::operator++() {
  // TODO: Lab2.2 实现 ++ 重载
  return *this;
}

bool HeapIterator::operator==(const BaseIterator &amp;other) const {
  // TODO: Lab2.2 实现 == 重载
  return true;
}

bool HeapIterator::operator!=(const BaseIterator &amp;other) const {
  // TODO: Lab2.2 实现 != 重载
  return true;
}
</code></pre>
<p>其中<code>-&gt;</code>运算符重载, 你可以直接利用已有的成员变量<code>mutable std::shared_ptr&lt;value_type&gt; current</code>, 返回器地址, 但你需要在构造函数和自增函数中对其进行正确的初始化和重置, 下面这个函数即为初始化和重置的逻辑实现:</p>
<pre><code class="language-cpp">void HeapIterator::update_current() const {
  // current 缓存了当前键值对的值, 你实现 -&gt; 重载时可能需要
  // TODO: Lab2.2 更新当前缓存值
}
</code></pre>
<h1 id="4-memtable的迭代器"><a class="header" href="#4-memtable的迭代器">4 MemTable的迭代器</a></h1>
<p>接下来, 有了<code>HeapIterator</code>, 你可以实现<code>MemTable</code>组件的全局迭代器了:</p>
<pre><code class="language-cpp">HeapIterator MemTable::begin(uint64_t tranc_id) {
  // TODO Lab 2.2 MemTable 的迭代器
  return {};
}

HeapIterator MemTable::end() {
  // TODO Lab 2.2 MemTable 的迭代器
  return HeapIterator{};
}
</code></pre>
<p>这里的逻辑就是利用之前实现的<code>HeapIterator</code>对整个<code>MemTable</code>进行遍历。</p>
<h1 id="5-测试"><a class="header" href="#5-测试">5 测试</a></h1>
<p>当你完成上述所有功能后, 你可以通过如下测试:</p>
<pre><code class="language-bash">✗ xmake
✗ xmake run test_memtable
[==========] Running 9 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 9 tests from MemTableTest
[ RUN      ] MemTableTest.BasicOperations
[       OK ] MemTableTest.BasicOperations (0 ms)
[ RUN      ] MemTableTest.RemoveOperations
[       OK ] MemTableTest.RemoveOperations (0 ms)
[ RUN      ] MemTableTest.FrozenTableOperations
[       OK ] MemTableTest.FrozenTableOperations (0 ms)
[ RUN      ] MemTableTest.LargeScaleOperations
[       OK ] MemTableTest.LargeScaleOperations (0 ms)
[ RUN      ] MemTableTest.MemorySizeTracking
[       OK ] MemTableTest.MemorySizeTracking (0 ms)
[ RUN      ] MemTableTest.MultipleFrozenTables
[       OK ] MemTableTest.MultipleFrozenTables (0 ms)
[ RUN      ] MemTableTest.IteratorComplexOperations
[       OK ] MemTableTest.IteratorComplexOperations (0 ms)
[ RUN      ] MemTableTest.ConcurrentOperations
[       OK ] MemTableTest.ConcurrentOperations (601 ms)
[ RUN      ] MemTableTest.PreffixIter
[       OK ] MemTableTest.PreffixIter (0 ms)
[----------] 9 tests from MemTableTest (602 ms total)

[----------] Global test environment tear-down
[==========] 9 tests from 1 test suite ran. (602 ms total)
[  PASSED  ] 9 tests.
</code></pre>
<p>接下来你可以开启下一小节的<a href="lab2/./lab2.3-range-query.html">Lab</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-23-范围查询"><a class="header" href="#lab-23-范围查询">Lab 2.3 范围查询</a></h1>
<h1 id="1-概述-1"><a class="header" href="#1-概述-1">1 概述</a></h1>
<p>还记得我们对<code>Skiplist</code>实现了前缀查询和谓词查询吗, 他们本质上都是范围查询, 这一小节, 你将基于已有的<code>Skiplist</code>的前缀查询和谓词查询接口, 实现<code>MemTable</code>的谓词查询。</p>
<p>本小节需要你修改的代码：
-<code>src/memtable/memtable.cpp</code></p>
<ul>
<li><code>include/memtable/memtable.h</code> (Optional)</li>
</ul>
<h1 id="2-实现-iters_preffix"><a class="header" href="#2-实现-iters_preffix">2 实现 iters_preffix</a></h1>
<pre><code class="language-cpp">HeapIterator MemTable::iters_preffix(const std::string &amp;preffix,
                                     uint64_t tranc_id) {

  // TODO Lab 2.3 MemTable 的前缀迭代器

  return {};
}
</code></pre>
<p>你需要借助<code>Skiplist</code>的<code>begin_preffix</code>完成这个<code>MemTable::iters_preffix</code>, 你可以从返回值类型推断出, 我们仍然需要借助<code>HeapIterator</code>进行去重和排序。</p>
<p>这里需要注意的还是自定义的排序<code>id</code>(就是<code>SearchItem</code>里面的成员变量<code>idx_</code>), 你需要在构造<code>HeapIterator</code>手动赋予<code>idx_</code>正确的整型值。</p>
<p>另外，<code>tranc_id</code>相关的滤除操作你可以暂时忽略, 直接传入<code>SearchItem</code>的构造函数即可。</p>
<blockquote>
<p>需要注意的是, 这个返回的迭代器从语义上是<code>begin</code>迭代器, 其使用方式是判断自身是否<code>is_valid</code>()以及<code>is_end()</code>, 不同于<code>C++ STL</code>中给定一对迭代器确定范围的风格。这也算是作者前期项目设计的不足之处，介于次代码和实验还是初版，能用能跑就行。</p>
</blockquote>
<h1 id="3-实现-iters_monotony_predicate"><a class="header" href="#3-实现-iters_monotony_predicate">3 实现 iters_monotony_predicate</a></h1>
<pre><code class="language-cpp">std::optional&lt;std::pair&lt;HeapIterator, HeapIterator&gt;&gt;
MemTable::iters_monotony_predicate(
    uint64_t tranc_id, std::function&lt;int(const std::string &amp;)&gt; predicate) {
  // TODO Lab 2.3 MemTable 的谓词查询迭代器起始范围
  return std::nullopt;
}
</code></pre>
<p>和<code>iters_preffix</code>类似, 只不过查询逻辑从特化的前缀查询变成了适用性更广泛的谓词查询, 注意事项也都差不多, 同样是借助<code>Skiplist</code>的<code>iters_monotony_predicate(predicate)</code>获取初步的结果, 再用<code>HeapIterator</code>区中。</p>
<h1 id="4-测试-1"><a class="header" href="#4-测试-1">4 测试</a></h1>
<p>完成上面的函数后, 你应该可以通过所有的test/test_memtable.cpp的单元测试:</p>
<pre><code class="language-bash">✗ xmake
✗ xmake run test_memtable
[==========] Running 12 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 12 tests from MemTableTest
[ RUN      ] MemTableTest.BasicOperations
[       OK ] MemTableTest.BasicOperations (0 ms)
[ RUN      ] MemTableTest.RemoveOperations
[       OK ] MemTableTest.RemoveOperations (0 ms)
[ RUN      ] MemTableTest.FrozenTableOperations
[       OK ] MemTableTest.FrozenTableOperations (0 ms)
[ RUN      ] MemTableTest.LargeScaleOperations
[       OK ] MemTableTest.LargeScaleOperations (1 ms)
[ RUN      ] MemTableTest.MemorySizeTracking
[       OK ] MemTableTest.MemorySizeTracking (0 ms)
[ RUN      ] MemTableTest.MultipleFrozenTables
[       OK ] MemTableTest.MultipleFrozenTables (0 ms)
[ RUN      ] MemTableTest.IteratorComplexOperations
[       OK ] MemTableTest.IteratorComplexOperations (0 ms)
[ RUN      ] MemTableTest.ConcurrentOperations
[       OK ] MemTableTest.ConcurrentOperations (604 ms)
[ RUN      ] MemTableTest.PreffixIter
[       OK ] MemTableTest.PreffixIter (0 ms)
[ RUN      ] MemTableTest.IteratorPreffix
[       OK ] MemTableTest.IteratorPreffix (0 ms)
[ RUN      ] MemTableTest.ItersPredicate_Base
[       OK ] MemTableTest.ItersPredicate_Base (0 ms)
[ RUN      ] MemTableTest.ItersPredicate_Large
[       OK ] MemTableTest.ItersPredicate_Large (13 ms)
[----------] 12 tests from MemTableTest (620 ms total)

[----------] Global test environment tear-down
[==========] 12 tests from 1 test suite ran. (620 ms total)
[  PASSED  ] 12 tests.
</code></pre>
<p>到此为止, <code>Lab2</code>的实验结束, 恭喜你完成本实验!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-3-sst"><a class="header" href="#lab-3-sst">Lab 3 SST</a></h1>
<h1 id="1-概述-2"><a class="header" href="#1-概述-2">1 概述</a></h1>
<p>这一章的开头我们再次搬出我们的经典架构图:</p>
<p><img src="lab3/../images/intro/tiny-lsm-arch.drawio.png" alt="Fig 1" /></p>
<p>通过<a href="lab3/../lab1/lab1-skiplist.html">Lab1</a>和<a href="lab3/../lab2/lab2-memtable.html">Lab2</a>的学习，我们已经初步完成了<code>LSM Tree</code>中内存的基础读写组件, 这一章我们将眼光从内存迁移到磁盘, 实现<code>SST</code>相关的内容。</p>
<p>从架构图中我们知道，<code>SST</code>文件是<code>LSM Tree</code>中持久化的存储文件，其中<code>Level 0</code>的<code>SST</code>存储了<code>MemTable</code>中单个<code>Skiplist</code>的数据，并且提供了<code>LSM Tree</code>中数据的有序性。因此对于一个磁盘中的文件, 我们肯定需要实现文件的编解码设计。其中编码设计用于将内存的<code>Skiplist</code>类的实例转化为<code>SST</code>文件, 而读取<code>SST</code>中的某些键值对时我们需要将文件进行解码并读取数据到内存。因此这一章中编解码是一大主题内容。而且相对之前常驻内存的<code>MemTable</code>而言, 这里的编解码代码的实现更为复杂, 尤其是<code>Debug</code>难度比之前要大上不少。</p>
<p>此外，我们从架构图中还了解到，不同<code>Level</code>的<code>SST</code>是需要再容量超出阈值时进行合并(<code>Compact</code>)的, 但<code>Compact</code>在本实验中是由更上层的控制结构实现的, 因此本节实验你不需要担心<code>Compact</code>, 这是后续<code>Lab</code>的内容, 这里提一嘴只是为了有助于从理论上理解其运行机制。</p>
<h1 id="2-sst-的结构"><a class="header" href="#2-sst-的结构">2 SST 的结构</a></h1>
<p>从架构图中我们了解到，不同<code>Level</code>之间的容量呈指数增长, 其中最小的<code>Level 0</code>的<code>SST</code>也是<code>SkipList</code>的大小, 而<code>SkipList</code>实例在内存中是由多个链表组成的, 查询速度基本上和红黑树差不多。但假若我们想从<code>SST</code>中查一个键值对，总不可能把整个<code>SST</code>都解码放到内存中吧? 要知道高层<code>Level</code>的<code>SST</code>是可以轻易增长到<code>GB</code>的大小的。因此，<code>SST</code>必须进行内部的切分, 这里切分形成的一块数据我们称之为<code>Block</code>。因此对<code>Block</code>的组织管理就是<code>SST</code>设计的核心内容。<code>Tiny-LSM</code>的<code>SST</code>文件结构如下:</p>
<p><img src="lab3/../images/lab3/SST.drawio.png" alt="SST-Arch" /></p>
<p><code>SST</code>文件由多个<code>Block</code>组成，每个<code>Block_x</code>内部暂且看成一个黑箱, 只需要知道其是我们查询的基本IO单元即可。 每个<code>Block_x</code>后会追加32位的哈希值，用于校验。每个<code>Block</code>对应一个<code>Meta</code>, 每个<code>Meta</code>记录这个<code>Block</code>在<code>SST</code>文件中的偏移量、第一个和最后一个<code>key</code>的元数据(长度和大小)。</p>
<p>这里，<code>Block</code>是基本的IO单元，这就意味着在查询一个<code>key</code>时, 其所在的整个<code>Block</code>的数据都会被解码并加载到内存中的。你可以类比操作系统中的<code>Page</code>, 其是内存和磁盘之间的基本IO单元。</p>
<p>另一方面，在查询一个<code>key</code>时，如何确定查哪一个<code>Block</code>呢? 这里就需要将<code>SST</code>中的<code>Extra Information</code>中的元数据提前加载到内存中, 这些元数据能够定位到<code>Meta Section</code>, 而<code>Meta Section</code>是一个数组, 其中每个<code>Meta_x</code>记录了对应<code>Block</code>在整个<code>SST</code>中的位置， 可以以此来快速对指定为位置的二进制数据进行解码。</p>
<blockquote>
<p>你肯定能想到, 作为基本的IO单元, 我们肯定会为其实现一个缓存池的, 这样可以避免每次查询时都进行磁盘IO。</p>
</blockquote>
<p>心细的你肯定也注意到, 这里有一个<code>Bloom Section</code>, 这其实就是布隆过滤器中的<code>bit</code>位数组, 其用处是拦截无效的访问, 这会在后续的<code>Lab</code>中进行详细讲解。</p>
<h1 id="3-block的结构"><a class="header" href="#3-block的结构">3 Block的结构</a></h1>
<p>现在我们来看<code>Block</code>的结构, <code>Block</code>是<code>SST</code>中的基本IO单元，即<code>SST</code>的每个查询最终是在<code>Blcok</code>中定位到具体的键值对的, 其结构为:</p>
<p><img src="lab3/../images/lab3/Block.png" alt="Block" /></p>
<blockquote>
<p>上图的<code>B</code>表示一个字节</p>
</blockquote>
<p>一个<code>Block</code>包含:<code>Data Section</code>、<code>Offset Section</code>和<code>Extra Information</code>三部分:</p>
<ul>
<li><code>Data Section</code>: 存放所有的数据, 也就是<code>key</code>和<code>value</code>的序列化数据
<ul>
<li>每一对<code>key</code>和<code>value</code>都是一个<code>Entry</code>， 编码信息包括<code>key_len</code>、<code>key</code>、<code>value_len</code>和<code>value</code>
<ul>
<li><code>key_len</code>和<code>value_len</code>都是<code>2B</code>的<code>uint16_t</code>类型, 用于表示<code>key</code>和<code>value</code>的长度</li>
<li><code>key</code>和<code>value</code>就是对应长度的字节数, 因此需要用<code>varlen</code>来表示。</li>
</ul>
</li>
</ul>
</li>
<li><code>Offset Section</code>: 存放所有<code>Entry</code>的偏移量, 用于快速定位</li>
<li><code>Extra Information</code>: 存放<code>num_of_elements</code>, 也就是<code>Entry</code>的数量</li>
</ul>
<p>这样编码满足了最基本的要求, 从最后的2个字节可以知道<code>Block</code>包含了多少<code>kv</code>对, 再从<code>Offset Section</code>中查询对应的<code>kv</code>对数据的偏移。</p>
<h1 id="4-思考"><a class="header" href="#4-思考">4 思考</a></h1>
<p>现在有了<code>Block</code>和<code>SST</code>的设计方案, 你可以思考如下几个问题:</p>
<ol>
<li><code>Blcok</code>和<code>SST</code>是如何构建的? <code>Block</code>如何进行划分?</li>
<li><code>Block</code>内部如何实现迭代器吗?</li>
<li><code>SST</code>的迭代器是单独设计, 还是对已有<code>Blcok</code>迭代器的封装? 如何封装?</li>
<li><code>Block</code>的缓存池如何设计?</li>
<li>布隆过滤器和缓存池的设计各自有什么作用? 他们的功能是否重复?</li>
</ol>
<p>当你对上述问题有过简单思考后, 你可以开启本次<code>Lab</code>了, 你需要有一定心理准备, 这一大章节的<code>Lab</code>原比之前的<code>MemTable</code>和<code>Skiplist</code>复杂, 现在开始第一部分 <a href="lab3/./lab3.1-Block.html">Block 实现</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阶段1-block"><a class="header" href="#阶段1-block">阶段1-Block</a></h1>
<p>本阶段主要实现<code>Block</code>类, 包括<code>Block</code>的编码格式, 编解码方法、以及<code>Block</code>的迭代器和相关的查询功能。</p>
<blockquote>
<p>提示: 强烈建议你自己创建一个分组实现<code>Lab</code>的内容, 并在每次新的<code>Lab</code>开始时进行如下同步操作:</p>
<pre><code class="language-bash">git pull origin lab
git checkout your_branch
git merge lab
</code></pre>
<p>如果你发现项目仓库的代码没有指导书中的 TODO 标记的话, 证明你需要运行上述命令更新代码了</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-31-block-实现"><a class="header" href="#lab-31-block-实现">Lab 3.1 Block 实现</a></h1>
<h1 id="1-准备工作-2"><a class="header" href="#1-准备工作-2">1 准备工作</a></h1>
<p>老套路, 我们先理一下<code>Block</code>的数据结构, 看看头文件定义:</p>
<pre><code class="language-cpp">// include/block/block.h
class Block : public std::enable_shared_from_this&lt;Block&gt; {
  friend BlockIterator;

private:
  std::vector&lt;uint8_t&gt; data; // 对应架构图的 Data
  std::vector&lt;uint16_t&gt; offsets; // 对应架构图的 Offset
  size_t capacity;

  struct Entry {
    std::string key;
    std::string value;
    uint64_t tranc_id;
  };
  // ...
};
</code></pre>
<p>这里可能涉及C++的新特性:</p>
<pre><code class="language-cpp">public std::enable_shared_from_this&lt;Block&gt;
</code></pre>
<p><code>std::enable_shared_from_this</code> 是 C++11 引入的一个标准库特性，它允许一个对象安全地创建指向自身的<code>std::shared_ptr</code>。这里先简单说明一下, 后续实现迭代器的时候就知道其作用了。</p>
<p>这里主要对<code>data</code>和<code>offsets</code>这两个数据结构进行说明, 他们在构建阶段和读取阶段存在一定区别, 首先还是给出架构图:</p>
<p><img src="lab3/../images/lab3/Block.png" alt="Block" /></p>
<p><strong>构建阶段</strong>
当我们从<code>Skiplist</code>拿到数据构建一个<code>SST</code>时, <code>SST</code>需要逐个构建<code>Block</code>, 这个<code>Block</code>在构建时步骤如下:</p>
<ol>
<li>逐个将编码的键值对(也就是<code>Entry</code>)写入<code>data</code>数组, 同时将每个<code>Entry</code>的偏移量记录在内存中的<code>offsets</code>数组中。</li>
<li>当这个<code>Block</code>容量达到阈值时, <code>Block</code>构建完成, 你需要将<code>offsets</code>数组写入到<code>Block</code>的末尾。</li>
<li>还需要再<code>Block</code>末尾写入一个<code>Entry Num</code>值, 用于标识这个<code>Block</code>中键值对的数量, 从而在解码时获取<code>Offset</code>的其实位置(因为每个<code>Entry Offset</code>大小是固定的整型值)</li>
<li>当前<code>Block</code>构建完成, <code>SST</code>开始构建下一个<code>Block</code>。</li>
</ol>
<blockquote>
<p>这里之所以将先将键值对持久化到<code>data</code>数组, 而元信息暂存于内存的<code>offsets</code>数组, 是因为<code>Data</code>是在数据部分之后的的<code>Offset</code>部分的偏移需要再键值对完全写入<code>Data</code>部分后才能确定</p>
</blockquote>
<p><strong>解码阶段</strong>
解码阶段, 直接将<code>Data</code>、<code>Offset</code>解码形成内存中的<code>Block</code>的实例以为上层组件提供查询功能，同时如果实现了缓存池，需要再缓存池中进行记录。</p>
<h1 id="2-代码实现"><a class="header" href="#2-代码实现">2 代码实现</a></h1>
<p>你需要修改的函数都在<code>src/block/block.cpp</code>中。</p>
<h2 id="21-block-编码和解码"><a class="header" href="#21-block-编码和解码">2.1 Block 编码和解码</a></h2>
<p>这里你先不要管这个<code>Block</code>是哪里来的, 就当它已经存在, 实现编码和解码的功能:</p>
<pre><code class="language-cpp">std::vector&lt;uint8_t&gt; Block::encode() {
  // TODO Lab 3.1 编码单个类实例形成一段字节数组
  return {};
}

std::shared_ptr&lt;Block&gt; Block::decode(const std::vector&lt;uint8_t&gt; &amp;encoded,
                                     bool with_hash) {
  // TODO Lab 3.1 解码字节数组形成类实例
  return nullptr;
}
</code></pre>
<p>这里特别说明, <code>encode</code>时的数据是不包括校验的哈希值的 因为哈希值是在<code>SST</code>控制<code>Block</code>构建过程中计算的, 但在<code>decode</code>时可以通过<code>with_hash</code>参数来指示传入的<code>encoded</code>是否包含哈希值, 如果包含哈希值, 则需要先校验哈希值是否正确, 校验失败则抛出异常。</p>
<blockquote>
<p>之所以<code>encode</code>不计算哈希值, <code>decode</code>按需计算哈希值, 其实是作者初版代码设计不佳, 这里先不纠结了, 后续可能会进行优化, 如果你有优化方案, 可对代码进行修改后提PR</p>
</blockquote>
<blockquote>
<p>编解码时你需要注意数据的格式, 如果校验格式错误, 你需要抛出异常, 否则错误将非常难以<code>Debug</code></p>
</blockquote>
<h2 id="22-局部数据编解码函数"><a class="header" href="#22-局部数据编解码函数">2.2 局部数据编解码函数</a></h2>
<p>对于二进制数据, 你需要按照设计的编码结构获取其<code>key</code>, <code>value</code>和<code>tranc_id</code>, 这里我们实现几个辅助函数:</p>
<pre><code class="language-cpp">// 从指定偏移量获取entry的key
std::string Block::get_key_at(size_t offset) const {
  // TODO Lab 3.1 从指定偏移量获取entry的key
  return "";
}

// 从指定偏移量获取entry的value
std::string Block::get_value_at(size_t offset) const {
  // TODO Lab 3.1 从指定偏移量获取entry的value
  return "";
}

uint16_t Block::get_tranc_id_at(size_t offset) const {
  // TODO Lab 3.1 从指定偏移量获取entry的tranc_id
  // ? 你不需要理解tranc_id的具体含义, 直接返回即可
  return 0;
}
</code></pre>
<h2 id="23-构建-block"><a class="header" href="#23-构建-block">2.3 构建 Block</a></h2>
<p><code>Block</code>构建是由<code>SST</code>控制的, 其会不断地调用下面这个函数添加键值对:</p>
<pre><code class="language-cpp">bool Block::add_entry(const std::string &amp;key, const std::string &amp;value,
                      uint64_t tranc_id, bool force_write) {
  // TODO Lab 3.1 添加一个键值对到block中
  // ? 返回值说明：
  // ? true: 成功添加
  // ? false: block已满, 拒绝此次添加
  return false;
}
</code></pre>
<p>这里需要注意, <code>force_write</code>参数表示是否强制写入, 如果为<code>true</code>, 则不管<code>Block</code>是否已满, 都强制写入, 否则如果<code>Block</code>已满, 则拒绝此次写入。</p>
<p><code>Block</code>是否已满的判断将当前数据容量与成员变量<code>capacity</code>进行比较, <code>capacity</code>在<code>Block</code>初始化时由<code>SST</code>传入, 表示一个<code>Block</code>的最大容量。</p>
<blockquote>
<p>如果你需要一些使用<code>config.toml</code>中预定义的一些阈值变量或者其他常来那个, 你也可以通过<code>TomlConfig::getInstance().getXXX</code>的方式获取</p>
</blockquote>
<h2 id="24-二分查询"><a class="header" href="#24-二分查询">2.4 二分查询</a></h2>
<p><code>Block</code>构建时是通过<code>SST</code>遍历<code>Skiplist</code>的迭代器调用<code>add_entry</code>实现的, 因此<code>Block</code>的数据是有序的, 你需要实现一个二分查找函数, 用于在<code>Block</code>中查找指定<code>key</code>所属的<code>Entry</code>在<code>offset</code>元数据中的索引:</p>
<pre><code class="language-cpp">std::optional&lt;size_t&gt; Block::get_idx_binary(const std::string &amp;key,
                                            uint64_t tranc_id) {
  // TODO Lab 3.1 使用二分查找获取key对应的索引
  return std::nullopt;
}
</code></pre>
<p><code>get_value_binary</code>函数中会调用<code>get_idx_binary</code>函数, 并返回指定<code>key</code>的<code>value</code>:</p>
<pre><code class="language-cpp">// 使用二分查找获取value
// 要求在插入数据时有序插入
std::optional&lt;std::string&gt; Block::get_value_binary(const std::string &amp;key,
                                                   uint64_t tranc_id) {
  auto idx = get_idx_binary(key, tranc_id);
  if (!idx.has_value()) {
    return std::nullopt;
  }

  return get_value_at(offsets[*idx]);
}
</code></pre>
<h1 id="3-测试-2"><a class="header" href="#3-测试-2">3 测试</a></h1>
<p>如果成功完成了上述的所有函数, 你应该如下运行测试并得到结果:</p>
<pre><code class="language-bash">✗ xmake
[100%]: build ok, spent 1.94s
✗ xmake run test_block
[==========] Running 10 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 10 tests from BlockTest
[ RUN      ] BlockTest.DecodeTest
[       OK ] BlockTest.DecodeTest (0 ms)
[ RUN      ] BlockTest.EncodeTest
[       OK ] BlockTest.EncodeTest (0 ms)
[ RUN      ] BlockTest.BinarySearchTest
[       OK ] BlockTest.BinarySearchTest (0 ms)
[ RUN      ] BlockTest.EdgeCasesTest
[       OK ] BlockTest.EdgeCasesTest (0 ms)
[ RUN      ] BlockTest.LargeDataTest
[       OK ] BlockTest.LargeDataTest (0 ms)
[ RUN      ] BlockTest.ErrorHandlingTest
[       OK ] BlockTest.ErrorHandlingTest (1 ms)
[ RUN      ] BlockTest.IteratorTest
test/test_block.cpp:225: Failure
Expected equality of these values:
  count
    Which is: 0
  test_data.size()
    Which is: 100
</code></pre>
<p>你应该能通过<code>BlockTest.IteratorTest</code>之前的所有单元测试, <code>BlockTest.IteratorTest</code>这个测试会测试<code>Block</code>的迭代器功能, 因为<code>Block</code>的迭代器功能还没有实现, 所以会失败, 这是符合预期的。</p>
<h1 id="4-下一步"><a class="header" href="#4-下一步">4 下一步</a></h1>
<p>现在进入下一步前, 你可以先思考:</p>
<ol>
<li>如何实现<code>Block</code>的迭代器</li>
<li>为什么我们需要让<code>Block</code>类继承<code>std::enable_shared_from_this&lt;Block&gt;</code>?</li>
</ol>
<p>带着这些疑问, 欢迎开启下一章</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-32-迭代器"><a class="header" href="#lab-32-迭代器">Lab 3.2 迭代器</a></h1>
<h1 id="1-blockiterator的设计"><a class="header" href="#1-blockiterator的设计">1 BlockIterator的设计</a></h1>
<p>现在实现我们的<code>Block</code>的迭代器。通过<code>Block</code>的编码格式可知, 只需要知道当前的索引, 就可以在<code>Block</code>中查询该索引的<code>kv</code>对, 因此迭代器只需要记录当前索引和原始<code>Block</code>的引用就可以了。</p>
<p>这也就是之前提到的<code>std::enable_shared_from_this</code>的作用，让我们的<code>BlockIterator</code>可以使用<code>Block</code>的智能指针, 为什么这样设计呢? 因为<code>BlockIterator</code>的生命周期是依赖于于<code>Block</code>的, 如果<code>Block</code>的生命周期结束, <code>BlockIterator</code>依然存在, 那么就会产生悬空指针, 因此我们需要使用智能指针来管理<code>Block</code>的生命周期。</p>
<p>这么说可能有点迷糊, 我们直接看头文件定义:</p>
<pre><code class="language-cpp">class BlockIterator {
  // ...
private:
  std::shared_ptr&lt;Block&gt; block;                   // 指向所属的 Block
  size_t current_index;                           // 当前位置的索引
  uint64_t tranc_id_;                             // 当前事务 id
  mutable std::optional&lt;value_type&gt; cached_value; // 缓存当前值
};
</code></pre>
<blockquote>
<p><code>cached_value</code>其实算是个小优化, 尽管有索引就在<code>block</code>中进行二分查找, 但这里还是用一个值进行缓存, 因为迭代器可能被反复读取值, 而每次读取值需要按照数据编码的格式进行解码, 在多次读取迭代器值的情况下, 缓存起来从理论上速度回更快</p>
</blockquote>
<p>这里的<code>BlockIterator</code>不同于我们之前的<code>HeapIterator</code>, 它并不持有我们实际的键值对数据, 而进行对<code>Block</code>中的键值对位置进行定位, 因此就需要保证其指针<code>block</code>是有效的, 在现代<code>C++</code>中, 我们应该避免使用裸指针, 因此这里使用了<code>std::shared_ptr</code>来保证其指针<code>block</code>有效的。但<code> std::shared_ptr&lt;Block&gt; block</code>肯定是某个<code>Blcok</code>的<code>this</code>指针, 而<code>this</code>是裸指针, 因此我们需要使<code>Block</code>继承<code>std::enable_shared_from_this</code>, 这样就可以通过<code>shared_from_this()</code>获取代表<code>this</code>指针的<code>shared_ptr&lt;Block&gt;</code>了。</p>
<blockquote>
<p>需要注意的是, 使用<code>shared_from_this()</code>时, 需要保证类的实例被<code>shared_ptr</code>管理, 否则会抛出异常, 具体可以查询相关资料, 这里不过多介绍。</p>
</blockquote>
<p>其余成员变量应该很好理解, <code>current_index</code>记录当前索引, <code>tranc_id_</code>记录当前事务 id, <code>cached_value</code>缓存当前值。</p>
<h1 id="2-实现-blockiterator"><a class="header" href="#2-实现-blockiterator">2 实现 <code>BlockIterator</code></a></h1>
<p>本部分你需要修改的代码文件为：</p>
<ul>
<li><code>src/block/block_iterator.cpp</code></li>
<li><code>include/block/block_iterator.h</code> (Optional)</li>
</ul>
<h2 id="21-构造函数实现"><a class="header" href="#21-构造函数实现">2.1 构造函数实现</a></h2>
<p>实现构造函数，传入一个 <code>block</code> 和 <code>key</code>，以及事务 <code>tranc_id</code>, 这里在构造迭代器时就将迭代器移动到指定<code>key</code>的位置(还需要满足<code>tranc_id</code>的可见性, 不过现在你可以先忽略这个可见性的判断逻辑)。</p>
<p>你需要借助之前实现的<code>Block</code>的成员函数来实现这的移动逻辑:</p>
<pre><code class="language-cpp">BlockIterator::BlockIterator(std::shared_ptr&lt;Block&gt; b, const std::string &amp;key,
                             uint64_t tranc_id)
    : block(b), tranc_id_(tranc_id), cached_value(std::nullopt) {
  // TODO: Lab3.2 创建迭代器时直接移动到指定的key位置
  // ? 你需要借助之前实现的 Block 类的成员函数
}
</code></pre>
<h2 id="22-运算符重载"><a class="header" href="#22-运算符重载">2.2 运算符重载</a></h2>
<p>迭代器的运算符重载是你需要实现的基础成员函数:</p>
<pre><code class="language-cpp">BlockIterator::pointer BlockIterator::operator-&gt;() const {
  // TODO: Lab3.2 -&gt; 重载
  return nullptr;
}

BlockIterator &amp;BlockIterator::operator++() {
  // TODO: Lab3.2 ++ 重载
  // ? 在后续的Lab实现事务后，你可能需要对这个函数进行返修
  return *this;
}

bool BlockIterator::operator==(const BlockIterator &amp;other) const {
  // TODO: Lab3.2 == 重载
  return true;
}

bool BlockIterator::operator!=(const BlockIterator &amp;other) const {
  // TODO: Lab3.2 != 重载
  return true;
}

BlockIterator::value_type BlockIterator::operator*() const {
  // TODO: Lab3.2 * 重载
  return {};
}
</code></pre>
<blockquote>
<p>这些运算符重载函数中, 你也不需要考虑<code>tranc_id</code>的相关逻辑, 只是你需要记得, 后续实现了事务功能后, 本<code>Lab</code>的部分逻辑需要进行调整</p>
</blockquote>
<h2 id="23-辅助函数"><a class="header" href="#23-辅助函数">2.3 辅助函数</a></h2>
<p>这里有一些作者提供的可能用用的辅助函数, 你可以按选择实现他们, 也可以忽略他们, 自己按照自己的理解创建自定义的成员函数:</p>
<pre><code class="language-cpp">void BlockIterator::update_current() const {
  // TODO: Lab3.2 更新当前指针
  // ? 该函数是可选的实现, 你可以采用自己的其他方案实现-&gt;, 而不是使用
  // ? cached_value 来缓存当前指针
}

void BlockIterator::skip_by_tranc_id() {
  // TODO: Lab3.2 * 跳过事务ID
  // ? 只是进行标记以供你在后续Lab实现事务功能后修改
  // ? 现在你不需要考虑这个函数
}
</code></pre>
<p>这里的<code>skip_by_tranc_id</code>只是标记后续<code>Lab</code>实现事务带来的的一些逻辑上的变化, 你现在不需要实现。
而<code>update_current</code>则是一个可选的实现, 其用来更新缓存的键值对变量, 你可以采用自己的其他方案实现<code>-&gt;</code>, 而不是使用成员变量<code>cached_value</code>和这个函数。</p>
<h1 id="4-获取迭代器的接口函数实现"><a class="header" href="#4-获取迭代器的接口函数实现">4 获取迭代器的接口函数实现</a></h1>
<p>现在我们已经实现了<code>BlockIterator</code>的, 我们需要实现<code>Block</code>的<code>begin</code>和<code>end</code>函数将<code>BlockIterator</code>进行返回给外部组件使用:</p>
<pre><code class="language-cpp">BlockIterator Block::begin(uint64_t tranc_id) {
  // TODO Lab 3.2 获取begin迭代器
  return BlockIterator(nullptr, 0, 0);
}

BlockIterator Block::end() {
  // TODO Lab 3.2 获取end迭代器
  return BlockIterator(nullptr, 0, 0);
}
</code></pre>
<p>这里的<code>tranc_id</code>同样可以暂时忽略, 但对应类实例的值还是要在构造函数中初始化的。</p>
<h1 id="5-测试-1"><a class="header" href="#5-测试-1">5 测试</a></h1>
<p>测试代码在<code>test/test_block.cpp</code>中, 你在完成上述组件实现后的测试结果预期为:</p>
<pre><code class="language-bash">✗ xmake
✗ xmake run test_block
[==========] Running 10 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 10 tests from BlockTest
[ RUN      ] BlockTest.DecodeTest
[       OK ] BlockTest.DecodeTest (0 ms)
[ RUN      ] BlockTest.EncodeTest
[       OK ] BlockTest.EncodeTest (0 ms)
[ RUN      ] BlockTest.BinarySearchTest
[       OK ] BlockTest.BinarySearchTest (0 ms)
[ RUN      ] BlockTest.EdgeCasesTest
[       OK ] BlockTest.EdgeCasesTest (0 ms)
[ RUN      ] BlockTest.LargeDataTest
[       OK ] BlockTest.LargeDataTest (0 ms)
[ RUN      ] BlockTest.ErrorHandlingTest
[       OK ] BlockTest.ErrorHandlingTest (1 ms)
[ RUN      ] BlockTest.IteratorTest
[       OK ] BlockTest.IteratorTest (0 ms)
[ RUN      ] BlockTest.PredicateTest
test/test_block.cpp:277: Failure
Value of: result.has_value()
  Actual: false
Expected: true

unknown file: Failure
C++ exception with description "bad optional access" thrown in the test body.
</code></pre>
<p><code>PredicateTest</code>需要你在完成下一小节的任务后, 才能通过。</p>
<p>现在你可以开启下一节的<a href="lab3/./lab3.3-iter-query.html">范围查询</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-33-范围查询"><a class="header" href="#lab-33-范围查询">Lab 3.3 范围查询</a></h1>
<h1 id="1-范围查询函数"><a class="header" href="#1-范围查询函数">1 范围查询函数</a></h1>
<p>鉴于你之前已经在<code>Skiplist</code>组件和<code>MemTable</code>组件中实现了<code>range_query</code>功能, 这里我们需要再<code>Blcok</code>组件中再次实现<code>range_query</code>功能。(同样, 查询是单调的), 只不过这里操作的基础数据从内存中的跳表变成了类似数组结构的<code>Block</code>。</p>
<p>你需要修改的文件:</p>
<ul>
<li><code>src/block/block.cpp</code></li>
<li><code>include/block/block.h</code> (Optional)</li>
</ul>
<h2 id="11-前缀查询"><a class="header" href="#11-前缀查询">1.1 前缀查询</a></h2>
<p>具体修改的函数为:</p>
<pre><code class="language-cpp">std::optional&lt;
    std::pair&lt;std::shared_ptr&lt;BlockIterator&gt;, std::shared_ptr&lt;BlockIterator&gt;&gt;&gt;
Block::iters_preffix(uint64_t tranc_id, const std::string &amp;preffix) {
  // TODO Lab 3.2 获取前缀匹配的区间迭代器
  return std::nullopt;
}
</code></pre>
<p>这里返回一对迭代器,标识前缀匹配的区间。(同样是和<code>STL</code>风格一致的左闭右开区间), 如果查询不到, 返回<code>std::nullopt</code>。</p>
<blockquote>
<p><code>std::optional</code>是一个智能指针, 其用法非常类似<code>Rust</code>的<code>Option</code></p>
</blockquote>
<h2 id="12-谓词查询"><a class="header" href="#12-谓词查询">1.2 谓词查询</a></h2>
<p>具体修改的函数为:</p>
<pre><code class="language-cpp">// 返回第一个满足谓词的位置和最后一个满足谓词的位置
// 如果不存在, 范围nullptr
// 谓词作用于key, 且保证满足谓词的结果只在一段连续的区间内, 例如前缀匹配的谓词
// 返回的区间是闭区间, 开区间需要手动对返回值自增
// predicate返回值:
//   0: 满足谓词
//   &gt;0: 不满足谓词, 需要向右移动
//   &lt;0: 不满足谓词, 需要向左移动
std::optional&lt;
    std::pair&lt;std::shared_ptr&lt;BlockIterator&gt;, std::shared_ptr&lt;BlockIterator&gt;&gt;&gt;
Block::get_monotony_predicate_iters(
    uint64_t tranc_id, std::function&lt;int(const std::string &amp;)&gt; predicate) {
  // TODO: Lab 3.2 使用二分查找获取满足谓词的区间迭代器
  return std::nullopt;
}
</code></pre>
<p>这里返回一对迭代器,标识谓词查询的区间。(同样是和<code>STL</code>风格一致的左闭右开区间), 如果查询不到, 返回<code>std::nullopt</code>。</p>
<h1 id="2-测试"><a class="header" href="#2-测试">2 测试</a></h1>
<p>如下运行测试， 预期结果为：</p>
<pre><code class="language-bash">✗ xmake
✗ xmake run test_block
[==========] Running 10 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 10 tests from BlockTest
[ RUN      ] BlockTest.DecodeTest
[       OK ] BlockTest.DecodeTest (0 ms)
[ RUN      ] BlockTest.EncodeTest
[       OK ] BlockTest.EncodeTest (0 ms)
[ RUN      ] BlockTest.BinarySearchTest
[       OK ] BlockTest.BinarySearchTest (0 ms)
[ RUN      ] BlockTest.EdgeCasesTest
[       OK ] BlockTest.EdgeCasesTest (0 ms)
[ RUN      ] BlockTest.LargeDataTest
[       OK ] BlockTest.LargeDataTest (0 ms)
[ RUN      ] BlockTest.ErrorHandlingTest
[       OK ] BlockTest.ErrorHandlingTest (1 ms)
[ RUN      ] BlockTest.IteratorTest
[       OK ] BlockTest.IteratorTest (0 ms)
[ RUN      ] BlockTest.PredicateTest
[       OK ] BlockTest.PredicateTest (2 ms) # 到这里成功就表示你完成了本`Lab`
[ RUN      ] BlockTest.TrancIteratorTest
[       OK ] BlockTest.TrancIteratorTest (0 ms)
[ RUN      ] BlockTest.TrancPredicateTest
[       OK ] BlockTest.TrancPredicateTest (0 ms)
[----------] 10 tests from BlockTest (4 ms total)

[----------] Global test environment tear-down
[==========] 10 tests from 1 test suite ran. (4 ms total)
[  PASSED  ] 10 tests.
</code></pre>
<p>其中最后两个测试<code>BlockTest.TrancIteratorTest</code>和<code>BlockTest.TrancPredicateTest</code>需要后续实现事务功能后才能正常通过。只要你通过了<code>BlockTest.PredicateTest</code>前的测试, 即视为完成了本<code>Lab</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阶段2-sst"><a class="header" href="#阶段2-sst">阶段2-SST</a></h1>
<p>在完成了<code>Block</code>组件和<code>BlockIterator</code>组件之后, 我们就可以开始实现<code>SST</code>组件了。</p>
<p><code>SST</code>组件的核心工作就是管理器内部的多个<code>Block</code>组件, 利用<code>Block</code>组件和<code>BlockIterator</code>的各种<code>CRUD</code>和初始化、构建等基本接口，来对外提供各类功能。</p>
<blockquote>
<p>提示: 强烈建议你自己创建一个分组实现<code>Lab</code>的内容, 并在每次新的<code>Lab</code>开始时进行如下同步操作:</p>
<pre><code class="language-bash">git pull origin lab
git checkout your_branch
git merge lab
</code></pre>
<p>如果你发现项目仓库的代码没有指导书中的 TODO 标记的话, 证明你需要运行上述命令更新代码了</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-34-blockmeta"><a class="header" href="#lab-34-blockmeta">Lab 3.4 BlockMeta</a></h1>
<h1 id="1-概述-3"><a class="header" href="#1-概述-3">1 概述</a></h1>
<p>让我们再次回顾<code>SST</code>的结构:</p>
<p><img src="lab3/../images/lab3/SST.drawio.png" alt="SST-Arch" /></p>
<p>可以看到, <code>SST</code>中有一个<code>Meta Section</code>, 它是一个数组, 数组中的每一个元素对应一个<code>Block</code>的元信息, 这些元信息包括:</p>
<ul>
<li>该<code>Block</code>在<code>SST</code>中的偏移量</li>
<li>该<code>Block</code>的第一个<code>key</code>和最后一个<code>key</code>的元数据</li>
</ul>
<p>在<code>SST</code>构建完成后, 其文件持久化在文件系统中, 但<code>Meta Section</code>会被加载到内存中并解码为控制结构, 因为没有<code>Meta Section</code>的元数据, 我们是没法对<code>SST</code>按照<code>Block</code>进行索引的。在<code>Tiny-LSM</code>中, 这里的元数据在内存中用类<code>BlockMeta</code>来表示, 其定义为:</p>
<pre><code class="language-cpp">class BlockMeta {
  friend class BlockMetaTest;

public:
  size_t offset;         // 块在文件中的偏移量
  std::string first_key; // 块的第一个key
  std::string last_key;  // 块的最后一个key
  static void encode_meta_to_slice(std::vector&lt;BlockMeta&gt; &amp;meta_entries,
                                   std::vector&lt;uint8_t&gt; &amp;metadata);
  static std::vector&lt;BlockMeta&gt;
  decode_meta_from_slice(const std::vector&lt;uint8_t&gt; &amp;metadata);
  BlockMeta();
  BlockMeta(size_t offset, const std::string &amp;first_key,
            const std::string &amp;last_key);
};
</code></pre>
<p>这里的每一个<code>BlockMeta</code>对应一个<code>Block</code>的元数据, 包含了我们之前介绍的编码方式的基础数据结构。</p>
<h1 id="2-代码实现-1"><a class="header" href="#2-代码实现-1">2 代码实现</a></h1>
<p>你需要修改的代码文件为:</p>
<ul>
<li><code>src/block/blockmeta.cpp</code></li>
<li><code>include/block/blockmeta.h</code> (Optional)</li>
</ul>
<h2 id="21-编码函数"><a class="header" href="#21-编码函数">2.1 编码函数</a></h2>
<p>你需要实现将内存中的元信息编码到二进制数组的函数:</p>
<pre><code class="language-cpp">void BlockMeta::encode_meta_to_slice(std::vector&lt;BlockMeta&gt; &amp;meta_entries,
                                     std::vector&lt;uint8_t&gt; &amp;metadata) {
  // TODO: Lab 3.4 将内存中所有`Blcok`的元数据编码为二进制字节数组
  // ? 输入输出都由参数中的引用给定, 你不需要自己创建`vector`
}
</code></pre>
<h2 id="22-解码函数"><a class="header" href="#22-解码函数">2.2 解码函数</a></h2>
<p>你需要实现将二进制数组解码到内存中的函数:</p>
<pre><code class="language-cpp">std::vector&lt;BlockMeta&gt;
BlockMeta::decode_meta_from_slice(const std::vector&lt;uint8_t&gt; &amp;metadata) {
  // TODO: Lab 3.4 将二进制字节数组解码为内存中的`Blcok`元数据
  return {};
}
</code></pre>
<blockquote>
<p>这里的编码解码都是以代表整个<code>SST</code>元信息的<code>vector</code>数组进行的, 上层组件并不要求你实现单个<code>Block</code>的编解码函数, 但需要你可以选择实现单个<code>Block</code>的编解码函数作为辅助函数</p>
</blockquote>
<h1 id="3-测试-3"><a class="header" href="#3-测试-3">3 测试</a></h1>
<p>测试代码在<code>test/test_blockmeta.cpp</code>中, 正常情况下, 完成本小节<code>Lab</code>后你应该可以通过所有的测试:</p>
<pre><code class="language-bash">✗ xmake
✗ xmake run test_blockmeta
[==========] Running 6 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 6 tests from BlockMetaTest
[ RUN      ] BlockMetaTest.BasicEncodeDecodeTest
[       OK ] BlockMetaTest.BasicEncodeDecodeTest (0 ms)
[ RUN      ] BlockMetaTest.EmptyMetaTest
[       OK ] BlockMetaTest.EmptyMetaTest (0 ms)
[ RUN      ] BlockMetaTest.SpecialCharTest
[       OK ] BlockMetaTest.SpecialCharTest (0 ms)
[ RUN      ] BlockMetaTest.ErrorHandlingTest
[       OK ] BlockMetaTest.ErrorHandlingTest (0 ms)
[ RUN      ] BlockMetaTest.LargeDataTest
[       OK ] BlockMetaTest.LargeDataTest (0 ms)
[ RUN      ] BlockMetaTest.OrderTest
[       OK ] BlockMetaTest.OrderTest (0 ms)
[----------] 6 tests from BlockMetaTest (0 ms total)

[----------] Global test environment tear-down
[==========] 6 tests from 1 test suite ran. (1 ms total)
[  PASSED  ] 6 tests.
</code></pre>
<h1 id="4-思考-1"><a class="header" href="#4-思考-1">4 思考</a></h1>
<p>我们实现了<code>Block</code>类的元信息<code>BlcokMeta</code>, 现在可以思考一下, <code>BlcokMeta</code>如何被上层使用? 其如何加速查询?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-35-sstbuilder"><a class="header" href="#lab-35-sstbuilder">Lab 3.5 SSTBuilder</a></h1>
<h1 id="1-概述-4"><a class="header" href="#1-概述-4">1 概述</a></h1>
<p><code>SSTBuilder</code>是<code>SST</code>文件的构造器, 它将<code>MemTable</code>中的数据进行编码并写入磁盘形成<code>SST</code>。不过这里我们并没有设计到不同组件数据的控制，这是由更上层的结构控制的。</p>
<p><strong>SST和SSTBuilder的关系是什么？</strong>
区别在于，<code>SSTBuilder</code>这个类的实例只在<code>SST文件</code>构建过程中存在, 其是可写的数据结构, 构建过程可不断添加键值对进行编码。在其调用<code>Build</code>后，其会将自身数据编码为<code>SST文件</code>， 并转化为一个<code>SST</code>类实例, <code>SST</code>类本质上就是<code>SST文件</code>的控制结构。</p>
<p>这样说起来可能不好理解, 让我们结合代码将这个过程具体化, 先看其<code>SSTBuilder</code>和<code>SST</code>的头文件定义:</p>
<pre><code class="language-cpp">class SST : public std::enable_shared_from_this&lt;SST&gt; {
  // ...  
private:
  FileObj file;
  std::vector&lt;BlockMeta&gt; meta_entries;
  uint32_t bloom_offset;
  uint32_t meta_block_offset;
  size_t sst_id;
  std::string first_key;
  std::string last_key;
  std::shared_ptr&lt;BloomFilter&gt; bloom_filter;
  std::shared_ptr&lt;BlockCache&gt; block_cache;
  uint64_t min_tranc_id_ = UINT64_MAX;
  uint64_t max_tranc_id_ = 0;

public:
  // ...
};

class SSTBuilder {
private:
  Block block;
  std::string first_key;
  std::string last_key;
  std::vector&lt;BlockMeta&gt; meta_entries;
  std::vector&lt;uint8_t&gt; data;
  size_t block_size;
  std::shared_ptr&lt;BloomFilter&gt; bloom_filter; // 后续Lab内容
  uint64_t min_tranc_id_ = UINT64_MAX; // 后续Lab内容
  uint64_t max_tranc_id_ = 0; // 后续Lab内容

public:
  // 创建一个sst构建器, 指定目标block的大小
  SSTBuilder(size_t block_size, bool has_bloom); 
  // 添加一个key-value对
  void add(const std::string &amp;key, const std::string &amp;value, uint64_t tranc_id);
  // 完成当前block的构建, 即将block写入data, 并创建新的block
  void finish_block();
  // 构建sst, 将sst写入文件并返回SST描述类
  std::shared_ptr&lt;SST&gt; build(size_t sst_id, const std::string &amp;path,
                             std::shared_ptr&lt;BlockCache&gt; block_cache);
};
</code></pre>
<p><strong>构建流程</strong></p>
<ol>
<li>当<code>MemTable</code>的大小超过阈值后，准备将<code>MemTable</code>中最旧的<code>Frozen Table</code>刷出为<code>SST</code>。</li>
<li>先创建一个<code>SSTBuilder</code>, 按照迭代器的顺序遍历<code>Frozen Table</code>，将<code>key-value</code>对添加到<code>SSTBuilder</code>中:
<ol>
<li><code>SSTBuilder</code>会有一个当前的<code>block</code>, 其<code>add</code>函数首先会调用<code>Block::add_entry</code>将迭代器的<code>kv</code>对插入</li>
<li>如果当前的<code>block</code>容量超出阈值<code>block_size</code>, 就调用<code>finish_block</code>将其编码到<code>data</code>, 并清楚当前<code>block</code>相关数据, 开启下一个<code>block</code>的构建</li>
<li>遍历完成迭代器的所有<code>kv</code>对的插入后, 调用<code>build</code>将所有的数据刷到文件系统, 并返回一个<code>SST</code>描述类</li>
</ol>
</li>
</ol>
<p><strong>读取流程</strong></p>
<ol>
<li><code>SST</code>构造函数会绑定一个文件描述符(这里是我自定义封装的文件读取类<code>FileObj file</code>)</li>
<li><code>SST</code>中的<code>meta entries</code>从第一次读取后就常驻内存(第一次读取可以是构造函数, 也可以是第一次<code>get</code>)</li>
<li>上层调用<code>get</code>时, 会从元数据<code>meta_entries</code>中进行二分查找, 找到对应的<code>block</code>的偏移量, 然后调用文件描述对象<code>file</code>从磁盘中读取</li>
<li>读取后的字节流交由<code>Block::decode</code>解码得到内存中的<code>Block</code></li>
<li>内存中的<code>Block</code>调用之前实现的查询函数完成二分查询</li>
</ol>
<h1 id="2-代码实现-2"><a class="header" href="#2-代码实现-2">2 代码实现</a></h1>
<h2 id="21-sstbuilderadd-函数"><a class="header" href="#21-sstbuilderadd-函数">2.1 SSTBuilder::add 函数</a></h2>
<blockquote>
<p>Hint: 建议你先看完下一个<code>finish_block</code>函数的描述后再开始写代码, 因为这个函数中需要使用<code>finish_block</code>函数</p>
</blockquote>
<p><code>SSTBuilder</code>中的<code>block</code>成员变量即为当前正在构建的<code>Block</code>, <code>add</code>函数不断接受上部组件传递的键值对, 并将键值对添加到当前正在构建的<code>Block</code>中, 当<code>Block</code>容量达到阈值时, 将<code>Block</code>写入<code>data</code>数组, 并创建一个新的<code>Block</code>继续构建。
构建结束后，这个<code>data</code>数组就包含了多个<code>Block</code>的编码字节, 经进一步处理后即可刷盘形成<code>SST</code>:</p>
<pre><code class="language-cpp">void SSTBuilder::add(const std::string &amp;key, const std::string &amp;value,
                     uint64_t tranc_id) {
  // TODO: Lab 3.5 添加键值对
}
</code></pre>
<blockquote>
<p>这里的一些阈值参数你同样可以采取<code>TomlConfig::getInstance().getxxx()</code>的方法获取配置文件<code>config.toml</code>中定义的常量</p>
</blockquote>
<h2 id="22-sstbuilderfinish_block-函数"><a class="header" href="#22-sstbuilderfinish_block-函数">2.2 SSTBuilder::finish_block 函数</a></h2>
<p>根据前文介绍可知, <code>SSTBuilder</code>只有一个活跃的<code>block</code>支持插入键值对进行构建, 超出阈值后其将会编码为<code>Block</code>并写入<code>data</code>数组, 这个过程就是<code>SSTBuilder::finish_block</code>函数的功能:</p>
<pre><code class="language-cpp">void SSTBuilder::finish_block() {
  // TODO: Lab 3.5 构建块
  // ? 当 add 函数发现当前的`block`容量超出阈值时，需要将其编码到`data`，并清空`block`
}
</code></pre>
<h2 id="23-sstbuilderbuild-函数"><a class="header" href="#23-sstbuilderbuild-函数">2.3 SSTBuilder::build 函数</a></h2>
<p>当上层组件已经将所有键值对插入到<code>SSTBuilder</code>中后，调用<code>SSTBuilder::build</code>函数即可完成<code>SST</code>文件的构建, 其会返回一个<code>SST</code>指针:</p>
<pre><code class="language-cpp">std::shared_ptr&lt;SST&gt;
SSTBuilder::build(size_t sst_id, const std::string &amp;path,
                  std::shared_ptr&lt;BlockCache&gt; block_cache) {
  // TODO 3.5 构建一个SST
  return nullptr;
}
</code></pre>
<p>参数列表中, <code>sst_id</code>表示<code>SST</code>的编号， <code>path</code>表示<code>SST</code>文件的存储路径， <code>block_cache</code>表示<code>Block</code>的缓存池。你相比也意识到, 当<code>SST</code>从内存持久化为文件后, 其<code>IO</code>必然收到缓存池的管理, 这也是我们之后的内容, 这里你也不需要考虑缓存池的指针, 当它为<code>nullptr</code>即可</p>
<blockquote>
<p>这里涉及到文件IO的操作, 作者已经在<code>include/utils</code>中封装了一个文件IO管理类<code>FileObj</code>, 你需要阅读<code>include/utils/files.h</code>即<code>src/utils/files.cpp</code>来了解其使用方法</p>
</blockquote>
<h1 id="3-测试-4"><a class="header" href="#3-测试-4">3 测试</a></h1>
<p>到目前位置, 我们只是实现了<code>SST</code>的构建工具类<code>SSTBuilder</code>, 但由于我们很没有实现<code>SST</code>的查询功能, 所以现在我们还无法通过查询接口验证我们<code>SST</code>构建的正确性, 因此单元测试需要完成后续<code>SST</code>相关<code>Lab</code>才能实现。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-36-sst-查询"><a class="header" href="#lab-36-sst-查询">Lab 3.6 SST 查询</a></h1>
<h1 id="1-概述-5"><a class="header" href="#1-概述-5">1 概述</a></h1>
<p>首先, 需要声明, 这一小节的实验容量稍大, 你将同时实现<code>SST</code>的基础查询功能和迭代器<code>SstIterator</code>。</p>
<p>为什么需要这样设计呢？答案是因为，我们对组件的查询设计沿用了<code>STL</code>的迭代器风格，查询都是返回迭代器作为结果的。但我们的思路首先应该是实现<code>SST</code>本身, 后续再实现迭代器<code>SstIterator</code>。但<code>STL</code>风格的接口设计导致二者耦合了，因此，这里索性将二者同时实现了。</p>
<h2 id="11-sst-的定义"><a class="header" href="#11-sst-的定义">1.1 SST 的定义</a></h2>
<p>同样，我们先看<code>SST</code>的定义：</p>
<pre><code class="language-cpp">class SST : public std::enable_shared_from_this&lt;SST&gt; {
private:
  FileObj file;
  std::vector&lt;BlockMeta&gt; meta_entries;
  uint32_t bloom_offset; // 暂时忽略
  uint32_t meta_block_offset;
  size_t sst_id;
  std::string first_key;
  std::string last_key;
  std::shared_ptr&lt;BloomFilter&gt; bloom_filter; // 暂时忽略
  std::shared_ptr&lt;BlockCache&gt; block_cache; // 暂时忽略
  uint64_t min_tranc_id_ = UINT64_MAX; // 暂时忽略
  uint64_t max_tranc_id_ = 0; // 暂时忽略
  // ...
};
</code></pre>
<p><code>SST</code>最关键的成员变量是<code>meta_entries</code>, 其本质上就是从硬盘中读取了<code>SST文件</code>的<code>Meta Section</code>部分解析后的<code>BlockMeta</code>数组。在接受外部查询请求时, 我们会根据<code>key</code>在<code>meta_entries</code>中查找对应的<code>BlockMeta</code>, 然后从硬盘中读取<code>Block</code>并解码得到内存中的<code>Block</code>, 最后再调用<code>Block</code>的查询接口完成查询。这里的<code>FileObj file</code>成员变量就是实现对应的<code>SST文件</code>的<code>IO</code>操作的类实例。</p>
<blockquote>
<p>当然, 如果你完成了后续<code>Lab</code>, 这里的逻辑存在一些不同:</p>
<ol>
<li>如果后续实现了缓存池, 就可以从缓存池中查询<code>Block</code>, 而不是从硬盘中读取。</li>
<li>如果后续实现了<code>BloomFilter</code>, 那么在查询时, 首先会通过<code>BloomFilter</code>判断<code>key</code>是否有存在的可能, 如果不可能存在, 则直接返回<code>nullptr</code>, 否则继续调用查询接口完成查询。</li>
</ol>
</blockquote>
<h2 id="12-sstiterator-的定义"><a class="header" href="#12-sstiterator-的定义">1.2 SstIterator 的定义</a></h2>
<p>然后是<code>SstIterator</code>的定义:</p>
<pre><code class="language-cpp">class SstIterator : public BaseIterator {
  // friend xxx

private:
  std::shared_ptr&lt;SST&gt; m_sst;
  size_t m_block_idx;
  uint64_t max_tranc_id_;
  std::shared_ptr&lt;BlockIterator&gt; m_block_it;
  mutable std::optional&lt;value_type&gt; cached_value; // 缓存当前值
  // ...
};
</code></pre>
<p>要实现<code>SST</code>的迭代器, 需要记录当前的<code>Block</code>索引, <code>以及Block</code>中的<code>Entry</code>索引, 因此也需要原<code>SST</code>类的<code>this</code>指针, 之前已经介绍过<code>enable_shared_from_this</code>了, 不再赘述。</p>
<p>这里使用<code>m_sst</code>, <code>m_block_idx</code>和<code>m_block_it</code>分别记录原始的<code>SST</code>类对象、当前<code>Block</code>在<code>SST</code>中的位置、当前迭代器在<code>Block</code>中的位置。<code>cached_value</code>仍然用做缓存值, 因为读取键值对涉及文件<code>IO</code>操作, 因此这里的<code>cached_value</code>就不仅仅是为了实现<code>-&gt;</code>的辅助成员变量了, 而是正儿八经的优化手段。</p>
<p>本小节<code>Lab</code>中, 你需要修改的代码文件:</p>
<ul>
<li>实现<code>SST</code>需要修改的文件
<ul>
<li><code>src/sst/sst.cpp</code></li>
<li><code>include/sst/sst.h</code> (Optional)</li>
</ul>
</li>
<li>实现<code>SstIterator</code>需要修改的文件
<ul>
<li><code>src/sst/sst_iterator.cpp</code></li>
<li><code>include/sst/sst_iterator.h</code> (Optional)</li>
</ul>
</li>
</ul>
<h1 id="2-sst-基础代码实现"><a class="header" href="#2-sst-基础代码实现">2 SST 基础代码实现</a></h1>
<h2 id="21-打开-sst-文件"><a class="header" href="#21-打开-sst-文件">2.1 打开 SST 文件</a></h2>
<p>你需要实现<code>SST：：open</code>函数:</p>
<pre><code class="language-cpp">// 头文件中将其定义为静态函数
std::shared_ptr&lt;SST&gt; SST::open(size_t sst_id, FileObj file,
                               std::shared_ptr&lt;BlockCache&gt; block_cache) {
  // TODO Lab 3.6 打开一个SST文件, 返回一个描述类

  return nullptr;
}
</code></pre>
<p>尽管我们的<code>SST</code>对数据的查询是惰性地从文件系统中进行读取, 但必要的元信息需要我们加载到内存中。<code>SST::open</code>的工就是将<code>SST文件</code>的元信息进行解码和加载，返回一个描述类<code>SST</code>， 你可以将<code>SST</code>看做是<code>SST</code>文件的操作句柄，或者是文件描述符。</p>
<blockquote>
<ol>
<li>如果你后续<code>Lab</code>实现了布隆过滤器, 那么布隆过滤器的<code>bit</code>数组也需要加载到内存中</li>
<li><code>block_cache</code>是缓存池的指针, 你现在不需要管它是哪里来的, 只需要对类的成员变量进行简单赋值即可</li>
</ol>
</blockquote>
<h2 id="22-加载-block"><a class="header" href="#22-加载-block">2.2 加载 Block</a></h2>
<p>在接受其他组件的查询请求后, <code>SST</code>会根据元信息定位请求的<code>key</code>可能位于哪一个<code>Block</code>(因为<code>BlockMeta</code>中存储了首尾的<code>key</code>), 接下来就是读取这个<code>Blcok</code>, 这就是你需要实现的<code>read_block</code>函数:</p>
<pre><code class="language-cpp">std::shared_ptr&lt;Block&gt; SST::read_block(size_t block_idx) {
  // TODO: Lab 3.6 根据 block 的 id 读取一个 `Block`
  return nullptr;
}
</code></pre>
<blockquote>
<p>实现缓存池后, 你的代码逻辑应该是</p>
<ol>
<li>从缓存池获取<code>Block</code>, 如果缓存命中, 直接返回。</li>
<li>缓存未命中才从文件系统中读取</li>
<li>返回前别忘了更新缓存池</li>
</ol>
</blockquote>
<h2 id="23-根据-key-查询-block"><a class="header" href="#23-根据-key-查询-block">2.3 根据 key 查询 Block</a></h2>
<pre><code class="language-cpp">size_t SST::find_block_idx(const std::string &amp;key) {
  // 先在布隆过滤器判断key是否存在
  // TODO: Lab 3.6 二分查找
  // ? 给定一个 `key`, 返回其所属的 `block` 的索引
  // ? 如果没有找到包含该 `key` 的 Block，返回-1
  return 0;
}
</code></pre>
<p><code>find_block_idx</code>函数的目的是根据<code>key</code>在<code>meta_entries</code>中查找对应的<code>BlockMeta</code>, 返回<code>BlockMeta</code>在<code>meta_entries</code>中的索引。如果<code>key</code>不存在于<code>SST</code>中, 则返回<code>-1</code>。</p>
<p>这里由于<code>Block</code>的数据是有序的, 因此你需要使用二分查找算法提速, 否者你的查询性能会非常差。</p>
<h1 id="3-sstiterator-代码实现"><a class="header" href="#3-sstiterator-代码实现">3 SstIterator 代码实现</a></h1>
<h2 id="31-sstiterator-定位函数"><a class="header" href="#31-sstiterator-定位函数">3.1 SstIterator 定位函数</a></h2>
<p>你需要实现下面的迭代器定位函数:</p>
<pre><code class="language-cpp">void SstIterator::seek_first() {
  // TODO: Lab 3.6 将迭代器定位到第一个key
}

void SstIterator::seek(const std::string &amp;key) {
  // TODO: Lab 3.6 将迭代器定位到指定key的位置
}
</code></pre>
<blockquote>
<p>Hint
这里的逻辑也很简单, 就是先使用记录在<code>sst</code>中的<code>meta_entries</code>找到包含要查找的<code>key</code>的<code>Block</code>(<code>find_block_idx</code>), 从文件中读取这个<code>Block</code>(<code>read_block</code>), 然后再读取的<code>Block</code>中调用获取指定<code>key</code>的迭代器的构造函数, 通过<code>BlockIterator</code>实现在<code>Block</code>中的定位。</p>
</blockquote>
<p><code>SST</code>创建迭代器时, 会在构造函数中选择是否偏移到指定的<code>key</code>, 你可以查看<code>SstIterator</code>的构造函数, 看看他们是如何与不同组件和函数见衔接的。</p>
<h2 id="32-运算符重载函数"><a class="header" href="#32-运算符重载函数">3.2 运算符重载函数</a></h2>
<p>作为迭代器, 我们的惯例就行要实现下面几个运算符重载函数:</p>
<pre><code class="language-cpp">BaseIterator &amp;SstIterator::operator++() {
  // TODO: Lab 3.6 实现迭代器自增
  return *this;
}

bool SstIterator::operator==(const BaseIterator &amp;other) const {
  // TODO: Lab 3.6 实现迭代器比较
  return false;
}

bool SstIterator::operator!=(const BaseIterator &amp;other) const {
  // TODO: Lab 3.6 实现迭代器比较
  return false;
}

SstIterator::value_type SstIterator::operator*() const {
  // TODO: Lab 3.6 实现迭代器解引用
  return {};
}
</code></pre>
<h1 id="4-补全-sst"><a class="header" href="#4-补全-sst">4 补全 SST</a></h1>
<p>在实现了<code>SstIterator</code>后, 你可以补全以<code>SST</code>中以<code>SstIterator</code>作为返回值的几个函数:</p>
<pre><code class="language-cpp">SstIterator SST::get(const std::string &amp;key, uint64_t tranc_id) {
  // TODO: Lab 3.6 根据查询`key`返回一个迭代器
  // ? 如果`key`不存在, 返回一个无效的迭代器即可
  throw std::runtime_error("Not implemented");
}

SstIterator SST::begin(uint64_t tranc_id) {
  // TODO: Lab 3.6 返回起始位置迭代器
  throw std::runtime_error("Not implemented");
}

SstIterator SST::end() {
  // TODO: Lab 3.6 返回终止位置迭代器
  throw std::runtime_error("Not implemented");
}
</code></pre>
<p>这几个函数都很简单, 因为具体的定位操作是在<code>SstIterator</code>内部完成的(虽然其反过来有调用了<code>SST</code>的<code>find_block_idx</code>等函数), 因此只需要调用<code>SstIterator</code>的构造函数即可。这里作为<code>Lab</code>的内容主要是为了让你对不同组件之间的交互有一个认真, 意思到这样一个设计思路: <strong>迭代器是连接不同组件的桥梁</strong>.</p>
<h1 id="5-测试-2"><a class="header" href="#5-测试-2">5 测试</a></h1>
<p>此次测试包含之前<a href="lab3/./lab3.5-SSTBuilder.html">Lab 3.5</a>的实现, 预期的结果是:</p>
<pre><code class="language-bash">✗ xmake
[100%]: build ok, spent 0.517s
✗ xmake run test_sst  
[==========] Running 8 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 8 tests from SSTTest
[ RUN      ] SSTTest.BasicWriteAndRead
[       OK ] SSTTest.BasicWriteAndRead (3 ms)
[ RUN      ] SSTTest.BlockSplitting
[       OK ] SSTTest.BlockSplitting (1 ms)
[ RUN      ] SSTTest.KeySearch
[       OK ] SSTTest.KeySearch (0 ms)
[ RUN      ] SSTTest.Metadata
[       OK ] SSTTest.Metadata (0 ms)
[ RUN      ] SSTTest.EmptySST
[       OK ] SSTTest.EmptySST (0 ms)
[ RUN      ] SSTTest.ReopenSST
[       OK ] SSTTest.ReopenSST (0 ms)
[ RUN      ] SSTTest.LargeSST
[       OK ] SSTTest.LargeSST (0 ms)
[ RUN      ] SSTTest.LargeSSTPredicate
test/test_sst.cpp:235: Failure
Value of: result.has_value()
  Actual: false
Expected: true

unknown file: Failure
C++ exception with description "bad optional access" thrown in the test body.

[  FAILED  ] SSTTest.LargeSSTPredicate (1 ms)
[----------] 8 tests from SSTTest (8 ms total)

[----------] Global test environment tear-down
[==========] 8 tests from 1 test suite ran. (8 ms total)
[  PASSED  ] 7 tests.
[  FAILED  ] 1 test, listed below:
[  FAILED  ] SSTTest.LargeSSTPredicate

 1 FAILED TEST
error: execv(/home/vanilla-beauty/proj/tiny-lsm/build/linux/x86_64/release/test_sst ) failed(1)
</code></pre>
<p>如果仅仅是得到一个可以跑的<code>SST</code>, 那么现在你已经完成的<code>SST</code>的大部分功能了。这里的<code>LargeSSTPredicate</code>需要你在实现下一小节的谓词查询后才能通过。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-37-范围查询"><a class="header" href="#lab-37-范围查询">Lab 3.7 范围查询</a></h1>
<h1 id="1-函数功能描述"><a class="header" href="#1-函数功能描述">1 函数功能描述</a></h1>
<p>同样地，我们设计了<code>sst_iters_monotony_predicate</code>函数，用于范围一段连续的区间, 这个区间是单调的, 只会在整个<code>SST</code>中出现一次, 例如包含指定前缀的一段范围。</p>
<p>不过这里我们将次函数定义为静态函数, 并放置于<code>src/sst/sst_iterator.cpp</code>中。因为我们之前进行了模块拆分， <code>SST</code>和<code>SstIterator</code>分别定义在了<code>src/sst/sst.cpp</code>和<code>src/sst/sst_iterator.cpp</code>中，而<code>sst_iters_monotony_predicate</code>函数需要同时访问<code>SST</code>和<code>SstIterator</code>，因此我们需要将<code>sst_iters_monotony_predicate</code>定义为静态函数, 并设定为以上两个类的友元函数.</p>
<h1 id="2-代码实现-3"><a class="header" href="#2-代码实现-3">2 代码实现</a></h1>
<p>你需要更改的文件:</p>
<ul>
<li><code>src/sst/sst_iterator.cpp</code></li>
</ul>
<p>你需要实现<code>sst_iters_monotony_predicate</code>函数:</p>
<pre><code class="language-cpp">// predicate返回值:
//   0: 谓词
//   &gt;0: 不满足谓词, 需要向右移动
//   &lt;0: 不满足谓词, 需要向左移动
std::optional&lt;std::pair&lt;SstIterator, SstIterator&gt;&gt; sst_iters_monotony_predicate(
    std::shared_ptr&lt;SST&gt; sst, uint64_t tranc_id,
    std::function&lt;int(const std::string &amp;)&gt; predicate) {
  // TODO: Lab 3.7 实现谓词查询功能
  return {};
}
</code></pre>
<blockquote>
<p>Hint</p>
<ul>
<li>这里的实现思路肯定是调用子组件<code>Block</code>的<code>get_monotony_predicate_iters</code>接口实现范围查询, 但你需要考虑不同<code>Block</code>查询结果的拼接, 即查询的目标可能跨<code>Block</code>分布</li>
<li><code>SST</code>中所有的<code>Block</code>都是有序的, 因此你在定位<code>Block</code>时, 也推荐使用类似二分查询的思路加快定位速度</li>
<li><code>src/sst/sst_iterator.cpp</code>中的<code>sst_iters_monotony_predicate</code>已经被设定为了<code>SST</code>和<code>SstIterator</code>的友元函数, 因此你可以随意访问<code>SST</code>和<code>SstIterator</code>的成员变量和函数, 这样应该可以简化你的实现</li>
</ul>
</blockquote>
<h1 id="3-测试--阶段2-结束"><a class="header" href="#3-测试--阶段2-结束">3 测试 &amp;&amp; 阶段2 结束</a></h1>
<p>现在, 你应该可以完成<code>test_sst</code>的所有测例:</p>
<pre><code class="language-bash">✗ xmake
✗ xmake run test_sst
[==========] Running 8 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 8 tests from SSTTest
[ RUN      ] SSTTest.BasicWriteAndRead
[       OK ] SSTTest.BasicWriteAndRead (2 ms)
[ RUN      ] SSTTest.BlockSplitting
[       OK ] SSTTest.BlockSplitting (0 ms)
[ RUN      ] SSTTest.KeySearch
[       OK ] SSTTest.KeySearch (0 ms)
[ RUN      ] SSTTest.Metadata
[       OK ] SSTTest.Metadata (0 ms)
[ RUN      ] SSTTest.EmptySST
[       OK ] SSTTest.EmptySST (0 ms)
[ RUN      ] SSTTest.ReopenSST
[       OK ] SSTTest.ReopenSST (0 ms)
[ RUN      ] SSTTest.LargeSST
[       OK ] SSTTest.LargeSST (0 ms)
[ RUN      ] SSTTest.LargeSSTPredicate
[       OK ] SSTTest.LargeSSTPredicate (0 ms)
[----------] 8 tests from SSTTest (6 ms total)

[----------] Global test environment tear-down
[==========] 8 tests from 1 test suite ran. (6 ms total)
[  PASSED  ] 8 tests.
</code></pre>
<h1 id="4-思考--下一步"><a class="header" href="#4-思考--下一步">4 思考 &amp;&amp; 下一步?</a></h1>
<p>现在你已经实现了<code>SST</code>的基本特性, 而剩余的<code>SST</code>特性还包括:</p>
<ul>
<li>不同<code>Level</code>的<code>SST</code>的压缩合并</li>
<li>缓存池和布隆过滤器的优化</li>
<li>以<code>Level</code>层级为单位的迭代器(就是将一整个<code>Level</code>的多个<code>SST</code>组织成一个迭代器)</li>
</ul>
<p>以上这些内容, 你将在<a href="lab3/../lab4/lab4-LSM-Engine.html">Lab 4 LSM Engine</a>中实现。因为以上的组件需要上层组件的控制，例如我们的缓存池是全局共享而非单个<code>SST</code>独有的, 因此需要上层组件进行初始化和分配。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-4-lsm-engine"><a class="header" href="#lab-4-lsm-engine">Lab 4 LSM Engine</a></h1>
<p>本章<code>Lab</code>将串联之前实现的<code>MemTable</code>, <code>SST</code>, <code>Block</code>, 各类<code>Iterator</code>, 实现一个初版的完整的单机<code>KV</code>存储引擎。</p>
<blockquote>
<p>提示: 强烈建议你自己创建一个分组实现<code>Lab</code>的内容, 并在每次新的<code>Lab</code>开始时进行如下同步操作:</p>
<pre><code class="language-bash">git pull origin lab
git checkout your_branch
git merge lab
</code></pre>
<p>如果你发现项目仓库的代码没有指导书中的 TODO 标记的话, 证明你需要运行上述命令更新代码了</p>
</blockquote>
<h1 id="1-概述-6"><a class="header" href="#1-概述-6">1 概述</a></h1>
<p>实现了之前的<code>Skiplist</code>, <code>MemTable</code>, <code>SST</code>, <code>Block</code>, 各类<code>Iterator</code>之后, 我们对其进行"简单"地封装, 即可得到一份可以运行的<code>LSM Engine</code>。完成这一章<code>Lab</code>后, 你将得到一个可以被外部结构调用的共享链接库, 其暴露了各种基础的<code>KV</code>存储引擎接口。</p>
<p>同样地, 我们再一次回顾我们的架构:</p>
<p><img src="lab4/../images/intro/tiny-lsm-arch.drawio.png" alt="Fig 1" /></p>
<p>可以看到, 不同组件之间存在各种交互, 这些交互内容包括:</p>
<ol>
<li><code>MemTable</code>和<code>SST</code>之间进行<code>Encoded</code>并刷盘形成<code>SST文件</code></li>
<li>不同<code>SST</code>之间的连接(例如遍历这一层的<code>SST</code>的键值对)</li>
<li>相邻<code>Level</code>之间<code>SST</code>的<code>Compact</code>操作</li>
<li><code>Client</code>发出<code>Get</code>请求到<code>MemTable</code>和<code>SST</code>组件的查询路径</li>
</ol>
<p>这一章的<code>Lab</code>就是将我们之前已经实现的组件进行串联, 形成初版的<code>LSM Tree</code>存储引擎。</p>
<h1 id="2-思考"><a class="header" href="#2-思考">2 思考</a></h1>
<p>同样地, 请先思考下面几个问题, 然后带着问题开始本章的<code>Lab</code>:</p>
<ol>
<li>不同组件之间交互的媒介是什么? 是迭代器吗?</li>
<li>之前提到的布隆过滤器和缓存池的优化并未在架构图中给出, 他们位于哪个位置?</li>
<li>缓存池缓存的是<code>Blcok</code>, 但如果<code>SST</code>被压缩形成新的<code>SST</code>文件, 缓存池中的<code>Block</code>将不再有效, 缓存池中的无效的<code>Block</code>将如何处理?</li>
<li>不同<code>Level</code>的<code>SST Compact</code>采用什么策略? 他们对<code>Read/Write</code>性能有什么影响?</li>
<li>我们实现整个<code>LSM Engine</code>的范围查询等操作时, 去重和排序逻辑和之前的组件有什么区别?</li>
<li>为什么<code>Level 0</code>要设计成<code>Unsorted</code>? 所有的<code>Level</code>的<code>SST</code>都是<code>Sorted</code>不好吗?</li>
<li>不同组件交互过程中, 如何设计并发控制策略, 保证其性能?</li>
<li>实现上述的功能, 是不是又要设计新的迭代器?</li>
</ol>
<blockquote>
<p>这些问题你不一定要马上给出一个清晰的答案, 只需要有一个整体的认知和思考即可, 这样有助于你对整个项目代码设计思路的理解。</p>
<p>由于本实现的设计目的就是让更广大的开发者或CS专业的学生对<code>KV</code>存储有初步的认真, 因此难度是被刻意降低了的, 你不需要进行架构设计层面的思考以及对应代码的编写, 只需要补全作者挖空的关键函数。</p>
<p>因此，如果你一味地完成<code>Lab</code>的代码, 却缺乏对作者给出思考题的理解, 那么你对本实验项目的理解可能是不到位的, 即你知道这么设计的代码能正常运行, 但却不知道他为什么这么设计。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阶段1-engine-基础功能"><a class="header" href="#阶段1-engine-基础功能">阶段1-Engine 基础功能</a></h1>
<p>在这一阶段中, 你将实现最基本的<code>LSM Tree</code>存储引擎的<code>CRUD</code>接口, 在之后的阶段二中你将实现性能优化部分的内容。</p>
<p>阶段一的内容包括：</p>
<ul>
<li>数据的写入 &amp;&amp; <code>SST文件</code>的构造</li>
<li><code>SST文件</code>的加载 &amp;&amp; 数据查询</li>
</ul>
<blockquote>
<p>提示: 强烈建议你自己创建一个分组实现<code>Lab</code>的内容, 并在每次新的<code>Lab</code>开始时进行如下同步操作:</p>
<pre><code class="language-bash">git pull origin lab
git checkout your_branch
git merge lab
</code></pre>
<p>如果你发现项目仓库的代码没有指导书中的 TODO 标记的话, 证明你需要运行上述命令更新代码了</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-41-engine-的写入"><a class="header" href="#lab-41-engine-的写入">Lab 4.1 Engine 的写入</a></h1>
<h1 id="1-概述-7"><a class="header" href="#1-概述-7">1 概述</a></h1>
<p>与之前的模块不同, <code>LSMEngine</code>部分我们不打算按照<code>CRUD</code>迭代器的顺序进行实验, 因为其<code>Put</code>操作包含了<code>SST</code>的构建流程, 而<code>Get</code>操作是对已经构建的<code>SST</code>进行查询, 因此, 本章的<code>Lab</code>以<code>SST</code>的生命周期为线索, 逐步实现<code>Lab</code>, 这样的设计也有助于你对上层组件运行调度机制的理解。</p>
<p>话不多说，我们先来看看<code>Engine</code>的头文件定义, 然后结合理论知识, 介绍<code>put</code>流程和<code>sst</code>的构建流程</p>
<pre><code class="language-cpp">class Level_Iterator;

class LSMEngine : public std::enable_shared_from_this&lt;LSMEngine&gt; {
public:
  std::string data_dir;
  MemTable memtable;
  std::map&lt;size_t, std::deque&lt;size_t&gt;&gt; level_sst_ids;
  std::unordered_map&lt;size_t, std::shared_ptr&lt;SST&gt;&gt; ssts;
  std::shared_mutex ssts_mtx;
  std::shared_ptr&lt;BlockCache&gt; block_cache;
  size_t next_sst_id = 0; // 下一个要分配的 sst id
  size_t cur_max_level = 0; // 当前最大的 level
};

class LSM {
private:
  std::shared_ptr&lt;LSMEngine&gt; engine;
  std::shared_ptr&lt;TranManager&gt; tran_manager_; // 本Lab不需要关注
};
</code></pre>
<p>这里, 我们使用了<code>LSM</code>包裹了<code>LSMEngine</code>, <code>LSMEngine</code>是你要补全函数实现的类, 其中定义了<code>memtable</code>, <code>level_sst_ids</code>, <code>ssts</code>, <code>block_cache</code>, <code>next_sst_id</code>, <code>cur_max_level</code>等成员变量。这里比较重要的包括:</p>
<ul>
<li><code>level_sst_ids</code>: 从<code>level</code>到这一层的<code>sst_id</code>数组, 每一个<code>SST</code>由一个<code>sst_id</code>唯一表示</li>
<li><code>ssts</code>: <code>sst_id</code>到<code>SST</code>的映射</li>
<li><code>next_sst_id</code>: <code>SST</code>的<code>id</code>分配器, <code>LSMEngine</code>在<code>flush</code>形成行的<code>SST</code>时, 会分配一个<code>sst_id</code>给<code>SST</code>, 然后将<code>sst_id</code>和<code>SST</code>映射关系存入<code>ssts</code>中, <code>next_sst_id</code>就是<code>sst_id</code>的分配器, 每次分配<code>sst_id</code>时, <code>next_sst_id</code>都会自增1</li>
<li><code>cur_max_level</code>: 顾名思义, 就是当前<code>SST</code>的最大的<code>level</code></li>
<li><code>data_dir</code>: <code>LSMEngine</code>的<code>data_dir</code>, 即数据文件的存储位置, 这个参数我们在单元测试中会进行指定, <code>SST</code>文件需要存放在这个目录下</li>
<li><code>MemTable</code>: 即整个<code>LSM Tree</code>引擎的内存表部分</li>
</ul>
<p>剩下的成员变量:</p>
<ul>
<li><code>ssts_mtx</code>: 全局的<code>sst文件</code>的访问锁, 这里是一个读写锁, 当然这个变量不是必须的, 你可以按照自己的理解实现并发控制策略(不过建议使用这个变量)</li>
<li><code>block_cache</code>: 全局的缓存池指针, 你实现缓存池之前, 默认其为<code>nullptr</code>即可</li>
</ul>
<blockquote>
<p>这里的<code>l0_sst_ids</code>记录了所有<code>sst</code>的<code>id</code>, 其排序是从大到小, 因为<code>sst</code>的<code>id</code>越大表示这个<code>sst</code>越新, 需要优先查询。</p>
<p>可以使用<code>l0_sst_ids</code>获取的<code>id</code>从哈希表<code>ssts</code>中查询<code>SST</code>的描述类(类似于文件描述符)。</p>
</blockquote>
<h1 id="2-写入删除流程"><a class="header" href="#2-写入删除流程">2 写入/删除流程</a></h1>
<p>结合刚刚对类的成员变量定义的简单介绍, 我们再次回顾一下<code>LSM Tree</code>的读写流程:</p>
<ol>
<li>写入<code>MemTable</code>:
<ol>
<li>如果写入的<code>KV</code>的<code>value</code>为空, 表示一个删除标记</li>
<li>直接调用成员变量<code>memtable</code>的接口即可</li>
<li>同样有批量接口和单次操作的接口</li>
</ol>
</li>
<li>若当前活跃的<code>MemTable</code>大小达到阈值, 则将其冻结
<ol>
<li>这一部分已经在<code>MemTable</code>中实现, 你无需再实现</li>
</ol>
</li>
<li>若冻结的<code>MemTable</code>容量达到阈值, 则将最早冻结的<code>MemTable</code>转为<code>SST</code>
<ol>
<li>判断<code>MemTable</code>容量并决定是否刷盘是你需要在本小节<code>Lab</code>进行实现的内容之一</li>
<li><code>SST</code>文件的设计是每一层的<code>SST文件</code>数量不能超过指定阈值, 因此你刷盘的<code>Level 0</code>的<code>SST</code>文件可能会哦触发<code>Level 0</code>和<code>Level 1</code>的<code>SST</code>文件的<code>compact</code>, 不过这一任务没有放在<code>Lab 4.1</code>, <code>Lab4.1</code>中你当做就只有<code>Level 0</code>这一个层级即可</li>
</ol>
</li>
</ol>
<p>因此, 本小节<code>Lab</code>的核心就是整合之前创建的<code>MemTable</code>, <code>SST</code>, <code>Block</code>, <code>Iterator</code>, 并调用接口实现对外服务的功能</p>
<h1 id="3-代码实现"><a class="header" href="#3-代码实现">3 代码实现</a></h1>
<p>本小节你需要更改的代码文件为:</p>
<ul>
<li><code>src/lsm/engine.cpp</code></li>
<li><code>include/lsm/engine.h</code></li>
</ul>
<h2 id="31-put--remove"><a class="header" href="#31-put--remove">3.1 Put &amp;&amp; Remove</a></h2>
<p>你首先需要实现<code>put</code>函数, <code>put</code>函数肯定是操纵<code>memtable</code>成员变量, 另外你也需要根据其容量接口函数判断什么时候需要进行<code>flush</code>操作:</p>
<pre><code class="language-cpp">uint64_t LSMEngine::put(const std::string &amp;key, const std::string &amp;value,
                        uint64_t tranc_id) {
  // TODO: Lab 4.1 插入
  // ? 由于 put 操作可能触发 flush
  // ? 如果触发了 flush 则返回新刷盘的 sst 的 id
  // ? 在没有实现  flush 的情况下，你返回 0即可
  return 0;
}
uint64_t LSMEngine::remove(const std::string &amp;key, uint64_t tranc_id) {
  // TODO: Lab 4.1 删除
  // ? 在 LSM 中，删除实际上是插入一个空值
  // ? 由于 put 操作可能触发 flush
  // ? 如果触发了 flush 则返回新刷盘的 sst 的 id
  // ? 在没有实现  flush 的情况下，你返回 0即可
  return 0;
}
</code></pre>
<p>这个函数的最终版本需要调用<code>flush</code>进行刷盘, 因此建议你将次函数和后面的<code>flush</code>函数一起实现。</p>
<p>此时你仍然可以忽略<code>tranc_id</code>, 将其传递到接口的参数即可。至于返回值<code>uint64_t</code>, 你现阶段返回0即可。</p>
<blockquote>
<p>额外说明, 这里说明一下为什么返回值是<code>uint64_t</code>，而不是<code>void</code>, 这主要是为后续的事务准备的, 刷盘意味着事务操作的持久化完成, 因此需要更新已经成功持久化的最大事务<code>id</code>, 也就是这里的返回值。如果你现在看不懂也没关系, 到实现事务的<code>Lab</code>就明白了。</p>
</blockquote>
<p>根据之前部分描述, 此时你可以简化刷盘部分的逻辑, 即默认现在只有<code>Level 0</code>的<code>SST文件</code>, <code>SST文件</code>不会进行<code>Compact</code>形成新的<code>Level</code></p>
<h2 id="32-put_batch--remove_batch"><a class="header" href="#32-put_batch--remove_batch">3.2 put_batch &amp;&amp; remove_batch</a></h2>
<p>和<code>put/remove</code>函数的逻辑几乎一样, 只是写入时是批量数据:</p>
<pre><code class="language-cpp">uint64_t LSMEngine::put_batch(
    const std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; &amp;kvs,
    uint64_t tranc_id) {
  // TODO: Lab 4.1 批量插入
  // ? 由于 put 操作可能触发 flush
  // ? 如果触发了 flush 则返回新刷盘的 sst 的 id
  // ? 在没有实现  flush 的情况下，你返回 0即可
  return 0;
}

uint64_t LSMEngine::remove_batch(const std::vector&lt;std::string&gt; &amp;keys,
                                 uint64_t tranc_id) {
  // TODO: Lab 4.1 批量删除
  // ? 在 LSM 中，删除实际上是插入一个空值
  // ? 由于 put 操作可能触发 flush
  // ? 如果触发了 flush 则返回新刷盘的 sst 的 id
  // ? 在没有实现  flush 的情况下，你返回 0即可
  return 0;
}
</code></pre>
<h2 id="33-flush"><a class="header" href="#33-flush">3.3 Flush</a></h2>
<p><code>flush</code>函数会将<code>MemTable</code>中<code>frozen_tables</code>中最旧的一个跳表的数据刷盘，并返回刷盘过程中提取的统计信息<code>tranc_id</code>, 现阶段你只需要返回0即可。</p>
<blockquote>
<p><strong>Hint</strong>:
<code>flush()</code>的返回值是和<code>put()</code>等接口的返回值一致的</p>
</blockquote>
<pre><code class="language-cpp">uint64_t LSMEngine::flush() {
  // TODO: Lab 4.1 刷盘形成sst文件
  return 0;
}
</code></pre>
<p><code>flush</code>函数应该是这一小节的关键函数了, 这里的逻辑就是从<code>memtable</code>的接口将最旧的跳表刷盘城<code>SST</code>文件, 这里涉及到文件<code>IO</code>的操作时, 推荐使用作者定义好的辅助类<code>FileObj</code>, 其定义在<code>include/utils/files.h</code>中, 如果你有兴趣, 也可以看看``include/utils`中定义的其他工具类及其实现。</p>
<p>最后，<code>SST文件</code>的命名格式已经在<code>get_sst_path</code>中进行了详细的说明:</p>
<pre><code class="language-cpp">std::string LSMEngine::get_sst_path(size_t sst_id, size_t target_level) {
  // sst的文件路径格式为: data_dir/sst_&lt;sst_id&gt;.&lt;level&gt;，sst_id格式化为32位数字
  std::stringstream ss;
  ss &lt;&lt; data_dir &lt;&lt; "/sst_" &lt;&lt; std::setfill('0') &lt;&lt; std::setw(32) &lt;&lt; sst_id
     &lt;&lt; '.' &lt;&lt; target_level;
  return ss.str();
}
</code></pre>
<blockquote>
<p>后缀标记了这个<code>SST文件</code>所属的<code>Level</code>, 在你实现<code>Compact</code>前, 这个后缀设置为0即可</p>
</blockquote>
<p><strong>你必须严格遵守<code>SST</code>文件格式的命名规范, 如果你采用自己的文件命名方式, 那么请自行修改对应的单元测试函数(非常不推荐)。</strong></p>
<h1 id="4-测试-2"><a class="header" href="#4-测试-2">4 测试</a></h1>
<p>由于我们目前仅实现了写入模块, 测试函数无法从引擎读取数据, 因此本小节没有单元测试, 当你实现<a href="lab4/./lab4.2-Engine-read.html">Lab 4.2 Engine 的读取</a>后会进行统一的单元测试。</p>
<h1 id="5-思考"><a class="header" href="#5-思考">5 思考</a></h1>
<p>现在请先思考一下几个问题，然后开启<a href="lab4/./lab4.2-Engine-read.html">Lab 4.2 Engine 的读取</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-42-engine-的读取"><a class="header" href="#lab-42-engine-的读取">Lab 4.2 Engine 的读取</a></h1>
<h1 id="1-概述-8"><a class="header" href="#1-概述-8">1 概述</a></h1>
<p>从之前 <a href="lab4/./lab4.1-Engine-write.html">Lab 4.1 Engine 的写入</a>中, 我们已经实现了<code>SST</code>的构建流程, 这一章我们将实现<code>Engine</code>的读取流程。(这里的读取还包括引擎的初始化流程中对<code>SST文件</code>的读取)</p>
<p>同样地, 我们想从逻辑上梳理引擎的读取和查询流程:</p>
<p><strong>1 存储引擎启动时</strong></p>
<p>遍历<code>data_dir</code>下的<code>SST</code>文件, 将<code>SST</code>文件的元信息加载到内存中</p>
<p><strong>2 接受查询请求</strong></p>
<ol>
<li>查询当前活跃的<code>MemTable</code>, 如果查到有效记录或删除记录, 则返回</li>
<li>若查询当前活跃的<code>MemTable</code>未命中, 则遍历冻结的<code>MemTable</code>, 由于冻结的<code>MemTable</code>也存在次序, 需要先查询最近冻结的<code>MemTable</code></li>
<li>若查询冻结的<code>MemTable</code>未命中, 则遍历<code>SST</code>, 由于<code>SST</code>也存在次序, 需要先查询最近创建的<code>SST</code>
<ol>
<li><code>SST</code>的顺序先按照<code>Level</code>排序, <code>Level</code>越低的<code>SST</code>越新, 需要先查询</li>
<li>相同<code>Level</code>的<code>SST</code>按照<code>sst_id</code>排序, 这里的逻辑有所不同:
<ol>
<li>如果是<code>Level 0</code>的<code>SST</code>, 则按照<code>sst_id</code>排序, 从大到小查询, 越大的<code>sst_id</code>表示这个<code>SST</code>越新, 需要有限查询</li>
<li>如果是其他<code>Level</code>以上的<code>SST</code>, 其所有的<code>SST</code>的<code>key</code>都是有序分布且不重叠的, 既然<code>key</code>不重叠也就无所谓谁的优先级更高、谁会覆盖谁的<code>key</code>, 可以采用二分查询实现更高的效率, 下面是一个<code>SST文件</code>的案例:
<pre><code class="language-bash">Level 0: sst_15(key000-key050), sst_14(key005-key030), sst_13(key020-key040)
Level 1: sst_10(key100-key120), sst_11(key121-key140), sst_12(key141-key160)
Level 2: sst_08(key100-key120), sst_09(key121-key140)
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li>整个<code>SST</code>文件遍历完成后, 若仍未命中, 则返回空指针表示<code>key</code>没有找到</li>
</ol>
<blockquote>
<p><strong>补充</strong></p>
<ul>
<li>在后续实现<code>WAL</code>后, 在上述所有流程前, 会有一个对<code>WAL</code>日志进行检查并实现崩溃恢复的流程</li>
</ul>
</blockquote>
<h1 id="2-代码实现-4"><a class="header" href="#2-代码实现-4">2 代码实现</a></h1>
<p>本小节你需要更改的代码文件为:</p>
<ul>
<li><code>src/lsm/engine.cpp</code></li>
<li><code>include/lsm/engine.h</code></li>
</ul>
<h2 id="21-引擎的初始化"><a class="header" href="#21-引擎的初始化">2.1 引擎的初始化</a></h2>
<p>上一章<a href="lab4/./lab4.1-Engine-write.html">Lab 4.1 Engine 的写入</a>中, 我们在<code>put</code>操作中惰性触发了<code>SST</code>的刷盘操作, 因此在<code>Engine</code>启动时, 我们需要遍历<code>data_dir</code>下的<code>SST</code>文件, 将<code>SST</code>文件的元信息加载到内存中, 以便后续的查询操作:</p>
<pre><code class="language-cpp">LSMEngine::LSMEngine(std::string path) : data_dir(path) {
  // 初始化日志
  init_spdlog_file();

  // TODO: Lab 4.2 引擎初始化
}
</code></pre>
<p><strong>说明</strong></p>
<ol>
<li>后续实现缓存池后, 构造函数中需要对缓存池进行初始化, 现阶段你的构造函数, 只需要将<code>block_cache</code>初始化为<code>nullptr</code>即可</li>
<li>第一次启动引擎时, 需要创建数据目录</li>
<li><code>init_spdlog_file</code>函数用于初始化日志, 其内部是对<code>std::call_once</code>的封装, 因此其只有第一次调用时会执行</li>
</ol>
<blockquote>
<p><strong>Hint</strong></p>
<ol>
<li>你需要从<code>SST文件</code>的命名格式中对<code>next_sst_id</code>和<code>cur_max_level</code>进行更新</li>
<li><code>level_sst_ids</code>映射的数组需要你自己维护其优先级顺序, 不同<code>Level</code>的<code>SST</code>文件优先级可能不同, 现在你不需要关心<code>Level 0</code>以外的<code>SST</code></li>
</ol>
</blockquote>
<h2 id="22-查询接口"><a class="header" href="#22-查询接口">2.2 查询接口</a></h2>
<h3 id="221-get"><a class="header" href="#221-get">2.2.1 get</a></h3>
<pre><code class="language-cpp">std::optional&lt;std::pair&lt;std::string, uint64_t&gt;&gt;
LSMEngine::get(const std::string &amp;key, uint64_t tranc_id) {
  // TODO: Lab 4.2 查询

  return std::nullopt;
}
</code></pre>
<p>这里传入的<code>uint64_t tranc_id</code>是为了在实现事务功能后控制不同事务的可见性的, 也就是实现事务基础属性中的<strong>隔离性</strong>, 现阶段你可以忽略它</p>
<p>此外, 这里的返回值是一个由<code>optional</code>包裹的<code>pair</code>, <code>pair</code>的第一个元素是<code>value</code>, 第二个元素是<code>tranc_id</code>, <code>value</code>表示查询到的值, <code>tranc_id</code>表示这个键值对最新的修改事务的的<code>tranc_id</code>(现阶段同样可以忽略), 如果查询不到, 则返回<code>std::nullopt</code></p>
<h3 id="222-get_batch"><a class="header" href="#222-get_batch">2.2.2 get_batch</a></h3>
<pre><code class="language-cpp">std::vector&lt;
    std::pair&lt;std::string, std::optional&lt;std::pair&lt;std::string, uint64_t&gt;&gt;&gt;&gt;
LSMEngine::get_batch(const std::vector&lt;std::string&gt; &amp;keys, uint64_t tranc_id) {
  // TODO: Lab 4.2 批量查询

  return {};
}
</code></pre>
<p>没啥好说的, 就是在<code>get</code>的基础上变成了批量查询</p>
<h3 id="223-sst_get_"><a class="header" href="#223-sst_get_">2.2.3 sst_get_</a></h3>
<p>通过后缀你可以看出, 这个查询是专门在<code>SST</code>中进行查询的接口, 其<code>_</code>表示这个函数是不需要进行加锁操作的, 其加锁逻辑是其他上层组件控制的:</p>
<pre><code class="language-cpp">std::optional&lt;std::pair&lt;std::string, uint64_t&gt;&gt;
LSMEngine::sst_get_(const std::string &amp;key, uint64_t tranc_id) {
  // TODO: Lab 4.2 sst 内部查询
  return std::nullopt;
}
</code></pre>
<blockquote>
<p>思考: 什么情况下会单独对<code>SST</code>部分进行查询?</p>
</blockquote>
<h1 id="3-测试-5"><a class="header" href="#3-测试-5">3 测试</a></h1>
<p>完成<a href="lab4/./lab4.1-Engine-write.html">Lab 4.1 Engine 的写入</a>和本节<code>Lab</code>后, 你应该能通过<code>test/test_lsm.cpp</code>中<code>IteratorOperations</code>前的所有单元测试:</p>
<pre><code class="language-bash">✗ xmake
[100%]: build ok, spent 1.936s
✗ xmake run test_lsm
[==========] Running 9 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 9 tests from LSMTest
[ RUN      ] LSMTest.BasicOperations
[       OK ] LSMTest.BasicOperations (0 ms)
[ RUN      ] LSMTest.Persistence
[       OK ] LSMTest.Persistence (228 ms)
[ RUN      ] LSMTest.LargeScaleOperations
[       OK ] LSMTest.LargeScaleOperations (1 ms)
[ RUN      ] LSMTest.MixedOperations
[       OK ] LSMTest.MixedOperations (0 ms)
[ RUN      ] LSMTest.IteratorOperations
unknown file: Failure
C++ exception with description "Not implemented" thrown in the test body.

[  FAILED  ] LSMTest.IteratorOperations (0 ms)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阶段2-迭代器--compact"><a class="header" href="#阶段2-迭代器--compact">阶段2-迭代器 &amp;&amp; Compact</a></h1>
<h2 id="子任务1-迭代器"><a class="header" href="#子任务1-迭代器">子任务1-迭代器</a></h2>
<p>之前你已经完成了具备初步的简单<code>CURD</code>操作的<code>LSM Tree</code>存储引擎, 但你应该发现了, 诸如范围查询、全局迭代器等功能，我们并没有放在 <a href="lab4/./Engine-Base.html">第一阶段</a>, 这是因为以上接口都需要不同组件之间(不同<code>Level</code>的<code>SST</code>和<code>MemTable</code>)进行交互, 而这些组件之间的交互需要我们实现更高级的迭代器才可以完成, 因此这一小节你将实现各种迭代器。</p>
<p>你需要实现的迭代器包括：</p>
<ul>
<li><code>TwoMergeIterator</code>
<ul>
<li>其主要用于整合2个迭代器, 按照不同的优先级顺序对迭代器进行遍历</li>
<li>这里的两个迭代器通常情况下就是内存<code>MemTable</code>的迭代器和<code>SST</code>部分的迭代器, 前者优先级更高</li>
</ul>
</li>
<li><code>ConcactIterator</code>
<ul>
<li>用于连接某一层<code>Level</code>的多个<code>SST</code></li>
<li>此处默认多个<code>SST</code>是不重叠且排序的, 因此使用于<code>Level &gt; 0</code>的<code>SST</code>的连接</li>
</ul>
</li>
<li><code>LevelIterator</code>
<ul>
<li>类似<code>TwoMergeIterator</code>, 但整合的迭代器数量更多</li>
<li>例如, 每个<code>Level</code>都有一个层间的迭代器</li>
</ul>
</li>
</ul>
<blockquote>
<p>提示: 强烈建议你自己创建一个分组实现<code>Lab</code>的内容, 并在每次新的<code>Lab</code>开始时进行如下同步操作:</p>
<pre><code class="language-bash">git pull origin lab
git checkout your_branch
git merge lab
</code></pre>
<p>如果你发现项目仓库的代码没有指导书中的 TODO 标记的话, 证明你需要运行上述命令更新代码了</p>
</blockquote>
<p><strong>思考</strong>
为什么我们要在实现<code>Compact</code>之前先实现这些迭代器?</p>
<h2 id="子任务2-compact"><a class="header" href="#子任务2-compact">子任务2-Compact</a></h2>
<p>这里的<code>Compact</code>操作需要我们的迭代器作为信息交互的接口, 具体原因请参见<a href="lab4/./lab4.3-ConcactIterator.html">Lab 4.3 ConcactIterator
</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-43-concactiterator"><a class="header" href="#lab-43-concactiterator">Lab 4.3 ConcactIterator</a></h1>
<h1 id="1-概述-9"><a class="header" href="#1-概述-9">1 概述</a></h1>
<p>其实这一章出现在这里是有一点突兀的, 照理说我们正常实现基础<code>LSMEngine</code>的下一个步骤是<code>Compact</code>。讲到这里我们接得知道<code>Compact</code>的逻辑了。</p>
<p>这里用一个具体案例进行讲解。</p>
<p>我们假设此时的<code>SST</code>状态是这样的:</p>
<pre><code class="language-bash">Level 0: sst_15(key000-key050), sst_14(key005-key030), sst_13(key020-key040)
Level 1: sst_10(key100-key120), sst_11(key121-key140), sst_12(key141-key160)
Level 2: sst_08(key100-key120), sst_09(key121-key140)
</code></pre>
<p>我们对每一层的<code>SST</code>需要进行限制, 当这一层的<code>SST</code>数量超过阈值时, 我们需要将这一层所有的<code>SST</code>进行<code>Compact</code>到下一层。</p>
<p>在这个案例中, 我们下一次<code>flush</code>刷盘后, 假设得到了一个<code>Level 0</code>的<code>SST</code>为<code>sst_16(key060-key080)</code>, 那么此时<code>Level 0</code>的<code>SST</code>数量超过了阈值4(这个是是假定的, 实际上是可在<code>config.toml</code>中配置的), 我们需要将<code>Level 0</code>的<code>SST</code>进行<code>sst_16, sst_15, sst_14, sst_13</code>到<code>Level 1</code>。但我们新<code>Compact</code>的<code>SST</code>会和<code>Level 1</code>本来的<code>SST</code>的<code>key</code>存在范围重叠, 这是不允许的, 所以实际上, 我们是将原来的<code>Level 0</code>和旧的<code>Level 1</code>的所有<code>SST</code>一并进行重新整理<code>Compact</code>形成新的<code>Level 1 SST</code>, 这里实际上就是用迭代器将2个<code>Level</code>的迭代器进行串联, 遍历这个迭代器, 逐一构建新的<code>Level 1</code>的<code>SST</code>, 那么是怎么个串联法呢?</p>
<ol>
<li>首先, <code>Level 0</code>的<code>SST</code>之间存在<code>key</code>的重叠, 需要进行去重, 这里我们可以复用已有的<code>HeapIterator</code>, 见<a href="lab4/../lab2/lab2.2-iterator.html">Lab 2.2 迭代器</a></li>
<li>其次就是我们将要实现的<code>ConcactIterator</code>, 这个迭代器会串联<code>Level 1</code>的所有<code>SST</code>形成层间迭代器</li>
<li>最后就是之后小节实现的<code>TwoMergeIterator</code>, 这个迭代器会串联<code>HeapIterator</code>和<code>ConcactIterator</code>, 按照优先级对迭代器进行输出, 遍历<code>TwoMergeIterator</code>即可构建新的<code>Level 1</code>的<code>SST</code></li>
</ol>
<blockquote>
<p><strong>Question</strong></p>
<p>如果<code>Compact</code>发生的<code>Level</code>不是<code>Level 0</code>和<code>Level 1</code>, 而是<code>Level x</code>和<code>Level y</code>(<code>x&gt;0</code>)呢?</p>
<p>答案显而易见, 还是用<code>TwoMergeIterator</code>对2个<code>Level</code>的层间迭代器进行遍历, 遍历过程中构造新的<code>Level y</code>的<code>SST</code>。只是<code>TwoMergeIterator</code>中包裹的<code>Level x</code>的迭代器从<code>HeapIterator</code>变成了<code>ConcactIterator</code>。</p>
</blockquote>
<p>这一小节我们先实现<code>ConcactIterator</code>。</p>
<h1 id="2-代码实现-5"><a class="header" href="#2-代码实现-5">2 代码实现</a></h1>
<p>你需要修改的文件:</p>
<ul>
<li><code>src/sst/concact_iterator.cpp</code></li>
<li><code>include/sst/concact_iterator.h</code> (Optional)</li>
</ul>
<h2 id="21-头文件分析"><a class="header" href="#21-头文件分析">2.1 头文件分析</a></h2>
<p>按照惯例, 我们简单分析下头文件定义:</p>
<pre><code class="language-cpp">class ConcactIterator : public BaseIterator {
private:
  SstIterator cur_iter;
  size_t cur_idx; // 不是真实的sst_id, 而是在需要连接的sst数组中的索引
  std::vector&lt;std::shared_ptr&lt;SST&gt;&gt; ssts;
  uint64_t max_tranc_id_;
};
</code></pre>
<p>这里的<code>ssts</code>就是这一层所有<code>SST</code>句柄的数组, <code>cur_idx</code>是当前迭代器指向的<code>SST</code>在<code>ssts</code>中的索引, <code>cur_iter</code>是当前<code>cur_idx</code>指向的<code>SST</code>的迭代器。</p>
<p><code>max_tranc_id_</code>是调用这个迭代器的事务<code>id</code>, 也就是其最大的事务可见范围, 现在你不需要实现。</p>
<h2 id="22-concactiterator-实现"><a class="header" href="#22-concactiterator-实现">2.2 ConcactIterator 实现</a></h2>
<p>这一章由于我们先介绍了<code>Compact</code>过程中的逻辑, 因此就先实现最简单的一个<code>ConcactIterator</code>:</p>
<pre><code class="language-cpp">BaseIterator &amp;ConcactIterator::operator++() {
  // TODO: Lab 4.3 自增运算符重载
  return *this;
}

bool ConcactIterator::operator==(const BaseIterator &amp;other) const {
  // TODO: Lab 4.3 比较运算符重载
  return false;
}

bool ConcactIterator::operator!=(const BaseIterator &amp;other) const {
  // TODO: Lab 4.3 比较运算符重载
  return false;
}

ConcactIterator::value_type ConcactIterator::operator*() const {
  // TODO: Lab 4.3 解引用运算符重载
  return value_type();
}
ConcactIterator::pointer ConcactIterator::operator-&gt;() const {
  // TODO: Lab 4.3 -&gt;运算符重载
  return nullptr;
}
</code></pre>
<p>这里基本上都是实现迭代器的运算符重载函数, 算是比较简单的一个小<code>Lab</code></p>
<h1 id="3-测试-6"><a class="header" href="#3-测试-6">3 测试</a></h1>
<p>本小节没有测试, 你完成后续迭代器和涉及迭代器的查询操作后有统一的单元测试。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-44-twomergeiterator"><a class="header" href="#lab-44-twomergeiterator">Lab 4.4 TwoMergeIterator</a></h1>
<h1 id="1-概述-10"><a class="header" href="#1-概述-10">1 概述</a></h1>
<p>根据上一节<a href="lab4/./lab4.3-ConcactIterator.html">Lab 4.3 ConcactIterator</a>中对<code>TwoMergeIterator</code>的介绍, <code>TwoMergeIterator</code>就是整合两个优先级不同的迭代器, 生成一个新的迭代器, 该迭代器优先级为两个迭代器中优先级较高的那个。</p>
<p>其余逻辑上一节<a href="lab4/./lab4.3-ConcactIterator.html">Lab 4.3 ConcactIterator</a>已经有所介绍, 这里不再赘述, 直接开始看头文件定义:</p>
<pre><code class="language-cpp">class TwoMergeIterator : public BaseIterator {
private:
  std::shared_ptr&lt;BaseIterator&gt; it_a;
  std::shared_ptr&lt;BaseIterator&gt; it_b;
  bool choose_a = false;
  mutable std::shared_ptr&lt;value_type&gt; current; // 用于存储当前元素
  uint64_t max_tranc_id_ = 0;
};
</code></pre>
<p>这里也很简单, 就只是存储两个迭代器 的指针<code>it_a</code>和<code>it_b</code>, 以及一个<code>choose_a</code>用于标记当前是否选择了优先级较高的<code>it_a</code>迭代器是, 一个<code>current</code>用于缓存当前迭代器位置的键值对, 一个<code>max_tranc_id_</code>用于记录当前可见事务的最大<code>id</code>。</p>
<h1 id="2-代码实现-6"><a class="header" href="#2-代码实现-6">2 代码实现</a></h1>
<h2 id="21-运算符重载"><a class="header" href="#21-运算符重载">2.1 运算符重载</a></h2>
<pre><code class="language-cpp">BaseIterator &amp;TwoMergeIterator::operator++() {
  // TODO: Lab 4.4: 实现 ++ 重载
}

bool TwoMergeIterator::operator==(const BaseIterator &amp;other) const {
  // TODO: Lab 4.4: 实现 == 重载
  return false;
}

bool TwoMergeIterator::operator!=(const BaseIterator &amp;other) const {
  // TODO: Lab 4.4: 实现 != 重载
  return false;
}

BaseIterator::value_type TwoMergeIterator::operator*() const {
  // TODO: Lab 4.4: 实现 * 重载
  return {};
}

TwoMergeIterator::pointer TwoMergeIterator::operator-&gt;() const {
  // TODO: Lab 4.4: 实现 -&gt; 重载
  return nullptr;
}
</code></pre>
<p>老套路, 你需要先实现迭代器的各个运算符重载函数, 不过建议你看看下面的辅助函数, 你在实现这些运算符重载函数的时候会用到这些辅助函数, 不妨一起实现了。</p>
<h2 id="22-辅助函数"><a class="header" href="#22-辅助函数">2.2 辅助函数</a></h2>
<p>首先<code>choose_it_a</code>判断当前解引用应该使用哪个迭代器:</p>
<pre><code class="language-cpp">bool TwoMergeIterator::choose_it_a() {
  // TODO: Lab 4.4: 实现选择迭代器的逻辑
  return false;
}
</code></pre>
<p>然后是更新当前缓存值的函数:</p>
<pre><code class="language-cpp">void TwoMergeIterator::update_current() const {
  // TODO: Lab 4.4: 实现更新缓存键值对的辅助函数
}
</code></pre>
<p>这个函数你可能会在之前的自增运算符和<code>-&gt;</code>运算符重载中调用</p>
<p>最后这个函数是根据事务可见性进行滤除的辅助函数, 当前不需要实现, 只是标记下便于你之后的<code>Lab</code>来更新:</p>
<pre><code class="language-cpp">void TwoMergeIterator::skip_by_tranc_id() {
  // TODO: Lab xx
}
</code></pre>
<h1 id="3-测试-7"><a class="header" href="#3-测试-7">3 测试</a></h1>
<p>本小节没有测试, 你完成后续迭代器和涉及迭代器的查询操作后有统一的单元测试。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-45-compact"><a class="header" href="#lab-45-compact">Lab 4.5 Compact</a></h1>
<h1 id="1-概述-11"><a class="header" href="#1-概述-11">1 概述</a></h1>
<p>完成了<code>ConcactIterator</code>和<code>TwoMergeIterator</code>, 我们就已经可以开始实现我们的<code>Compact</code>流程了。</p>
<p>在LSM（Log-Structured Merge）树中，数据最初写入一个称为 <strong>memtable</strong> 的内存结构。一旦 memtable 达到一定大小限制，其内容会被刷写到磁盘上作为 SSTable（Sorted String Table）。随着时间的推移，可能会在 LSM 树的不同层级积累多个 SSTable。这些 SSTable 可能会导致以下问题：</p>
<ul>
<li><strong>读放大</strong>：查询一个键时，系统可能需要搜索多个不同层级的 SSTable。这会增加 I/O 操作次数，从而降低读取性能。</li>
<li><strong>写放大</strong>：频繁的写操作生成新的 SSTable，最终需要与现有 SSTable 合并。如果没有压缩，这会导致过多的磁盘写入。</li>
<li><strong>空间放大</strong>：被删除或覆盖的键可能仍然存在于旧的 SSTable 中，直到它们通过压缩被清除。这浪费了磁盘空间。</li>
</ul>
<p>为了解决这些问题，需要进行 <strong>压缩（compaction）</strong>。压缩将较小的 SSTable 合并成较大的 SSTable，移除过时的数据（如已删除或覆盖的键），并平衡各层级之间的数据分布。</p>
<p>由于<code>Compact</code>的策略对<code>LSM Tree</code>的性能有着绝对影响, 因此实际工业界的<code>Compact</code>策略非常多, 我们这一章先介绍不同的<code>Compact</code>策略, 再来实现一种最简单的<code>Compact</code>策略</p>
<h1 id="2-经典的sst压缩方案"><a class="header" href="#2-经典的sst压缩方案">2. 经典的SST压缩方案</a></h1>
<p>这里先介绍一些经典的SST压缩方案。</p>
<h2 id="21-基于大小的分层压缩size-tiered-compaction"><a class="header" href="#21-基于大小的分层压缩size-tiered-compaction">2.1 基于大小的分层压缩（Size-Tiered Compaction）</a></h2>
<p>这种方案按大小和层级对 SSTable 进行分组。每一层包含大致相同大小的 SSTable。当某一层的 SSTable 数量超过阈值时，它们会被合并成一个或多个 SSTable 并移动到下一层。</p>
<ul>
<li>
<p><strong>流程</strong>：</p>
<ol>
<li>将 Level L 的 SSTable 合并成一个或多个 SSTable 并移动到 Level L+1。</li>
<li>如果必要，递归执行此过程。</li>
</ol>
</li>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li>实现简单。</li>
<li>高效处理高写入吞吐量。</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li>可能导致显著的读放大，因为单次查询可能需要扫描多个层级。</li>
</ul>
</li>
<li>
<p><strong>示意图</strong>：</p>
<pre><code class="language-text">Level 0: [SST1] [SST2] [SST3]
Level 1: [SST4] [SST5]
Level 2: [SST6]

压缩后：
Level 0: []
Level 1: [Merged(SST1,SST2,SST3)]
Level 2: [SST6]
</code></pre>
</li>
</ul>
<h2 id="22-分层压缩leveled-compaction"><a class="header" href="#22-分层压缩leveled-compaction">2.2 分层压缩（Leveled Compaction）</a></h2>
<p>这种方案将 SSTable 分布在不同的层级，确保每个层级包含固定数量的数据。较低层级的数据以小块形式逐步移动到较高层级。</p>
<ul>
<li>
<p><strong>流程</strong>：</p>
<ol>
<li>将 Level L 的 SSTable 按键范围拆分成更小的部分，并与 Level L+1 中重叠的 SSTable 合并。</li>
<li>每次压缩只影响 Level L+1 中的一小部分 SSTable。</li>
</ol>
</li>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li>相比基于大小的分层压缩，减少了读放大。</li>
<li>确保每个层级的键范围不重叠。</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li>实现复杂度更高。</li>
<li>频繁的小规模合并导致较高的写放大。</li>
</ul>
</li>
<li>
<p><strong>示意图</strong>：</p>
<pre><code class="language-text">Level 0: [SST1] [SST2] [SST3]
Level 1: [RangeA] [RangeB] [RangeC]
Level 2: [RangeD] [RangeE]

压缩后:
Level 0: []
Level 1: [Merged(SST1,RangeA)] [Merged(SST2,RangeB)] [Merged(SST3,RangeC)]
Level 2: [RangeD] [RangeE]
</code></pre>
</li>
</ul>
<h2 id="23-混合压缩hybrid-compacti23"><a class="header" href="#23-混合压缩hybrid-compacti23">2.3 混合压缩（Hybrid Compacti2.3）</a></h2>
<p>一些系统结合了基于大小的分层压缩和分层压缩的优点。例如，前几层使用基于大小的分层压缩，而较深层级切换到分层压缩。</p>
<ul>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li>在读放大和写放大之间取得平衡。</li>
<li>根据工作负载特性提供灵活性。</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li>管理多种压缩策略增加了复杂性。</li>
</ul>
</li>
</ul>
<h1 id="3-本项目-sst-compact-设计"><a class="header" href="#3-本项目-sst-compact-设计">3 本项目 SST Compact 设计</a></h1>
<p>本项目的<code>compact</code>机制采用了一种混合方法，主要在第0层使用基于大小的分层压缩，而在更高层则转向分层压缩。以下是详细的设计说明</p>
<h2 id="31-触发压缩的时机"><a class="header" href="#31-触发压缩的时机">3.1 触发压缩的时机</a></h2>
<ul>
<li><strong>Level 0</strong>：如果 Level 0 的 SSTable 数量超过一个阈值 <code>LSM_SST_LEVEL_RATIO</code>，则触发全量压缩，将所有 Level 0 的 SSTable 移动到 Level 1。</li>
<li><strong>更高层</strong>：如果某一层的 SSTable 数量超过 <code>LSM_SST_LEVEL_RATIO</code>，系统会递归检查下一层是否也需要压缩，然后继续执行。</li>
</ul>
<blockquote>
<p><code>LSM_SST_LEVEL_RATIO</code>定义在<code>config.toml</code>中</p>
</blockquote>
<p>这里重点解释一下 <code>LSM_SST_LEVEL_RATIO</code>的含义, 它的含义是相邻两层的单个<code>SST</code>容量之比, 同时也是单层<code>SST</code>数量的阈值。这里我为了方便压缩触发的条件判断的便捷性, 规定每一个<code>Level</code>的<code>SST</code>数量阈值恒定。例如， 每层<code>SST</code>数量超过16时就需要进行<code>compact</code>, 这一层16个<code>SST</code>被合并为下一层的单个<code>SST</code>, 因此这个单个<code>SST</code>的容量是上一个<code>Level</code>中单个<code>SST</code>的容量的16倍。这个案例中, <code>LSM_SST_LEVEL_RATIO</code>就是16。</p>
<h2 id="32-递归压缩"><a class="header" href="#32-递归压缩">3.2 递归压缩</a></h2>
<ol>
<li>
<p><strong>确定源层和目标层</strong>：</p>
<ul>
<li>确定源层 (<code>src_level</code>) 和目标层 (<code>src_level + 1</code>)。</li>
<li>获取这两层的 SSTable ID。</li>
</ul>
</li>
<li>
<p><strong>判断是否进行递归压缩</strong></p>
<ul>
<li>由于<code>src_level</code>层是触发了这一次<code>compact</code>操作, 因此其<code>SST</code>数量肯定大于等于<code>LSM_SST_LEVEL_RATIO</code></li>
<li>但还需要判断目标层(<code>src_level + 1</code>)的<code>SST</code>数量是否大于等于<code>LSM_SST_LEVEL_RATIO</code>。如果时, 则需要先将<code>src_level + 1</code>层的<code>SST</code>全部压缩到<code>src_level + 2</code>层</li>
<li>上述的判断递归地在更高的<code>Level</code>中进行</li>
</ul>
</li>
<li>
<p><strong>合并SSTable</strong>：</p>
<ul>
<li>对于 <code>Level 0</code>，由于其不同<code>SST</code>中的<code>key</code>有重叠, 需要使用 <code>full_l0_l1_compact</code> 处理键范围重叠的问题</li>
<li>对于更高层， 其<code>key</code>本来就是从小大大排布的, 使用 <code>full_common_compact</code> 合并不重叠键范围的 <code>SSTable</code>。</li>
</ul>
</li>
<li>
<p><strong>生成新SSTable</strong>：</p>
<ul>
<li>使用 <code>gen_sst_from_iter</code> 从合并后的迭代器结果生成新的 SSTable。</li>
<li>确保新 SSTable 的大小符合 <code>get_sst_size</code> 定义的限制。</li>
</ul>
</li>
<li>
<p><strong>更新元数据</strong>：</p>
<ul>
<li>删除旧的 SSTable（从内存和磁盘中移除）。</li>
<li>将新的 SSTable 添加到适当的目标层。</li>
<li>更新 <code>level_sst_ids</code> 并对其进行排序以便高效访问。</li>
</ul>
</li>
</ol>
<blockquote>
<p>这里的<code>full_l0_l1_compact</code>和<code>full_common_compact</code> 会在后文中介绍</p>
</blockquote>
<p><strong>关键特性</strong></p>
<ul>
<li><strong>事务处理</strong>：在压缩过程中，确保只将可见记录（基于事务ID）包含在新的 SSTable 中。</li>
<li><strong>并发控制</strong>：使用锁（<code>std::shared_mutex</code>）防止在访问共享资源（如 <code>ssts_mtx</code>）时发生竞争条件。</li>
<li><strong>高效迭代</strong>：利用迭代器（<code>TwoMergeIterator</code>、<code>HeapIterator</code>、<code>ConcactIterator</code>）高效遍历和合并来自多个 SSTable 的数据。</li>
</ul>
<p><strong>示例流程</strong></p>
<p>假设初始状态如下：</p>
<ul>
<li>
<p><strong>压缩前</strong>：</p>
<pre><code class="language-text">Level 0: [SST1] [SST2] [SST3]
Level 1: [SST4] [SST5]
Level 2: [SST6]
</code></pre>
</li>
<li>
<p><strong>触发条件</strong>：Level 0 有三个 SSTable，超过了阈值（<code>LSM_SST_LEVEL_RATIO = 2</code>）。</p>
</li>
<li>
<p><strong>压缩过程</strong>：</p>
<ol>
<li>合并 <code>[SST1]</code>、<code>[SST2]</code> 和 <code>[SST3]</code> 成为一个迭代器。</li>
<li>将该迭代器的结果与 <code>[SST4]</code> 和 <code>[SST5]</code> 从 Level 1 中合并。</li>
<li>生成新的 SSTable 并将其分配到 Level 1。</li>
</ol>
</li>
<li>
<p><strong>压缩后</strong>：</p>
<pre><code class="language-text">Level 0: []
Level 1: [NewSST1] [NewSST2]
Level 2: [SST6]
</code></pre>
</li>
</ul>
<blockquote>
<p>TODO: 后续版本应该在此处添加一张流程图</p>
</blockquote>
<h1 id="4-本实验-compact-策略的优势和劣势"><a class="header" href="#4-本实验-compact-策略的优势和劣势">4 本实验 Compact 策略的优势和劣势</a></h1>
<p>本实验的<code>Compact</code>策略属于 <code>Leveled Compaction</code> (分层合并) 的一种变体。这种<code>全层合并</code>的<code>Leveled Compaction</code>策略，与其他主流策略的对比如下</p>
<blockquote>
<p><strong>Size-Tiered Compaction (STCS - 基于大小分层的合并)</strong></p>
<p><strong>Classic Leveled Compaction (经典的、更细粒度的分层合并，如LevelDB/RocksDB采用的策略)</strong></p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">特性 (Aspect)</th><th style="text-align: left">本实验策略 (Leveled - 全层合并)</th><th style="text-align: left">Size-Tiered Compaction (STCS)</th><th style="text-align: left">经典Leveled Compaction (细粒度合并)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>读放大 (Read Amplification)</strong></td><td style="text-align: left">L0层: 中等 (需查找多个SSTable)<br>L1+层: <strong>低</strong> (由于SSTable不重叠且有序，每层理论上最多查找一个SSTable)</td><td style="text-align: left"><strong>高</strong> (通常需要在多个层级(Tier)的多个SSTable中查找，因为不同SSTable间的键范围可能大量重叠)</td><td style="text-align: left">L0层: 中等 (需查找多个SSTable)<br>L1+层: <strong>低</strong> (与本实验的策略类似，L1+层SSTable不重叠)</td></tr>
<tr><td style="text-align: left"><strong>写放大 (Write Amplification)</strong></td><td style="text-align: left"><strong>非常高</strong> (合并Level_N和Level_{N+1}时，两个层级的<em>全部</em>数据都会被读取和重写，即使Level_{N+1}中大部分是“冷”数据)</td><td style="text-align: left"><strong>低</strong> (数据在其生命周期中被重写的次数相对较少，通常是合并固定数量的SSTable)</td><td style="text-align: left"><strong>中等</strong> (比STCS高，但显著低于“全层合并”。仅合并Level_N中少量被选中的SSTable及其在Level_{N+1}中的键范围重叠部分)</td></tr>
<tr><td style="text-align: left"><strong>空间放大 (Space Amplification)</strong></td><td style="text-align: left"><strong>低</strong> (合并过程频繁且较为彻底地重写数据，有利于快速回收无效数据和墓碑(Tombstone)占用的空间)</td><td style="text-align: left"><strong>高</strong> (旧版本数据和墓碑可能长时间存在于未被合并的SSTable中，导致总体磁盘占用较大，最坏情况一个键的多个版本都存在)</td><td style="text-align: left"><strong>低</strong> (与“全层合并”类似，能较好控制空间。因单次合并范围较小，整体回收速度可能略慢于全层合并，但通常有严格的层级大小限制)</td></tr>
<tr><td style="text-align: left"><strong>合并I/O成本 (Compaction I/O Cost)</strong></td><td style="text-align: left"><strong>高</strong> (单次合并涉及的数据量通常很大，导致瞬时I/O和CPU压力显著，可能引发性能抖动或“合并风暴”)</td><td style="text-align: left"><strong>中低</strong> (通常合并固定数量（例如N个）的SSTable，单次合并成本相对可控，但合并操作可能更频繁)</td><td style="text-align: left"><strong>中等</strong> (单次合并的数据量介于STCS和“全层合并”之间，致力于平滑I/O负载)</td></tr>
<tr><td style="text-align: left"><strong>实现复杂度</strong></td><td style="text-align: left"><strong>中等</strong> (比STCS复杂，因为需要维护层级结构和SSTable元数据；但比经典的细粒度Leveled Compaction简单，因为合并整个层级的逻辑较直接)</td><td style="text-align: left"><strong>低</strong> (逻辑相对简单，主要是基于SSTable的大小和数量触发合并，易于实现和维护)</td><td style="text-align: left"><strong>高</strong> (需要复杂的SSTable挑选逻辑(picking logic)来决定哪些SSTable参与合并，键范围管理、并发控制以及避免写暂停等机制都较复杂)</td></tr>
<tr><td style="text-align: left"><strong>墓碑/旧数据清理效率</strong></td><td style="text-align: left"><strong>高</strong> (由于整个层级的数据会定期参与合并过程，墓碑和旧版本数据能得到较快和较彻底的清理)</td><td style="text-align: left"><strong>低</strong> (清理效率依赖于包含墓碑或旧数据的SSTable何时被选中参与合并，可能存在较长延迟)</td><td style="text-align: left"><strong>中高</strong> (数据也定期参与合并过程，但由于单次合并涉及的数据范围小于全层合并，整体清理速度和彻底性可能稍逊于全层合并，但仍属高效)</td></tr>
<tr><td style="text-align: left"><strong>查询性能稳定性/可预测性</strong></td><td style="text-align: left">L1+层: <strong>好</strong> (查询路径短且固定，性能稳定)<br>L0层: 一般 (受SSTable数量影响)</td><td style="text-align: left"><strong>差</strong> (查询性能波动较大，取决于数据具体分布在哪些SSTable以及需要检查的SSTable数量)</td><td style="text-align: left">L1+层: <strong>好</strong> (查询路径短且固定，性能稳定)<br>L0层: 一般 (受SSTable数量影响)</td></tr>
</tbody></table>
</div>
<h1 id="5-本实验的代码实现"><a class="header" href="#5-本实验的代码实现">5 本实验的代码实现</a></h1>
<p>在完成之前的理论学习后, 你可以开始实现本实验的代码了</p>
<p>本小节你需要更改的代码文件为:</p>
<ul>
<li><code>src/lsm/engine.cpp</code></li>
<li><code>include/lsm/engine.h</code> (Optional)</li>
</ul>
<h2 id="51-新sst的构造"><a class="header" href="#51-新sst的构造">5.1 新<code>SST</code>的构造</a></h2>
<p><code>gen_sst_from_iter</code>从一个迭代器中构造新的<code>SST</code>, 新的<code>SST</code>的容量上限为<code>target_sst_size</code>, 新的<code>SST</code>的层级为<code>target_level</code>。 也就是说, 假设迭代器中所有键值对的容量是<code>128 MB</code>, 而<code>target_sst_size = 32MB</code>, 那么你需要构造4个<code>SST</code>。</p>
<pre><code class="language-cpp">std::vector&lt;std::shared_ptr&lt;SST&gt;&gt;
LSMEngine::gen_sst_from_iter(BaseIterator &amp;iter, size_t target_sst_size,
                             size_t target_level) {
  // TODO: Lab 4.5 实现从迭代器构造新的 SST

  return {};
}
</code></pre>
<p>这里, <code>SST</code>的命名规则参照<code>get_sst_path</code>:</p>
<pre><code class="language-cpp">std::string LSMEngine::get_sst_path(size_t sst_id, size_t target_level) {
  // sst的文件路径格式为: data_dir/sst_&lt;sst_id&gt;，sst_id格式化为32位数字
  std::stringstream ss;
  ss &lt;&lt; data_dir &lt;&lt; "/sst_" &lt;&lt; std::setfill('0') &lt;&lt; std::setw(32) &lt;&lt; sst_id
     &lt;&lt; '.' &lt;&lt; target_level;
  return ss.str();
}
</code></pre>
<blockquote>
<p><code>sst</code>的<code>id</code>的分配可以简单地按照如下操作获取:</p>
<pre><code class="language-cpp">size_t sst_id = next_sst_id++
</code></pre>
</blockquote>
<h2 id="52-full_l0_l1_compact"><a class="header" href="#52-full_l0_l1_compact">5.2 full_l0_l1_compact</a></h2>
<p><code>full_l0_l1_compact</code>负责将<code>L0</code>层和<code>L1</code>层的<code>SST</code>合并到<code>L1</code>层, 因为<code>L0</code>层的<code>SST</code>之间是不排序且存在重叠的, 因此你需要结合之前实现的迭代器对其进行排序和去重, 并和<code>L1</code>迭代器整合成新的迭代器, 出入你刚刚实现的<code>gen_sst_from_iter</code>函数, 完成新的<code>SST</code>的构造:</p>
<pre><code class="language-cpp">std::vector&lt;std::shared_ptr&lt;SST&gt;&gt;
LSMEngine::full_l0_l1_compact(std::vector&lt;size_t&gt; &amp;l0_ids,
                              std::vector&lt;size_t&gt; &amp;l1_ids) {
  // TODO: Lab 4.5 负责完成 l0 和 l1 的 full compact
  return {};
}
</code></pre>
<blockquote>
<p>根据我们的<code>Compact</code>策略设计, <code>Ln</code>层的<code>SST</code>容量应该是<code>Ln-1</code>层的<code>LSM_SST_LEVEL_RATIO</code>倍, 作者已经提供了<code>get_sst_size</code>帮助你计算任意一层<code>SST</code>的容量</p>
</blockquote>
<h2 id="52-full_common_compact"><a class="header" href="#52-full_common_compact">5.2 full_common_compact</a></h2>
<p><code>full_common_compact</code>负责其他相邻<code>Level</code>的<code>SST</code>合并, 你需要参考<code>full_l0_l1_compact</code>的实现, 完成其他相邻<code>Level</code>的<code>SST</code>合并。这里应该会更简单，因为这里相邻的两个<code>Level</code>的<code>SST</code>之间是排序且不重叠的, 因此单个<code>Level</code>的迭代器都是相同的类型:</p>
<pre><code class="language-cpp">std::vector&lt;std::shared_ptr&lt;SST&gt;&gt;
LSMEngine::full_common_compact(std::vector&lt;size_t&gt; &amp;lx_ids,
                               std::vector&lt;size_t&gt; &amp;ly_ids, size_t level_y) {
  // TODO: Lab 4.5 负责完成其他相邻 level 的 full compact

  return {};
}
</code></pre>
<h1 id="53-full_compact"><a class="header" href="#53-full_compact">5.3 full_compact</a></h1>
<p><code>full_compact</code>负责整个<code>Compact</code>流程, 你需要根据<code>Compact</code>策略设计, 完成这个函数。另外, 由于每次<code>compact</code>会导致目标<code>Level</code>的<code>SST</code>数量增加, 因此这个<code>compact</code>流程可能会哦递归地进行, 你需要在<code>full_compact</code>中控制这个递归过程。也就是说，你需要按照我们之前描述的策略控制之前实现的<code>full_common_compact</code>和<code>full_l0_l1_compact</code>的调用:</p>
<pre><code class="language-cpp">void LSMEngine::full_compact(size_t src_level) {
  // TODO: Lab 4.5 负责完成整个 full compact
  // ? 你可能需要控制`Compact`流程需要递归地进行
}
</code></pre>
<details>
<summary>点击这里展开/折叠提示 (建议你先尝试自己完成)</summary>
<p>这里给出作者对这个函数的的实现思路:</p>
<p><code>LSMEngine::full_compact</code> 函数的目标是将指定层级 <code>src_level</code> 的所有 SSTable 压缩到下一层级 <code>src_level + 1</code>，并通过合并和优化减少冗余数据，提升读写性能。其步骤为:</p>
<p><strong>a. 递归检查下一层是否需要压缩</strong></p>
<ul>
<li>在对当前层级（<code>src_level</code>）进行全量压缩之前，先检查下一层级（<code>src_level + 1</code>）是否也需要进行全量压缩。</li>
<li>如果 <code>src_level + 1</code> 层的 SSTable 数量超过阈值（<code>LSM_SST_LEVEL_RATIO</code>），则递归调用 <code>full_compact(src_level + 1)</code> 对下一层进行压缩。</li>
<li>这种递归机制确保了在压缩当前层之前，目标层已经处于优化状态。</li>
</ul>
<p><strong>b. 获取源层级和目标层级的 SSTable ID</strong></p>
<ul>
<li>从 <code>level_sst_ids[src_level]</code> 和 <code>level_sst_ids[src_level + 1]</code> 中分别获取当前层级和目标层级的所有 SSTable ID。</li>
<li>将这些 ID 转换为两个向量：<code>lx_ids</code>（源层级）和 <code>ly_ids</code>（目标层级），便于后续处理。</li>
</ul>
<p><strong>c. 根据层级选择不同的压缩方式</strong></p>
<ul>
<li>根据 <code>src_level</code> 是否为 Level 0，选择不同的压缩方法：
<ul>
<li><strong>Level 0</strong>：由于 Level 0 的 SSTable 可能存在键范围重叠，调用 <code>full_l0_l1_compact(lx_ids, ly_ids)</code> 处理。</li>
<li><strong>其他层级</strong>：调用 <code>full_common_compact(lx_ids, ly_ids, src_level + 1)</code> 处理，这些层级的 SSTable 键范围不重叠。</li>
</ul>
</li>
</ul>
<p><strong>d. 移除旧的 SSTable</strong></p>
<ul>
<li>压缩完成后，删除源层级和目标层级中所有旧的 SSTable：
<ul>
<li>调用 <code>del_sst()</code> 方法释放磁盘资源。</li>
<li>从 <code>ssts</code> 映射中移除这些 SSTable。</li>
</ul>
</li>
<li>清空 <code>level_sst_ids[src_level]</code> 和 <code>level_sst_ids[src_level + 1]</code>，为新生成的 SSTable 准备空间。</li>
</ul>
<p><strong>e. 更新最大层级</strong></p>
<ul>
<li>更新 <code>cur_max_level</code>，确保其始终表示当前 LSM 树中的最大层级。</li>
</ul>
<p><strong>f. 添加新的 SSTable</strong></p>
<ul>
<li>将新生成的 SSTable 添加到目标层级（<code>src_level + 1</code>）：
<ul>
<li>将新 SSTable 的 ID 插入到 <code>level_sst_ids[src_level + 1]</code>。</li>
<li>将新 SSTable 本身插入到 <code>ssts</code> 映射中。</li>
</ul>
</li>
<li>对 <code>level_sst_ids[src_level + 1]</code> 进行排序，确保 SSTable 按顺序存储，便于高效访问。</li>
</ul>
</details>
<h2 id="54-compact-的触发时机"><a class="header" href="#54-compact-的触发时机">5.4 Compact 的触发时机</a></h2>
<p>最后, <code>full_compact</code>的调用肯定需要有一个触发时机, 你可以选择在<code>put</code>时候惰性地检查每层<code>Level</code>的<code>SST</code>数量是否达到阈值, 也可以单独创建一个线程进行轮训检查, 具体实现方案取决于你自己, 因此这里就没有对指定的函数进行挖空让你实现了。</p>
<h1 id="6-测试-1"><a class="header" href="#6-测试-1">6 测试</a></h1>
<p>这一章的测试有一点特别, 由于我们常规测试中为了速度考虑, 不会有大量的键值对插入行为。而测试<code>Compact</code>, 需要数据量较大时, 才会触发多个<code>SST</code>文件的持久化以及超出数量后的<code>compact</code>操作, 因此这里的建议是, 将配置文件中单个<code>L0 SST</code>的大小(也就是单个<code>Skiplist</code>的大小)调小(其他相应参数也一并调小), 然后运行<code>Persistence</code>函数。</p>
<p>例如我如下调整配置：</p>
<pre><code class="language-toml">[lsm.core]
# Memory table size limit (64MB)
# LSM_TOL_MEM_SIZE_LIMIT = 67108864 # Calculated from 64 * 1024 * 1024 # 原来的 MemTable 容量限制
LSM_TOL_MEM_SIZE_LIMIT = 65536 # Calculated from 64 * 1024 * 1024
# Per-memory table size limit (4MB)
# LSM_PER_MEM_SIZE_LIMIT = 4194304 # Calculated from 4 * 1024 * 1024 # 原来的单个 Skiplist 容量限制
LSM_PER_MEM_SIZE_LIMIT = 8192 # Calculated from 4 * 1024 * 1024
# Block size (32KB)
# LSM_BLOCK_SIZE = 32768 # Calculated from 32 * 1024 # # 原来的单个 Block 容量限制
LSM_BLOCK_SIZE = 1024 # Calculated from 32 * 1024
# SST level size ratio
LSM_SST_LEVEL_RATIO = 4
</code></pre>
<blockquote>
<p>需要注意的是, 单元测试读取配置文件默认是当前目录下的<code>config.toml</code>因此你需要将修改后的配置文件复制到编译单元测试的目录, 一般是:</p>
<pre><code class="language-bash">./build/linux/x86_64/release # release 版本
./build/linux/x86_64/debug # debug 版本
</code></pre>
</blockquote>
<p>你只需要关注这个测例:</p>
<pre><code class="language-cpp">// test/test_lsm.cpp
TEST_F(LSMTest, Persistence) {
    // ...
}
</code></pre>
<p>通过这个测试即可</p>
<blockquote>
<p>TODO: 后期实验项目书应进行优化, 不应该让学员手动来控制这一过程</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-46-level_iterator"><a class="header" href="#lab-46-level_iterator">Lab 4.6 Level_Iterator</a></h1>
<h1 id="1-概述-12"><a class="header" href="#1-概述-12">1 概述</a></h1>
<p>为什么要将<code>Level_Iterator</code>放在<code>Compact</code>之后呢? 当然是因为<code>Compact</code>之后, 我们才有了<code>Level</code>的概念, 才能对某个<code>Level</code>的所有键值对进行迭代.</p>
<p><code>Level_Iterator</code>的实现其实非常简单了, 与<code>TwoMergeIterator</code>非常类似, 只不过整合的迭代器数量是不定的, 用一个<code>vector</code>存储, 我们先简单看看定义:</p>
<pre><code class="language-cpp">class Level_Iterator : public BaseIterator {
  // ...

private:
  std::shared_ptr&lt;LSMEngine&gt; engine_;
  std::vector&lt;std::shared_ptr&lt;BaseIterator&gt;&gt; iter_vec;
  size_t cur_idx_;
  uint64_t max_tranc_id_;
  mutable std::optional&lt;value_type&gt; cached_value; // 缓存当前值
  std::shared_lock&lt;std::shared_mutex&gt; rlock_;
};
</code></pre>
<p>这里同样是有上层<code>LSMEngine</code>的智能指针<code>engine_</code>, <code>iter_vec</code>按照索引顺序存储不同优先级的迭代器, 这里的情形就是不同的<code>Level</code>的层间迭代器(<code>ConcactIterator</code>)</p>
<blockquote>
<p>当然, 也不一定是<code>ConcactIterator</code>, 只要多个迭代器存在优先级的概念, 都可以用<code>ConcactIterator</code>进行整合。例如我们之前由于<code>Level 0</code>的不同<code>SST</code>存在重叠且为排序, 这种情况也可以用<code>ConcactIterator</code>进行整合, 因为<code>id</code>更大的<code>SST</code>优先级更高, 需要先遍历。同时也看出我们迭代器设计存在强大的复用性，因为这里的<code>BaseIterator</code>是抽象类，只要实现了<code>BaseIterator</code>的接口，都可以作为<code>iter_vec</code>的元素, 从而实现整合逻辑的复用。</p>
</blockquote>
<h1 id="2-代码实现-7"><a class="header" href="#2-代码实现-7">2 代码实现</a></h1>
<p>相比上一章, 这一章轻松不少, 只需要实现几个简单的重载和构造函数初始化流程即可</p>
<p>本小节你需要修改的代码文件:</p>
<ul>
<li><code>src/lsm/level_iterator.cpp</code></li>
<li><code>include/lsm/level_iterator.h</code> (Optional)</li>
</ul>
<h2 id="21-迭代器初始化"><a class="header" href="#21-迭代器初始化">2.1 迭代器初始化</a></h2>
<pre><code class="language-cpp">Level_Iterator::Level_Iterator(std::shared_ptr&lt;LSMEngine&gt; engine,
                               uint64_t max_tranc_id)
    : engine_(engine), max_tranc_id_(max_tranc_id), rlock_(engine_-&gt;ssts_mtx) {
  // TODO: Lab 4.6 Level_Iterator 初始化
}
</code></pre>
<p>这里的初始化流程就是提取每一个<code>Level</code>的迭代器然后放入<code>iter_vec</code>中, 不过同样的, <code>Level 0</code>的<code>SST</code>由于存在重叠且未排序, 需要进行额外处理。</p>
<blockquote>
<p>思考: 初始化<code>iter_vec</code>后, 是否需要进行一些额外的判断呢?</p>
</blockquote>
<h2 id="22-运算符重载-1"><a class="header" href="#22-运算符重载-1">2.2 运算符重载</a></h2>
<p>接下来就是我们的传统艺能————运算符函数重载了:</p>
<pre><code class="language-cpp">BaseIterator &amp;Level_Iterator::operator++() {
  // TODO: Lab 4.6 ++ 重载
  return *this;
}

bool Level_Iterator::operator==(const BaseIterator &amp;other) const {
  // TODO: Lab 4.6 == 重载
  return false;
}

bool Level_Iterator::operator!=(const BaseIterator &amp;other) const {
  // TODO: Lab 4.6 != 重载
  return false;
}

BaseIterator::value_type Level_Iterator::operator*() const {
  // TODO: Lab 4.6 * 重载
  return {};
}

BaseIterator::pointer Level_Iterator::operator-&gt;() const {
  // TODO: Lab 4.6 -&gt; 重载
  return nullptr;
}
</code></pre>
<p>类似地, 你可以先看看接下来要实现的一些辅助功能函数, 也许你会在实现这些运算符重载时需要用到它们。</p>
<h2 id="23-辅助函数-1"><a class="header" href="#23-辅助函数-1">2.3 辅助函数</a></h2>
<pre><code class="language-cpp">std::pair&lt;size_t, std::string&gt; Level_Iterator::get_min_key_idx() const {
  // TODO: Lab 4.6 获取当前 key 最小的迭代器在 iter_vec 中的索引和具体的 key
  return {};
}

void Level_Iterator::skip_key(const std::string &amp;key) {
  // TODO: Lab 4.6 跳过 key 相同的部分(即被当前激活的迭代器覆盖的写入记录)
}

void Level_Iterator::update_current() const {
  // TODO: Lab 4.6 更新当前值 cached_value
  // ? 实现 -&gt; 时你也许会用到 cached_value
}
</code></pre>
<h1 id="3-测试-8"><a class="header" href="#3-测试-8">3 测试</a></h1>
<p>次小节的测试将在实现下一小节 <a href="lab4/./lab4.7-Complicated-Query.html">Lab 4.7 复杂查询</a> 后统一进行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-47-复杂查询"><a class="header" href="#lab-47-复杂查询">Lab 4.7 复杂查询</a></h1>
<h1 id="1-概述-13"><a class="header" href="#1-概述-13">1 概述</a></h1>
<p>其实也就是我们每个组件实现过程中最后实现的范围查询, 只是我们之前简单的<code>begin</code>和<code>end</code>也是需要实现<code>Level_Iterator</code>, 因此这里就统称其为<code>复杂查询</code>了。</p>
<p>本小节你需要更改的代码文件为:</p>
<ul>
<li><code>src/lsm/engine.cpp</code></li>
<li><code>include/lsm/engine.h</code> (Optional)</li>
</ul>
<h2 id="2-全局迭代器"><a class="header" href="#2-全局迭代器">2 全局迭代器</a></h2>
<p>现在你已经有了各种各样的迭代器，那么<code>LSMEngine</code>的<code>begin/end</code>自然也不在话下了:</p>
<pre><code class="language-cpp">Level_Iterator LSMEngine::begin(uint64_t tranc_id) {
  // TODO: Lab 4.7
  throw std::runtime_error("Not implemented");
}

Level_Iterator LSMEngine::end() {
  // TODO: Lab 4.7
  throw std::runtime_error("Not implemented");
}
</code></pre>
<p>这里只需要简单地调用<code>Level_Iterator</code>的构造函数即可</p>
<h2 id="3-范围查询"><a class="header" href="#3-范围查询">3 范围查询</a></h2>
<p>最后, 比全局迭代器稍微复杂的是谓词查询:</p>
<pre><code class="language-cpp">std::optional&lt;std::pair&lt;TwoMergeIterator, TwoMergeIterator&gt;&gt;
LSMEngine::lsm_iters_monotony_predicate(
    uint64_t tranc_id, std::function&lt;int(const std::string &amp;)&gt; predicate) {
  // TODO: Lab 4.7 谓词查询
  return std::nullopt;
}
</code></pre>
<p>这里的复杂点在于, 这是一个顶层的范围查询, 你需要完成的是所有组件迭代器的组合、排序和滤除。你需要灵活地运用我们已经实现的各种迭代器, 完成这个复杂的查询。</p>
<blockquote>
<p>这个函数你应该能体会到我们实验代码涉及中迭代器复用的精妙之处</p>
</blockquote>
<h1 id="4-测试-3"><a class="header" href="#4-测试-3">4 测试</a></h1>
<p>现在你应该能通过<code>test_lsm</code>的大部分测试了:</p>
<pre><code class="language-bash">✗ xmake
[100%]: build ok, spent 1.389s
✗ xmake run test_lsm
[==========] Running 9 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 9 tests from LSMTest
[ RUN      ] LSMTest.BasicOperations
[       OK ] LSMTest.BasicOperations (1007 ms)
[ RUN      ] LSMTest.Persistence
[       OK ] LSMTest.Persistence (2022 ms)
[ RUN      ] LSMTest.LargeScaleOperations
[       OK ] LSMTest.LargeScaleOperations (1021 ms)
[ RUN      ] LSMTest.MixedOperations
[       OK ] LSMTest.MixedOperations (1043 ms)
[ RUN      ] LSMTest.IteratorOperations
[       OK ] LSMTest.IteratorOperations (1001 ms)
[ RUN      ] LSMTest.MonotonyPredicate
[       OK ] LSMTest.MonotonyPredicate (1019 ms)
# 其余测试与实物相关
</code></pre>
<h1 id="5-总结与思考"><a class="header" href="#5-总结与思考">5 总结与思考</a></h1>
<p>这应该是目前为止强度最大的一个阶段的<code>Lab</code>了, 不过现在你已经得到了可以运行并执行部分复杂功能的<code>LSM</code>引擎了, 所以这一阶段标志着<code>LSM Tree</code>项目的初步阶段, 算是一个小小的里程碑, 有没有一点成就感?</p>
<p>不过我们的<code>Lab</code>还需要继续, 首先思考着几个问题:</p>
<ul>
<li>请观察你自己的<code>LSMTest.Persistence</code>的测试耗时, 是否比我的速度慢很多? 为什么? (如果你比我的速度快, 应该是硬件碾压了 🥵)</li>
<li>如果你的<code>LSMTest.Persistence</code>确实慢, 是不是缺少缓存池的优化?</li>
<li>我们的<code>compact</code>策略太粗糙, 你是否有更好的策略?</li>
</ul>
<p>然后, 进入阶段3: <a href="lab4/./Optimization.html">阶段3-LSM Tree 的优化</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阶段3-lsm-tree-的优化"><a class="header" href="#阶段3-lsm-tree-的优化">阶段3-LSM Tree 的优化</a></h1>
<p>上一阶段我们完成了基础的<code>LSM Engine</code>的实现, 但其缺乏性能优化。这一阶段， 你将实现以<code>Blcok</code>为单位的缓存池，以及布隆过滤器的优化。实现这两个优化方案后, 你可以对比前后的单元测试的整体运行时间, 尤其是<code>Persistence</code>这个测例(其数据规模量最大), 你可以直观地感受到这里的优化方案的必要性。</p>
<blockquote>
<p>提示: 强烈建议你自己创建一个分组实现<code>Lab</code>的内容, 并在每次新的<code>Lab</code>开始时进行如下同步操作:</p>
<pre><code class="language-bash">git pull origin lab
git checkout your_branch
git merge lab
</code></pre>
<p>如果你发现项目仓库的代码没有指导书中的 TODO 标记的话, 证明你需要运行上述命令更新代码了</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-48-复杂查询"><a class="header" href="#lab-48-复杂查询">Lab 4.8 复杂查询</a></h1>
<h1 id="1-缓存池原理与设计"><a class="header" href="#1-缓存池原理与设计">1 缓存池原理与设计</a></h1>
<h1 id="11-缓存池的作用"><a class="header" href="#11-缓存池的作用">1.1 缓存池的作用</a></h1>
<p>在LSM Tree的实现中，数据读取是以<code>Block</code>为单位进行的。为了提高热点<code>Block</code>的读取效率，我们引入了缓存池（<code>Buffer Pool</code>）。缓存池的主要作用主要是减少磁盘I/O, 通过将频繁访问的<code>Block</code>缓存到内存中，可以显著减少对磁盘的读取次数，从而提高系统的整体性能。因此这里我们的目的就是尽量让热点<code>Block</code>数据常驻内存。</p>
<h2 id="12-lru-k算法原理"><a class="header" href="#12-lru-k算法原理">1.2 LRU-K算法原理</a></h2>
<p>这里我采用<code>LRU-K</code>算法来管理缓存池。其实主要原因是以前做过<code>CMN15445</code>, 里面实现过<code>LRU-K</code>算法, 稍作改进可以直接拿来用, 这里就偷个懒了。照例还是先简单介绍下<code>LRU-K</code>。</p>
<p><code>LRU-K</code>（Least Recently Used with K accesses）是一种基于访问频率和时间的缓存淘汰策略。相比于传统的<code>LRU</code>（最近最少使用），<code>LRU-K</code>考虑了更复杂的访问模式，能够更好地适应实际应用场景中的数据访问特性。<code>LRU-K</code>仍然是使用键值对来索引缓存内容。</p>
<p><strong>设计思路</strong></p>
<ul>
<li>Key：表示在决定淘汰某个缓存项时，会考虑该缓存项在过去K次访问的时间间隔。当K=1时，LRU-K退化为普通的LRU。这里我的的<code>Blcok</code>可以由<code>(sst_id, block_id)</code>唯一索引, 因此缓存池的的<code>Block</code>索引键可以设计为<code>std::pair&lt;sst_id, block_id&gt;</code></li>
<li>访问链表：每个缓存项都有一个访问历史记录，记录其最近K次的访问时间。当最近访问次数大于等于K次, 则放在链表首部, 不足K次的放在后半部分, 按照访问时间排序。</li>
</ul>
<p><strong>淘汰规则</strong></p>
<ul>
<li>当缓存池满时，选择那些在过去K次访问中时间间隔最长的缓存项进行淘汰。</li>
<li>如果多个缓存项的时间间隔相同，则选择最早插入缓存池的那个项。</li>
</ul>
<h1 id="2-代码实现-8"><a class="header" href="#2-代码实现-8">2 代码实现</a></h1>
<h2 id="21-代码思路梳理"><a class="header" href="#21-代码思路梳理">2.1 代码思路梳理</a></h2>
<p>这里采用一个简化的<code>LRU-K</code>实现, 我们不需要记录访问的时间戳, 而是用链表的顺序来表达最新的访问记录, 最新的访问置于链表头部。另一方面，为保证快速查询，我们还需要一个哈希表，这个哈希表的索引键为<code>std::pair&lt;sst_id, block_id&gt;</code>， 索引值为链表的迭代器， 因此结合二者可以简单实现查询和新增均为<code>O(1)</code>的缓存池。那怎么表达<code>LRU-K</code>呢? 很简单, 采用2个链表, 一个存储访问次数少于<code>k</code>次的缓存项, 一个存储访问次数大于等于<code>k</code>次的缓存项。</p>
<p>首先看一下头文件的关键定义:</p>
<pre><code class="language-cpp">struct CacheItem {
  int sst_id;
  int block_id;
  std::shared_ptr&lt;Block&gt; cache_block;
  uint64_t access_count; // 访问计数
};
// 定义缓存池
class BlockCache {
public:
  ...

private:
  size_t capacity_;          // 缓存容量
  size_t k_;                 // LRU-K 中的 K 值

  // 双向链表存储缓存项
  std::list&lt;CacheItem&gt; cache_list_greater_k;
  std::list&lt;CacheItem&gt; cache_list_less_k;

  // 哈希表索引缓存项
  std::unordered_map&lt;std::pair&lt;int, int&gt;, std::list&lt;CacheItem&gt;::iterator,
                     pair_hash, pair_equal&gt;
      cache_map_;

  ...
};
</code></pre>
<details>
<summary>点击这里展开/折叠提示 (建议你先尝试自己完成)</summary>
<blockquote>
<p>本思路实现的<code>LRU-K</code>并不标准, 你可以按照自己的方案实行, 可以大刀阔斧地修改代码, 保证接口统一即可</p>
</blockquote>
<p>我们结合<code>cache_list_greater_k</code>, <code>cache_list_less_k</code>和<code>cache_map_</code>来整理一下流程:</p>
<p><strong>查询</strong></p>
<ol>
<li>先通过<code>cache_map_</code>查询缓存项的迭代器, 通过迭代器的访问次数判断其属于哪个链表。
<ol>
<li><code>访问次数 &lt; k</code> -&gt; 属于 <code>cache_list_less_k</code>
<ol>
<li>如果<code>访问次数 == k-1</code>，更新访问次数后就就等于k了，将其重新置于<code>cache_list_greater_k</code>的头部。</li>
<li>否则更新后仍然属于<code>cache_list_greater_k</code>，但需要将其移动到<code>cache_list_greater_k</code>的头部。</li>
</ol>
</li>
<li><code>访问次数 = k</code> -&gt; 属于 <code>cache_list_greater_k</code>, 将其置于<code>cache_list_greater_k</code>的头部。但<code>访问次数</code>就固定在<code>k</code>, 不继续增长了</li>
</ol>
</li>
</ol>
<p><strong>插入</strong></p>
<ol>
<li>先通过<code>cache_map_</code>查询缓存项是否存在, 存在则按照之前的步骤更新缓存项即可</li>
<li>不存在的话, 判断缓存池是否已满
<ol>
<li>没有满
<ol>
<li>直接插入到<code>cache_list_less_k</code>头部，并更新cache_map_索引。</li>
</ol>
</li>
<li>满了
<ol>
<li>如果<code>cache_list_less_k</code>不为空，从<code>cache_list_less_k</code>末尾淘汰一个缓存项，并插入新的缓存项到<code>cache_list_less_k</code>头部。</li>
<li>如果<code>cache_list_less_k</code>为空，从<code>cache_list_greater_k</code>末尾淘汰一个缓存项，并插入新的缓存项到<code>cache_list_less_k</code>。</li>
</ol>
</li>
</ol>
</li>
</ol>
</details>
<blockquote>
<p>根据你的实现, 你可以更改<code>CacheItem</code>的定义和排序规则, 例如记录访问的具体时间戳等</p>
</blockquote>
<h1 id="22-具体实现"><a class="header" href="#22-具体实现">2.2 具体实现</a></h1>
<p>你需要修改的代码文件包括:</p>
<ul>
<li><code>src/block/block_cache.cpp</code></li>
<li><code>include/block/block_cache.h</code> (Optional)</li>
</ul>
<p>要实现的函数也很简单, 首先是插入一个<code>Block</code>到缓存池:</p>
<pre><code class="language-cpp">void BlockCache::put(int sst_id, int block_id, std::shared_ptr&lt;Block&gt; block) {
  // TODO: Lab 4.8 插入一个 Block
}
</code></pre>
<p>然后是查询一个<code>Block</code>:</p>
<pre><code class="language-cpp">std::shared_ptr&lt;Block&gt; BlockCache::get(int sst_id, int block_id) {
  // TODO: Lab 4.8 查询一个 Block
  return nullptr;
}
</code></pre>
<p>最后是一些辅助函数, 比如你在插入和查询时, 需要更新相应<code>Block</code>的统计信息:</p>
<pre><code class="language-cpp">void BlockCache::update_access_count(std::list&lt;CacheItem&gt;::iterator it) {
  // TODO: Lab 4.8 更新统计信息
}
</code></pre>
<p>具体更新什么统计信息呢? 除了要保证缓存池的基础运行逻辑正确外, 你看到这个获取命中率的函数可能有所启发:</p>
<pre><code class="language-cpp">double BlockCache::hit_rate() const {
  std::lock_guard&lt;std::mutex&gt; lock(mutex_);
  return total_requests_ == 0
             ? 0.0
             : static_cast&lt;double&gt;(hit_requests_) / total_requests_;
}
</code></pre>
<h1 id="3-缓存池的构造"><a class="header" href="#3-缓存池的构造">3 缓存池的构造</a></h1>
<p>现在我们已经实现了<code>BlockCache</code>这个类, 你应该还记得, 之前我们许多函数的参数中都包含了<code>std::shared_ptr&lt;BlockCache&gt;</code>类型的参数, 且其都发起于上层组件<code>LSMEngine</code>, 同时<code>LSMEngine</code>也包含了<code>std::shared_ptr&lt;BlockCache&gt;</code>的成员变量, 因此你需要在<code>LSMEngine</code>的构造函数中初始化这个成员变量, 并在调用的函数中进行传递。</p>
<blockquote>
<p>一些配置参数仍然可以查看<code>config.toml</code>并使用<code>TomlConfig::getInstance().getXXX</code>获取</p>
</blockquote>
<h1 id="4-测试-4"><a class="header" href="#4-测试-4">4 测试</a></h1>
<p>对于缓存池本身, 你应该可以通过下面的测试:</p>
<pre><code class="language-bash">✗ xmake
✗ xmake run test_block_cache
[==========] Running 4 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 4 tests from BlockCacheTest
[ RUN      ] BlockCacheTest.PutAndGet
[       OK ] BlockCacheTest.PutAndGet (0 ms)
[ RUN      ] BlockCacheTest.CacheEviction1
[       OK ] BlockCacheTest.CacheEviction1 (0 ms)
[ RUN      ] BlockCacheTest.CacheEviction2
[       OK ] BlockCacheTest.CacheEviction2 (0 ms)
[ RUN      ] BlockCacheTest.HitRate
[       OK ] BlockCacheTest.HitRate (0 ms)
[----------] 4 tests from BlockCacheTest (0 ms total)

[----------] Global test environment tear-down
[==========] 4 tests from 1 test suite ran. (0 ms total)
[  PASSED  ] 4 tests.
</code></pre>
<p>在<code>SSt</code>和<code>Block</code>的逻辑层面, 本节实验并未新添加任何接口, 只是做出了IO层面的优化, 因此, 你只需要像<a href="lab4/./lab4.7-Complicated-Query.html">Lab 4.7 复杂查询</a>那样再次运行单元测试, 观察前后数据读取的效率变化即可。</p>
<p>需要说明的是, 你需要尤其关注<code>Persistence</code>这个测例(位于<code>test/test_lsm.cpp</code>), 因为其会插入大量的数据并刷盘, 此时的大部分查询请求都是在<code>SST</code>文件层面进行的, 能够较为明显地观察出加入缓存池优化后的速度变化。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-49-布隆过滤器"><a class="header" href="#lab-49-布隆过滤器">Lab 4.9 布隆过滤器</a></h1>
<p>除了缓存池之外，我们下一个要实现的优化方案是布隆过滤器。布隆过滤器你可能在各大校招实习的八股文中都遇到过（尤其是和经典问题：如何避免<code>Redis</code>的缓存穿透问题）。本小节我们就将自己实现一个布隆过滤器。</p>
<h1 id="1-布隆过滤器简介"><a class="header" href="#1-布隆过滤器简介">1 布隆过滤器简介</a></h1>
<h2 id="11-原理介绍"><a class="header" href="#11-原理介绍">1.1 原理介绍</a></h2>
<p>布隆过滤器是一种 <code>probabilistic</code> 数据结构，用于判断一个元素是否在集合中。它通过一个概率的方式来判断，即使集合中存在一个元素，但是布隆过滤器也依然可以判断出来。</p>
<p>布隆过滤器的核心思想是使用一个位数组和多个哈希函数来表示一个集合。它的特点是可以高效地判断某个元素是否“可能存在”或“确定不存在”，但它有一定的误判率，即可能会误判某个不存在的元素为“可能存在”。其实现方式如下:</p>
<ol>
<li><strong>初始化位数组</strong>：布隆过滤器使用一个固定大小的位数组（如长度为 <code>m</code>），所有位初始化为 <code>0</code>。</li>
<li><strong>插入元素时在位数组记录</strong>：当插入一个元素时，使用 <code>k</code> 个独立的哈希函数对该元素进行哈希运算，得到 <code>k</code> 个哈希值（每个值对应位数组的索引）。将这些索引位置的位设置为 <code>1</code>。</li>
<li><strong>查询元素时在位数组校验</strong>：当查询一个元素是否存在时，同样使用 <code>k</code> 个哈希函数对该元素进行哈希运算，得到 <code>k</code> 个哈希值。如果这些哈希值对应的位数组中的所有位都为 <code>1</code>，则判断该元素“可能存在”；如果有任意一位为 <code>0</code>，则判断该元素“确定不存在”。</li>
</ol>
<p><strong>特点</strong></p>
<ul>
<li><strong>优点</strong>：布隆过滤器的空间效率和查询效率非常高，适合处理大规模数据。</li>
<li><strong>缺点</strong>：存在一定的误判率（即可能会误判不存在的元素为“可能存在”），并且无法删除元素（删除可能会影响其他元素的判断）。</li>
</ul>
<h2 id="12-案例介绍"><a class="header" href="#12-案例介绍">1.2 案例介绍</a></h2>
<p>下面我们通过一个案例来看看布隆过滤器的运行机制:</p>
<p><img src="lab4/../images/lab4/bloom-example.png" alt="bloom-example" /></p>
<ol>
<li>在新增一个记录时(<code>put/insert</code>等), 通过预定义数量(案例图片中是2个)的哈希函数对<code>key</code>进行哈希, 将哈希值对位数组的长度取模, 将结果作为索引, 将索引位置的位设置为1</li>
<li>在查询时(<code>get</code>), 通过预定义数量(案例图片中是2个)的哈希函数对<code>key</code>进行哈希, 将哈希值对位数组的长度取模, 将结果作为索引, 如果索引位置的位为1, 则认为该<code>key</code>可能存在, 否则认为该<code>key</code>不存在</li>
</ol>
<h1 id="2-lsm-tree中的布隆过滤器"><a class="header" href="#2-lsm-tree中的布隆过滤器">2 LSM-Tree中的布隆过滤器</a></h1>
<p>尽管我们之前为整个<code>LSM-Tree</code>设计了<code>bock cache</code>, 但面对大量不存在于<code>LSM-Tree</code>中的<code>key</code>时, <code>bock cache</code>会频繁的进行磁盘IO, 这将导致<code>LSM-Tree</code>的性能降低。</p>
<blockquote>
<p>这里的原理类似后端八股文中<code>Redis</code>常问的缓存击穿、缓存穿透、缓存雪崩，而设置布隆过滤器就是一个景点的解决方案，背过八股的同学们应该会很熟悉。</p>
</blockquote>
<p>因此，我们可以在编码<code>SST</code>文件时，为每个<code>SST</code>文件都设计一个<code>bloom filter</code>, 在其中记录整个<code>SST</code>中的所有<code>key</code>, 并将其持久化到文件系统中, 在读取文件时, 相应的布隆过滤器部分也需要被解码并加载到内存中。这样当查询时, 我们只需要判断<code>key</code>是否存在于<code>bloom filter</code>中, 如果不存在, 则认为该<code>key</code>不存在于<code>LSM-Tree</code>, 否则, 我们需要继续在<code>LSM-Tree</code>中查找。这样以来, 我们就可以避免大量的无效访问。</p>
<h1 id="3-布隆过滤器代码解读"><a class="header" href="#3-布隆过滤器代码解读">3 布隆过滤器代码解读</a></h1>
<p>同样地, 我们解读下头文件的定义:</p>
<pre><code class="language-cpp">class BloomFilter {
public:
  // 构造函数，初始化布隆过滤器
  // expected_elements: 预期插入的元素数量
  // false_positive_rate: 允许的假阳性率
  BloomFilter();
  BloomFilter(size_t expected_elements, double false_positive_rate);
  
  // ...

private:
  // 布隆过滤器的位数组大小
  size_t expected_elements_;
  // 允许的假阳性率
  double false_positive_rate_;
  size_t num_bits_;
  // 哈希函数的数量
  size_t num_hashes_;
  // 布隆过滤器的位数组
  std::vector&lt;bool&gt; bits_;

private:
  // 第一个哈希函数
  // 返回值: 哈希值
  size_t hash1(const std::string &amp;key) const;

  // 第二个哈希函数
  // 返回值: 哈希值
  size_t hash2(const std::string &amp;key) const;

  size_t hash(const std::string &amp;key, size_t idx) const;
};
</code></pre>
<p>我们需要完成如下的功能：</p>
<ol>
<li>能够在初始化时通过假阳性率和键的数量来确定哈希函数的数量和位数组的长度</li>
<li>支持编码与解码</li>
</ol>
<p>对于<code>通过假阳性率和键的数量来确定哈希函数的数量和位数组的长度</code>, 我们可以按照指定的公式求取, 但问题在于我们是不知道哈希函数的数量的, 难道我们要手动写很多个哈希函数吗?</p>
<p>我们可以采用这样的方案: 只写2个哈希函数, 通过对这两个哈希函数的线性组合构造新的哈希函数, 这也就是你在头文件定义中看到的<code>hash1</code>和<code>hash2</code></p>
<blockquote>
<p>这里有一个坑, <code>std::vector&lt;bool&gt;</code>中单个元素存储只占一个位, 而不是一个字节</p>
</blockquote>
<p>此外, 你应该从之前的介绍中了解到, 布隆过滤器只能滤除百分百不存在的元素, 但其不能保证一个元素一定存在。不过我们可以给出一个目标概率， 例如，如果目标概率为0.01，则表示我们希望布隆过滤器误判的概率不超过1%。这就是成员变量中的<code>false_positive_rate</code>。</p>
<p>假阳性率和位数组长度之间的关系可以用以下公式表示：</p>
<p>$$m = - \frac{n \cdot \ln(p)}{(\ln(2))^2}$$</p>
<p>其中，<code>m</code> 是位数组的长度，<code>n</code> 是预期插入的元素数量，<code>p</code> 是假阳性率。</p>
<p>而哈希函数的数量由公式:
$$k = \frac{m}{n} \cdot \ln(2)$$</p>
<blockquote>
<p>为什么公式是这样的? 你可以尝试自己推导, 也可以去 <code>Google</code> 一下或者问<code>LLM</code></p>
</blockquote>
<h1 id="4-代码实现"><a class="header" href="#4-代码实现">4 代码实现</a></h1>
<h2 id="41-构造函数"><a class="header" href="#41-构造函数">4.1 构造函数</a></h2>
<pre><code class="language-cpp">// 构造函数，初始化布隆过滤器
// expected_elements: 预期插入的元素数量
// false_positive_rate: 允许的假阳性率
BloomFilter::BloomFilter(size_t expected_elements, double false_positive_rate)
    : expected_elements_(expected_elements),
      false_positive_rate_(false_positive_rate) {
  // TODO: Lab 4.9: 初始化数组长度
}
</code></pre>
<p>这里, 构造函数就是按照之前理论介绍部分中的公式, 确定数组长度并初始化容器和哈希函数数量</p>
<h2 id="42-hash"><a class="header" href="#42-hash">4.2 hash</a></h2>
<p>如同之前介绍的, <code>hash</code>函数有很多个, 我们不可能手动写出一大堆候选函数出来, 因此这里你需要对<code>hash1</code>和<code>hash2</code>进行组合, 构造出新的哈希函数(<code>idx</code>标识这是第几个哈希函数):</p>
<pre><code class="language-cpp">size_t BloomFilter::hash(const std::string &amp;key, size_t idx) const {
  // TODO: Lab 4.9: 计算哈希值
  // ? idx 标识这是第几个哈希函数
  // ? 你需要按照某些方式, 从 hash1 和 hash2 中组合成新的哈希函数
  return 0;
}
</code></pre>
<h2 id="43-add"><a class="header" href="#43-add">4.3 add</a></h2>
<p>添加记录时, 我们根据哈希函数的序号, 调用你之前实现的<code>hash</code>函数, 将结果对位数组的长度取模, 将结果作为索引, 将索引位置的位设置为1:</p>
<pre><code class="language-cpp">void BloomFilter::add(const std::string &amp;key) {
  // TODO: Lab 4.9: 添加一个记录到布隆过滤器中
}
</code></pre>
<h2 id="44-encodedecode"><a class="header" href="#44-encodedecode">4.4 encode/decode</a></h2>
<p>与缓存池不同, 布隆过滤器需要持久化到文件系统中。这是因为我们的<code>Block</code>在形成后就是只读的形式了, 不会发生变化。如果不持久化到文件系统中, 那么在重启时, 我们就则需要对每个键值对再次进行解码和哈希运算构造新的布隆过滤器实例， 这显然是不合理的。因此你需要实现编码和解码函数:</p>
<pre><code class="language-cpp">// 编码布隆过滤器为 std::vector&lt;uint8_t&gt;
std::vector&lt;uint8_t&gt; BloomFilter::encode() {
  // TODO: Lab 4.9: 编码布隆过滤器
  return std::vector&lt;uint8_t&gt;();
}

// 从 std::vector&lt;uint8_t&gt; 解码布隆过滤器
BloomFilter BloomFilter::decode(const std::vector&lt;uint8_t&gt; &amp;data) {
  BloomFilter bf;
  // TODO: Lab 4.9: 解码布隆过滤器
  return bf;
}
</code></pre>
<p>这里我们仍然使用<code>std::vector&lt;uint8_t&gt;</code>作为编码后的数据结构, 你需要将位数组中的每个元素都编码为一个字节, 并将所有字节拼接起来。这里的二进制数组将整合到<code>SST</code>文件中。</p>
<h1 id="5-将-bloomfilter-集成到-sst"><a class="header" href="#5-将-bloomfilter-集成到-sst">5 将 BloomFilter 集成到 SST</a></h1>
<p>现在你已经实现了<code>BloomFilter</code>, 你需要将其集成到<code>SST</code>文件中。具体来说，你需要修改<code>SST</code>文件的编码和解码函数:</p>
<ul>
<li>编码时调用<code>BloomFilter::encode</code>将编码的布隆过滤器部分的<code>std::vector&lt;uint8_t&gt;</code>拼接到<code>SST文件</code>的正确位置;</li>
<li>解码时从<code>SST文件</code>的指定偏移位置取出<code>std::vector&lt;uint8_t&gt;</code>切片, 并解码出<code>BloomFilter</code>放置于<code>SST</code>类实例的控制结构的成员变量中。</li>
</ul>
<p>这里回顾一下我们的<code>SST</code>文件的结构:
<img src="lab4/../images/lab3/SST.drawio.png" alt="SST" /></p>
<p>你应该知道这里<code>Bloom Section</code>的<code>...</code>里面放置的是什么了吧?</p>
<p>首先, 之前的<code>SSTBuilder::build</code>和<code>SST::open</code>涉及整个<code>SST</code>的持久化和编解码, 是你肯定需要修改的。此外由于每个人的设计思路不同, 因此其他地方没有固定的修改文件和函数, 你只需要保证编解码过程正确、查询数据时能够正常利用到布隆过滤器即可。</p>
<h1 id="6-测试-2"><a class="header" href="#6-测试-2">6 测试</a></h1>
<p>对于布隆过滤器本身, 你应该可以通过下面的测试:</p>
<pre><code class="language-bash">✗ xmake
✗ xmake run test_utils # 布隆过滤器的测试包含在 `test_utils` 中
[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from BloomFilterTest
[ RUN      ] BloomFilterTest.ComprehensiveTest
False positive rate: 0.08
[       OK ] BloomFilterTest.ComprehensiveTest (2 ms)
[----------] 1 test from BloomFilterTest (2 ms total)

[----------] Global test environment tear-down
[==========] 1 test f
</code></pre>
<p>类似之前缓存池的小节, 在逻辑层面本节实验并未新添加任何接口, 只是做出了IO层面的优化, 因此, 你只需要像<a href="lab4/./lab4.7-Complicated-Query.html">Lab 4.7 复杂查询</a>那样再次运行单元测试, 观察前后数据读取的效率变化即可。</p>
<p>需要说明的是, 你需要尤其关注<code>Persistence</code>这个测例(位于<code>test/test_lsm.cpp</code>), 因为其会插入大量的数据并刷盘, 此时的大部分查询请求都是在<code>SST</code>文件层面进行的, 能够较为明显地观察出加入缓存池优化后的速度变化。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-5-事务--mvcc--wal"><a class="header" href="#lab-5-事务--mvcc--wal">Lab 5 事务 &amp;&amp; MVCC &amp;&amp; WAL</a></h1>
<h1 id="事务理论知识"><a class="header" href="#事务理论知识">事务理论知识</a></h1>
<p>本小节主要介绍事务的基本概念，事务的ACID特性，事务的隔离级别, 没有代码任务需要你完成。因此，如果你对这些内容已经熟悉，可以跳过本小节，直接进入下一节。</p>
<h1 id="1-本小节目标"><a class="header" href="#1-本小节目标">1 本小节目标</a></h1>
<p>之前大家实现的各种函数中, 都是忽略了<code>tranc_id</code>这个参数的, 这一小节之后, <code>tranc_id</code>的神秘面纱将被揭开, 我们将学习事务的基础知识, 并修改之前所有的涉及<code>tranc_id</code>的函数, 使其能够支持事务特性。</p>
<p>首先给出本章实验后的架构示意图:</p>
<p><img src="lab5/../images/intro/tiny-lsm-arch-full.drawio.png" alt="Arch" /></p>
<p>相比之前实现的<code>LSM Engine</code>的基础部分的<a href="lab5/../images/intro/tiny-lsm-arch.drawio.png">架构</a>, 这里新增了<code>TrancManager</code>、<code>WAL</code>、<code>TrancContext</code>杰哥模块, 其中<code>TrancManager</code>用于管理事务, <code>WAL</code>用于持久化事务操作, <code>TrancContext</code>用于与客户端进行直接交互。</p>
<h1 id="2-kv存储中的事务"><a class="header" href="#2-kv存储中的事务">2 KV存储中的事务</a></h1>
<h2 id="21-事务介绍"><a class="header" href="#21-事务介绍">2.1 事务介绍</a></h2>
<p>在数据库系统中，事务（Transaction）是指一组原子性操作的执行单元，需要满足ACID特性。这里简单介绍下<code>ACID</code>的基本性质:</p>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>定义</th><th>技术实现</th><th>KV存储中的特殊表现</th></tr></thead><tbody>
<tr><td><strong>原子性</strong><br>(Atomicity)</td><td>事务内的操作要么全部成功，要么全部失败，不存在中间状态。</td><td>- WAL（Write-Ahead Logging）<br>- 两阶段提交（2PC）<br>- 操作回滚日志</td><td>- 单键操作天然原子<br>- 跨键原子性需显式事务（如批量提交）<br>- LSM-Tree依赖WAL保证崩溃恢复</td></tr>
<tr><td><strong>一致性</strong><br>(Consistency)</td><td>事务执行后数据库必须保持预设的业务规则（如唯一性、完整性约束）。</td><td>- 关系型：外键、触发器<br>- 声明式约束（DDL）<br>- 事务回滚机制</td><td>- 业务逻辑一致性需应用层实现</td></tr>
<tr><td><strong>隔离性</strong><br>(Isolation)</td><td>并发事务相互隔离，避免脏读、不可重复读、幻读。</td><td>- 锁机制（悲观锁）<br>- MVCC（多版本并发控制）<br>- 快照隔离（Snapshot Isolation）</td><td>- 通常采用乐观锁（版本号校验）<br>- 全局时间戳实现快照隔离<br>- 弱隔离级别常见（如Read Committed）</td></tr>
<tr><td><strong>持久性</strong><br>(Durability)</td><td>事务提交后，数据永久存储，即使系统崩溃也不丢失。</td><td>- 同步刷盘（<code>fsync</code>）<br>- 副本复制（Replication）<br>- 冗余存储（如RAID）</td><td>- LSM-Tree依赖SSTable落盘<br>- 内存数据需通过WAL持久化<br>- 异步刷盘可能牺牲部分持久性（如Redis AOF）</td></tr>
</tbody></table>
</div>
<p>在这四个基本性质中, KV存储由于数据较为简单, 不存在类似关系型数据库中的外键、触发器、声明式约束等复杂业务规则, 因此一致性是比较容易实现的，基本上你实现了一致性、隔离性，一致性就自然满足了，这里我们探讨下其他几个形状在<code>KV存储</code>中的实现逻辑:</p>
<ol>
<li><strong>原子性</strong>：通过批量化操作即可, 可以将一个事务的操作先暂存起来, 在提交时统一应用到存储引擎的状态机中。</li>
<li><strong>隔离性</strong>：这里涉及到隔离级别， 会在后面统一介绍。</li>
<li><strong>持久性</strong>：<code>LSM-Tree</code>的持久化依赖<code>SSTable</code>落盘，但我们插入一些数据后, 这些数据肯定优先存在于内存中, 在内存容量达到阈值后才会刷盘, 为保证持久性, 可以用以下两个方案
<ol>
<li>事务提交后强制刷盘到<code>SST</code>, 但这样可能导致刷入的<code>L0 SST</code>大小过小, 加大了<code>L0 SST</code>合并时的计算量(后续章节介绍<code>compact</code>)</li>
<li>事务提交时先将操作写入<code>WAL</code>(<code>Write-Ahead Logging</code>), 同时存储引擎维护刷入<code>SST</code>的最大事务序号, 在重启或崩溃恢复时根据<code>WAL</code>重放操作(后续会介绍)</li>
</ol>
</li>
</ol>
<h2 id="22-隔离级别"><a class="header" href="#22-隔离级别">2.2 隔离级别</a></h2>
<h3 id="221-隔离级别的定义与分类"><a class="header" href="#221-隔离级别的定义与分类">2.2.1 隔离级别的定义与分类</a></h3>
<p>在并发事务场景下，隔离性通过不同的隔离级别实现不同程度的可见性控制。我们先回顾下关系型数据库中的隔离级别:</p>
<blockquote>
<p>这里如果对这些隔离级别不熟悉, 建议先学下数据库的课程</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>隔离级别</th><th>脏读(Dirty Read)</th><th>不可重复读(Non-Repeatable Read)</th><th>幻读(Phantom Read)</th><th>典型实现方案</th></tr></thead><tbody>
<tr><td><strong>读未提交</strong></td><td>允许</td><td>允许</td><td>允许</td><td>- 无版本控制<br>- 直接读取内存最新值</td></tr>
<tr><td><strong>读已提交</strong></td><td>禁止</td><td>允许</td><td>允许</td><td>- 单版本快照<br>- 每次读获取最新提交版本</td></tr>
<tr><td><strong>可重复读</strong></td><td>禁止</td><td>禁止</td><td>允许</td><td>- 多版本快照<br>- 事务级版本锚定（如MySQL InnoDB的MVCC）</td></tr>
<tr><td><strong>可串行化</strong></td><td>禁止</td><td>禁止</td><td>禁止</td><td>- 严格锁机制<br>- 冲突范围检测（如FoundationDB）</td></tr>
</tbody></table>
</div>
<blockquote>
<p>注：快照隔离下幻读仍可能发生，但可通过追加范围锁避免</p>
</blockquote>
<h3 id="222-kv存储中事务冲突和隔离级别的案例"><a class="header" href="#222-kv存储中事务冲突和隔离级别的案例">2.2.2 KV存储中事务冲突和隔离级别的案例</a></h3>
<p>在LSM-Tree结构的KV存储中，我们举一个例子说明隔离级别和实物冲突的联系:</p>
<p>在下面的场景时序图, 事务按照创建的时间从小大大分配<code>ID</code>, 在这个</p>
<div class="table-wrapper"><table><thead><tr><th>Timeline</th><th>事务A (ID=100)</th><th>事务B (ID=101)</th><th>Key1状态</th></tr></thead><tbody>
<tr><td>T0</td><td>Begin</td><td></td><td>Version=0 (初始值)</td></tr>
<tr><td>T1</td><td>Read Key1 (Version=0)</td><td>Begin</td><td></td></tr>
<tr><td>T2</td><td>Modify Key1→ValueA</td><td>Read Key1 (Version=0)</td><td></td></tr>
<tr><td>T3</td><td></td><td>Modify Key1→ValueB</td><td></td></tr>
<tr><td>T4</td><td></td><td>Commit ✅ (Version=1)</td><td>Version=1 (ValueB)</td></tr>
<tr><td>T5</td><td>Attempt Commit ❌</td><td></td><td>检测到Key1已更新</td></tr>
</tbody></table>
</div>
<p>在这个例子中, 更早创建的事务A和和更晚创建的事务B在读写了同一个<code>Key1</code>, 事务B先提交, 并且更新了<code>Key1</code>的值为<code>ValueB</code>, 事务A在提交后, 数据库中面临这样的问题: 以哪一个版本的修改为准?</p>
<p>以上问题就是一种事务冲突，在<code>KV存储</code>中，事务冲突的解决方式直接取决于<strong>隔离级别</strong>的设计。以下是不同隔离级别的处理差异：</p>
<div class="table-wrapper"><table><thead><tr><th>隔离级别</th><th>事务A提交结果</th><th>原因</th><th>最终Key1值</th></tr></thead><tbody>
<tr><td><strong>读未提交</strong></td><td>✅ 成功</td><td>允许覆盖未提交数据，但导致事务B的修改丢失（违反原子性）</td><td>ValueA</td></tr>
<tr><td><strong>读已提交</strong></td><td>❌ 中止</td><td>检测到Key1已提交新版本（Version=1 &gt; 事务A的起始版本）</td><td>ValueB</td></tr>
<tr><td><strong>可重复读</strong></td><td>❌ 中止</td><td>事务A的读快照锁定Version=0，但写冲突仍存在</td><td>ValueB</td></tr>
<tr><td><strong>可串行化</strong></td><td>❌ 中止</td><td>通过范围锁阻止事务B写入，或强制事务串行执行</td><td>ValueB</td></tr>
</tbody></table>
</div>
<p>以上是<code>put</code>时是事务冲突, 基于这个案例, 同时有2个事务再去读取<code>key1</code>:</p>
<blockquote>
<p>假设初始时刻 <code>Key1 = Value0</code></p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Timeline</th><th>事务A (ID=100)</th><th>事务B (ID=101)</th><th>事务C (ID=102)</th><th>事务D (ID=103)</th></tr></thead><tbody>
<tr><td>T0</td><td>Begin</td><td></td><td>Key1 = Value0 (初始值)</td><td>Key1 = Value0 (初始值)</td></tr>
<tr><td>T1</td><td>Read Key1</td><td>Begin</td><td></td><td></td></tr>
<tr><td>T2</td><td>Modify Key1→ValueA</td><td></td><td>Begin</td><td></td></tr>
<tr><td>T3</td><td></td><td></td><td>Read Key1 (Version=❓)</td><td></td></tr>
<tr><td>T4</td><td></td><td>Read Key1</td><td></td><td></td></tr>
<tr><td>T5</td><td></td><td>Modify Key1→ValueB</td><td></td><td></td></tr>
<tr><td>T6</td><td></td><td>Attempt Commit ❓</td><td></td><td></td></tr>
<tr><td>T7</td><td></td><td></td><td></td><td>Begin</td></tr>
<tr><td>T8</td><td></td><td></td><td>Read Key1 (Key1=❓)</td><td>Read Key1 (Key1=❓)</td></tr>
<tr><td>T9</td><td>Attempt Commit ❓</td><td></td><td></td><td></td></tr>
<tr><td>T10</td><td></td><td></td><td>Read Key1 (Key1=❓)</td><td>Read Key1 (Key1=❓)</td></tr>
</tbody></table>
</div>
<p>这个场景下, 在事务A和B操作时, 另外还存在2个事务C和D在读取<code>key1</code>的值, 事务C和D的读取结果是仍然取决于隔离级别:</p>
<h4 id="1-读未提交read-uncommitted"><a class="header" href="#1-读未提交read-uncommitted"><strong>1. 读未提交（Read Uncommitted）</strong></a></h4>
<p>允许读取未提交的中间值（包括可能回滚的脏数据）。</p>
<div class="table-wrapper"><table><thead><tr><th>事务</th><th>T3（C读取）</th><th>T8（C/D读取）</th><th>T10（C/D读取）</th><th>事务提交结果</th><th>结果解释</th></tr></thead><tbody>
<tr><td><strong>A</strong></td><td>-</td><td>-</td><td>-</td><td>✅ 成功</td><td>不检测写冲突，直接覆盖事务B的提交（Key1=ValueA）</td></tr>
<tr><td><strong>B</strong></td><td>-</td><td>-</td><td>-</td><td>✅ 成功</td><td>事务B先提交（Key1=ValueB），但被事务A覆盖</td></tr>
<tr><td><strong>C</strong></td><td>ValueA</td><td>ValueB</td><td>ValueA</td><td>-</td><td>T3读取事务A未提交的ValueA；T8时事务B已经提交，读ValueB；T10事务A提交后读ValueA</td></tr>
<tr><td><strong>D</strong></td><td>-</td><td>ValueB</td><td>ValueA</td><td>-</td><td>T8时事务A未提交，读ValueB；T10事务A提交后读ValueA</td></tr>
</tbody></table>
</div>
<p><strong>最终Key1值</strong>：ValueA（事务A覆盖事务B）<br />
<strong>风险</strong>：事务B的合法提交被覆盖，数据一致性被破坏。</p>
<hr />
<h4 id="2-读已提交read-committed"><a class="header" href="#2-读已提交read-committed"><strong>2. 读已提交（Read Committed）</strong></a></h4>
<p>仅读取已提交的数据，但同一事务内多次读取结果可能不同。</p>
<div class="table-wrapper"><table><thead><tr><th>事务</th><th>T3（C读取）</th><th>T8（C/D读取）</th><th>T10（C/D读取）</th><th>事务提交结果</th><th>结果解释</th></tr></thead><tbody>
<tr><td><strong>A</strong></td><td>-</td><td>-</td><td>-</td><td>✅ 成功 <br>or <br>❌中止</td><td>只确保读取时的数据是提交的, 但不确保提交时没有冲突, 取决于具体的实现</td></tr>
<tr><td><strong>B</strong></td><td>-</td><td>-</td><td>-</td><td>✅ 成功</td><td>事务B提交成功（Key1=ValueB）</td></tr>
<tr><td><strong>C</strong></td><td>Value0</td><td>ValueB</td><td>ValueA</td><td>-</td><td>T3时事务A/B均未提交，读Value0；T8时事务B已提交，读ValueB, 最后T10时事务A提交，读ValueA</td></tr>
<tr><td><strong>D</strong></td><td>-</td><td>ValueB</td><td>ValueA</td><td>-</td><td>T8时事务B已提交，读ValueB, 最后T10时事务A提交，读ValueA</td></tr>
</tbody></table>
</div>
<p><strong>最终Key1值</strong>：ValueA（事务A覆盖事务B）<br />
<strong>风险</strong>：事务B的合法提交被覆盖，数据一致性被破坏。
<strong>相较于前者的优化</strong>: 读取的数据一定是已经提交的数据</p>
<hr />
<h4 id="3-可重复读repeatable-read"><a class="header" href="#3-可重复读repeatable-read"><strong>3. 可重复读（Repeatable Read）</strong></a></h4>
<p>基于首次读取时的值锚定，保证多次读取结果一致。</p>
<div class="table-wrapper"><table><thead><tr><th>事务</th><th>T3（C读取）</th><th>T8（C/D读取）</th><th>T10（C/D读取）</th><th>事务提交结果</th><th>结果解释</th></tr></thead><tbody>
<tr><td><strong>A</strong></td><td>-</td><td>-</td><td>-</td><td>❌ 中止</td><td>提交时检测到Key1已被事务B修改</td></tr>
<tr><td><strong>B</strong></td><td>-</td><td>-</td><td>-</td><td>✅ 成功</td><td>事务B提交成功（Key1=ValueB）</td></tr>
<tr><td><strong>C</strong></td><td>Value0</td><td>Value0</td><td>Value0</td><td>-</td><td>事务C首次读取锚定Value0，后续读取强制复用</td></tr>
<tr><td><strong>D</strong></td><td>-</td><td>ValueB</td><td>ValueB</td><td>-</td><td>事务D首次读取时事务B已提交，锚定ValueB</td></tr>
</tbody></table>
</div>
<p><strong>最终Key1值</strong>：ValueB<br />
<strong>实现难点</strong>：需在内存中维护事务首次读取的键值锚定表，防止Compaction清理旧版本。</p>
<hr />
<h4 id="5-可串行化serializable"><a class="header" href="#5-可串行化serializable"><strong>5. 可串行化（Serializable）</strong></a></h4>
<p>通过锁机制强制事务串行执行，完全禁止并发冲突。</p>
<div class="table-wrapper"><table><thead><tr><th>事务</th><th>T3（C读取）</th><th>T8（C/D读取）</th><th>T10（C/D读取）</th><th>事务提交结果</th><th>结果解释</th></tr></thead><tbody>
<tr><td><strong>A</strong></td><td>-</td><td>-</td><td>-</td><td>❌ 中止</td><td>事务C持有Key1的共享锁，事务A尝试获取排他锁时被阻塞，最终超时中止</td></tr>
<tr><td><strong>B</strong></td><td>-</td><td>-</td><td>-</td><td>✅ 成功</td><td>事务B在事务C释放锁后获取排他锁并提交</td></tr>
<tr><td><strong>C</strong></td><td>Value0</td><td>Value0</td><td>Value0</td><td>-</td><td>事务C持有共享锁，保证读取一致性</td></tr>
<tr><td><strong>D</strong></td><td>-</td><td>ValueB</td><td>ValueB</td><td>-</td><td>事务D在事务B提交后读取ValueB</td></tr>
</tbody></table>
</div>
<p><strong>最终Key1值</strong>：ValueB<br />
<strong>锁竞争时序</strong>：事务C的共享锁阻塞事务A/B，事务B在事务C释放锁后提交。</p>
<hr />
<p>通过这个案例, 我们可以复习下MVCC在读已提交和可重复读的区别:</p>
<ol>
<li>读已提交: 读取时，快照基于当前这一次操作的时间</li>
<li>可重复读: 读取时，快照基于事务创建的时间</li>
</ol>
<h1 id="3-wal简单介绍"><a class="header" href="#3-wal简单介绍">3 WAL简单介绍</a></h1>
<p><code>WAL</code>（Write-Ahead Logging）是一种常用的日志记录机制，用于确保在系统崩溃或故障恢复时，数据的一致性和完整性。<code>WAL</code>的核心思想是：在执行数据修改操作之前，首先将修改操作记录到日志中，然后再对数据进行修改。这样，即使系统在修改数据的过程中崩溃，也可以通过日志中的记录来恢复数据。</p>
<p><code>WAl</code>主要是一种思想, 具体的日志编码格式、存储方式、检查恢复方式在不同数据库中差异很大，我们会在<a href="lab5/./lab5.3-Record.html">Lab 5.3</a>中对本实验项目的<code>WAL</code>设计进行详细讲解。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阶段1-事务基础功能"><a class="header" href="#阶段1-事务基础功能">阶段1-事务基础功能</a></h1>
<p>本阶段要求实现事务的基本功能，包括事务的提交和回滚，并在其中实现事务不同隔离级别下的<code>ACID</code>特性。</p>
<p>具体来说, 你首先需要实现一个<code>事务管理器</code>, 这个事务管理器负责事务<code>id</code>的生成、<code>事务上下文</code>的分配。</p>
<p>其次，你需要实现<code>事务上下文</code>的<code>CRUD</code>接口, <code>事务上下文</code>可以看做一个句柄, 其就是<code>CLient</code>直接操作的对象, 提供包括<code>get</code>、<code>put</code>、<code>remove</code>、<code>commit</code>、<code>abort</code>等接口。</p>
<blockquote>
<p>提示: 强烈建议你自己创建一个分组实现<code>Lab</code>的内容, 并在每次新的<code>Lab</code>开始时进行如下同步操作:</p>
<pre><code class="language-bash">git pull origin lab
git checkout your_branch
git merge lab
</code></pre>
<p>如果你发现项目仓库的代码没有指导书中的 TODO 标记的话, 证明你需要运行上述命令更新代码了</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-lab-51-事务基础功能"><a class="header" href="#2-lab-51-事务基础功能">2# Lab 5.1 事务基础功能</a></h1>
<h1 id="1-本kv引擎的mvcc和事务设计"><a class="header" href="#1-本kv引擎的mvcc和事务设计">1 本KV引擎的MVCC和事务设计</a></h1>
<p>通过事前的<code>MVCC</code>运行机制的分析可知, 在可重复读级别下, 我们需要记录这个事务开始的时间, 其实只需要记录这个事务的<code>id</code>就可以了, 因为我们可以设计一个事务管理器, 使得事务开始的时间严格按照事务<code>id</code>排序.</p>
<p>另一方面, 如果是读已提交, 我们需要按理说需要记录每个读操作的时间, 但是实际上, 我们的<code>KV</code>存储引擎是追加写入的, 我们本身读取的相同<code>key</code>就是按照最近时间读取的, 不需要额外记录本次操作的时间戳。换句话说，假设你遍历整个存储引擎的键值对， 其都是按照插入时间从近到久排序的。</p>
<p>故我们首先需要在键值对中记录事务<code>id</code>， 你应该在之前的<code>Lab</code>中已经实现了, 只是那是你不知道其具体的含义:</p>
<p><img src="lab5/../images/lab3/Block.png" alt="trac_id" /></p>
<p>同时, 你现在应该也明白了我们为什么需要在每个<code>SST</code>中记录事务<code>id</code>的范围, 这样我们才能在查找指定事务的记录时能够通过<code>SST</code>的元数据快速定位到对应的<code>SST</code>文件：</p>
<p><img src="lab5/../images/lab3/SST.drawio.png" alt="MemTable-SST" /></p>
<h1 id="2-代码修改"><a class="header" href="#2-代码修改">2 代码修改</a></h1>
<p>现在，我们需要对之前的<code>Lab</code>中涉及到事务操作的函数进行修改, 其实也就是参数列表中包含了<code>tranc_id</code>或者<code>max_tranc_id</code>的函数进行逻辑补全。</p>
<p>本章你需要修改的代码文件：</p>
<ul>
<li>之前<code>Lab</code>中所有涉及<code>tranc_id</code>的函数</li>
</ul>
<blockquote>
<p>注意, 如果<code>tranc_id == 0</code>, 表示当前操作没有开启事务功能, 你的执行逻辑相当于事务不存在</p>
</blockquote>
<h2 id="21-skiplist-部分修改"><a class="header" href="#21-skiplist-部分修改">2.1 SkipList 部分修改</a></h2>
<h3 id="211-put"><a class="header" href="#211-put">2.1.1 put</a></h3>
<p>之前的<code>Skiplist</code>中, 你的实现思路可能是这样的:</p>
<ol>
<li>定位到指定位置</li>
<li>判断是否需要插入
<ol>
<li><code>key</code>不存在则插入</li>
<li><code>key</code>存在则更新</li>
</ol>
</li>
</ol>
<p>现在而言, 以上的逻辑就错误了, 因为之前旧的键值对的记录也需要保留, 其可能会被比当前事务<code>id</code>更小的事务使用, 因此这里就不能进行原位更新了, 而是应该插入一个新的键值对, 同时保留旧的键值对。</p>
<blockquote>
<p>你可以查看 <code>SkiplistNode</code> 的比较运算符重载函数, 看看为什么如此设计</p>
</blockquote>
<h3 id="212-remove"><a class="header" href="#212-remove">2.1.2 remove</a></h3>
<p>由于<code>LSM Tree</code>中的<code>remove</code>就是将插入一个<code>value</code>为空的键值对进行标记, 因此这里的修改逻辑和<code>put</code>类似, 不再赘述。</p>
<h3 id="213-get"><a class="header" href="#213-get">2.1.3 get</a></h3>
<p>加入事务属性后, <code>get</code>函数需要判断查询数据的可见性(也就是实现事务属性中的隔离性), 传入的<code>tranc_id</code>参数表示当前操作所属的事务的<code>id</code>, 因此查询的数据不能是比当前<code>id</code>更大的事务创建的, 如果找到了这样的数据, 你需要进行滤除或跳过。</p>
<p>新的查询逻辑步骤为：
查询时, 我们需要指定一个事务<code>id</code>, 通过<code>id</code>判断如何启用<code>mvcc</code>机制, 目前我们实现的隔离级别只有(<code>读未提交</code>, <code>读已提交</code>, <code>可重复读</code>)</p>
<ol>
<li>若为0表示我们的事务隔离级别是<code>读未提交</code>或<code>读已提交</code>(因为直接查询最新的记录即可, 不需要判断失误<code>id</code>是否合法)</li>
<li>若指定的事务<code>id</code>, 并指定了事务的隔离级别为<code>可重复读</code>, 则需要判断<code>id</code>是否合法, 若不合法, 则返回<code>nullptr</code></li>
</ol>
<blockquote>
<p>本项目只在<code>commit</code>后才将事务更改的键值对加入数据库, 否则只会暂存, 因此<code>读已提交</code>不需要判断事务<code>id</code></p>
</blockquote>
<h3 id="214-iters_monotony_predicate--begin_preffix--end_preffix"><a class="header" href="#214-iters_monotony_predicate--begin_preffix--end_preffix">2.1.4 iters_monotony_predicate &amp;&amp; begin_preffix &amp;&amp; end_preffix</a></h3>
<p>其实这些范围查询等函数也需要进行修改, 但这不是必须的, 因为范围查询函数被上部组件<code>MemTable</code>包裹, 你可以选择在上层组件中统一实现事务<code>id</code>的滤除逻辑。因此这里的更改你可以选择性实现。</p>
<h2 id="22-memtable-部分修改"><a class="header" href="#22-memtable-部分修改">2.2 MemTable 部分修改</a></h2>
<h3 id="221-iters_preffix--iters_monotony_predicate"><a class="header" href="#221-iters_preffix--iters_monotony_predicate">2.2.1 iters_preffix &amp;&amp; iters_monotony_predicate</a></h3>
<p><code>MemTable</code>部分对范围查询是内存部分的最顶级组件了, 在上层就是整个<code>LSM Tree</code>的控制结构<code>LSMEngine</code>了, 因此推荐你在此处根据事务可见性原则对键值对进行滤除。</p>
<p>不过这里也有另一个方案, 我们的返回值类型是<code>std::optional&lt;std::pair&lt;HeapIterator, HeapIterator&gt;&gt;</code>, 因此你也可以在<code>HeapIterator</code>中实现类似的根据事务<code>id</code>的滤除逻辑, 这样上层组件就不需要额外处理了。如果你选择用这种方式的话, <code>HeapIterator</code>的运算符重载、之前标记的<code>skip_by_tranc_id</code>函数都需要更改。</p>
<blockquote>
<p><code>HeapIterator</code>中的更新是强烈推荐你实现的, 因为这个去重+排序的组件你可能会在其他地方进行复用, 因此实现其功能的完善有助于简化复用过程中的数据处理</p>
</blockquote>
<h3 id="222-其余接口"><a class="header" href="#222-其余接口">2.2.2 其余接口</a></h3>
<p>其余接口基本上是对底层<code>Skiplist</code>的封装, 因此你只要更新了<code>Skiplist</code>的接口, <code>MemTable</code>的接口则只需要做简单的参数传递, 不需要额外的更新。</p>
<h2 id="23-block-部分修改"><a class="header" href="#23-block-部分修改">2.3 Block 部分修改</a></h2>
<h3 id="231-add_entry"><a class="header" href="#231-add_entry">2.3.1 add_entry</a></h3>
<p>之前的<code>src/block/block.cpp</code>中的<code>Block::add_entry</code>函数需要写入<code>tranc_id</code>, 当然你大概率已经写入了, 虽然你当时不知道这个<code>tranc_id</code>具体是干嘛的, 如果你之前已经完成了<code>tranc_id</code>的编码, 请跳过这一部分。</p>
<p>除了<code>Block</code>之外, <code>SST</code>的文件编码部分应该只是调用<code>Block</code>的接口, 因此你只需要修改<code>Block</code></p>
<h3 id="232-adjust_idx_by_tranc_id"><a class="header" href="#232-adjust_idx_by_tranc_id">2.3.2 adjust_idx_by_tranc_id</a></h3>
<p>这是之前<code>Lab</code>中标记的一个遗留函数:</p>
<pre><code class="language-cpp">int Block::adjust_idx_by_tranc_id(size_t idx, uint64_t tranc_id) {
  // TODO Lab5.1 找到最接近 tranc_id 的键值对的索引位置
  return -1;
}
</code></pre>
<p>这里说明下这个函数的作用:</p>
<ol>
<li>你进行查询定位时发现<code>idx</code>位置的<code>key</code>是你的目标</li>
<li>但<code>idx</code>位置的<code>tranc_id</code>并不愉参数匹配</li>
</ol>
<p>因此你需要调用<code>adjust_idx_by_tranc_id</code>函数, 找到最接近<code>tranc_id</code>的键值对索引位置。当然, 这里的最接近不能大于指定的事务<code>id</code>。这个辅助函数有助于你实现新的<code>get_idx_binary</code>函数。</p>
<h3 id="233-get_idx_binary"><a class="header" href="#233-get_idx_binary">2.3.3 get_idx_binary</a></h3>
<p><code>get_idx_binary</code>函数用于二分查找定位<code>key</code>在<code>Block</code>中的索引位置, 你需要修改这个函数, 使其能够支持<code>tranc_id</code>的滤除。(可以借助刚刚实现的<code>adjust_idx_by_tranc_id</code>函数)</p>
<h3 id="234-get_monotony_predicate_iters--iters_preffix"><a class="header" href="#234-get_monotony_predicate_iters--iters_preffix">2.3.4 get_monotony_predicate_iters &amp;&amp; iters_preffix</a></h3>
<p>这里的<code>get_monotony_predicate_iters</code>函数需要修改, 使其能够支持<code>tranc_id</code>的滤除。不过和<code>SKiplist</code>中的范围查询类似, <code>Block::get_monotony_predicate_iters</code>会被<code>SST</code>部分的范围查询接口调用, 因此你也可以选择在上层统一实现根据事务<code>id</code>的滤除工作, 这里的实现是可选的。</p>
<h2 id="25-各类迭代器"><a class="header" href="#25-各类迭代器">2.5 各类迭代器</a></h2>
<p>我们实现了多种迭代器都需要在其自增运算符中实现事务<code>id</code>的滤除逻辑, 因此你需要更新的迭代器包括：</p>
<ol>
<li><code>HeapIterator</code></li>
<li><code>BlockIterator</code></li>
<li><code>SSTIterator</code></li>
<li><code>ConcactIterator</code></li>
<li><code>LevelIterator</code></li>
<li><code>TwoMergeIterator</code></li>
</ol>
<p>当然, 你不一定需要再每一个迭代器中都实现类似的逻辑, 以<code>TwoMergeIterator</code>为例, 如果其中的<code>it_a</code>和<code>it_b</code>都实现了基于事务<code>id</code>的滤除功能, 那么<code>TwoMergeIterator</code>就不需要再实现一次了。</p>
<blockquote>
<p>不过这里<code>it_a</code>和<code>it_b</code>都是基类<code>BaseIterator</code>的指针, 因此你如果想要少实现这个逻辑, 需要好好地进行设计, 提供其是否实现了滤除逻辑的接口。当然，你在所有迭代器全部都实现一次这个滤除逻辑是最保险的做法。</p>
</blockquote>
<h2 id="26-engine部分修改"><a class="header" href="#26-engine部分修改">2.6 Engine部分修改</a></h2>
<p><code>LSMEngine</code>的大部分接口都是对下层组件(包括<code>MemTable</code>、<code>SST</code>等)的封装, 因此你只需要想对应的接口传递正确的<code>tranc_id</code>即可, 不需要额外的修改。</p>
<p>这里只有范围查询(谓词查询)需要你注意, 这里是对包括谓词查询、前缀查询等接口的最顶层封装, 你需要在上层组件中实现根据事务<code>id</code>的滤除逻辑。</p>
<h2 id="27-其余部分修改"><a class="header" href="#27-其余部分修改">2.7 其余部分修改</a></h2>
<p>作者列出了大部分在引入事务<code>id</code>后需要修改的代码部分, 但由于每个人在之前的<code>Lab</code>中实现的方案不同, 因此你可能还需要在其他地方进行一些修修补补。</p>
<blockquote>
<p>TODO: 这一部分给参与者的自由度稍高, 引导可能也弱了一点, 后续版本更新的指导书应该加以改正</p>
</blockquote>
<h1 id="3-测试-9"><a class="header" href="#3-测试-9">3 测试</a></h1>
<p>由于事务功能的耦合度较高, 因此现在还没有办法进行单元测试, 你可以按照自己的需要编写测试用例进行测试, 测试用例的编写思路和之前的<code>Lab</code>类似, 你可以参考<code>src/test</code>中的测试用例进行编写。</p>
<p>不过别忘了我们在<a href="lab5/../lab1/lab1.3-range-query.html">Lab 1.3</a>中先搁置的<code>SkipListTest.TransactionId</code>单元测试, 此时你应该可以通过这个单元测试测例。</p>
<blockquote>
<p>TODO: 后续版本中补全这里的阶段性测试, 而不是2个Lab完成后才有一个大测试</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-52-引入事务-id"><a class="header" href="#lab-52-引入事务-id">Lab 5.2 引入事务 ID</a></h1>
<p>之前我们已经对各个组件的接口进行了统一, 添加了<code>tranc_id</code>这个事务id参数, 接下来这个章节, 我们将介绍顶层的事务设计, 即事务id是如何生成的, 实现相关的事务管理器。</p>
<h1 id="1-事务的设计思想"><a class="header" href="#1-事务的设计思想">1 事务的设计思想</a></h1>
<p>我们先给出一个完成后的<code>demo</code>, 演示我们的事务设计是如何工作的, 代码如下:</p>
<pre><code class="language-cpp">#include "../include/lsm/engine.h"
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  // create lsm instance, data_dir is the directory to store data
  LSM lsm("example_data");

  // put data
  lsm.put("key1", "value1");

  // Query data
  auto value1 = lsm.get("key1");
    std::cout &lt;&lt; "key1: " &lt;&lt; value1.value() &lt;&lt; std::endl;


  // transaction
  auto tranc_hanlder = lsm.begin_tran();
  tranc_hanlder-&gt;put("xxx", "yyy");
  tranc_hanlder-&gt;put("yyy", "xxx");
  tranc_hanlder-&gt;commit();

  auto res = lsm.get("xxx");
  std::cout &lt;&lt; "xxx: " &lt;&lt; res.value() &lt;&lt; std::endl;

  lsm.clear();

  return 0;
}
</code></pre>
<p>这里我们可以通过一个<code>begin_tran</code>函数获取一个事务的处理句柄, 然后通过这个句柄进行增删改查操作, 最后通过<code>commit</code>或<code>abort</code>函数完成提交事务或终结事务的流程.</p>
<p>现在我们要完成的就是接受<code>begin_tran</code>的事务管理器. 这里有一些设计问题我们需要提前明确:</p>
<ol>
<li><code>begin_tran</code>获取的事务句柄肯定会分配一个事务<code>id</code>, 那么没有开启事务的<code>put/get/remove</code>操作的事务<code>id</code>是什么呢?</li>
<li><code>begin_tran</code>进行增删改查的操作如何保证不同事务的隔离性?</li>
</ol>
<p>首先回答第一个问题, 我们可以使用一个全局的<code>atomic</code>变量来作为事务id, 这个变量在每次调用<code>begin_tran</code>或<code>put/get/remove</code>时自增, 这样就可以保证每个事务或单次操作都有一个唯一的<code>tranc_id</code>(这里的<code>tranc_id</code>和事务<code>id</code>是同义词). 换句话说, 普通的<code>put/get/remove</code>就是操作数量为1的简单事务。</p>
<p>然后是第二个问题，这实际上取决于我们的事务隔离级别:</p>
<ol>
<li><code>Read Uncommitted</code>: 允许读取未提交的数据, 也就是脏读. 这种情况下, 我们可以将事务的句柄(案例代码中的<code>tranc_hanlder</code>)进行增删改查的数据直接写入到<code>memtable</code>中, 这样就可以让其他的事务可以从<code>memtable</code>中读取到未提交的数据, 速度肯定很快. 但是这里有一个场景需要尤其注意, 就是我们事务<code>rokkback</code>(或者是<code>abort</code>)时, 必须撤销已经写入到<code>memtable</code>的数据, 因此这里需要我们记录事务的操作记录和以前的历史记录, 然后在<code>abort</code>时, 将<code>memtable</code>中的数据进行回滚.</li>
<li><code>Read Committed</code>: 允许读取已提交的数据, 也就是不可脏读. 这种情况下, 我们可以将事务的句柄(案例代码中的<code>tranc_hanlder</code>)进行增删改查的数据暂存到句柄的上下文, 因此其他事务从<code>memtable</code>中是查不到这个事务未提交的数据的, 但这个事务自身查询时可以从自己的上下文中读取到未提交的数据.</li>
<li><code>Repeatable Read</code>: 在<code>Read Committed</code>的基础上解决了不可重复读的问题, 也就是在同一个事务中, 多次读取同一数据的结果是一样的. 这种情况下, 我们可以将每次<code>get</code>的数据同样暂存到句柄的上下文, 后续查询相同的<code>key</code>时, 从上下文中读取到相同的数据.</li>
<li><code>Serializable</code>: 这个这个事务隔离级别我们在关系型数据库中是进一步解决<code>幻读</code>现象的, 例如: 在<code>Repeatable Read</code>隔离级别下，事务A读取了年龄&gt;30的员工，得到10条记录。此时事务B插入了一个年龄31的新员工并提交。事务A再次读取同样的条件，可能会看到11条记录（幻读）。但在<code>Serializable</code>隔离级别下，事务B的插入会被阻塞或者事务A的两次读取结果保持一致，避免幻读。在我们的<code>KV</code>数据库中, 我们只需要保证事务提交时进程冲突检查、且按照事务<code>id</code>的顺序依次提交即可(虽然这样性能很低)。</li>
</ol>
<h1 id="2-事务管理器的设计方案"><a class="header" href="#2-事务管理器的设计方案">2 事务管理器的设计方案</a></h1>
<h2 id="21-组件关系设计"><a class="header" href="#21-组件关系设计">2.1 组件关系设计</a></h2>
<p>还记得我们之前实现的<code>LSm</code>和<code>LSMEngine</code>吗? 当时我们将<code>LSMEngine</code>包裹在<code>LSM</code>中, <code>LSMEngine</code>中封装了<code>memtable</code>, <code>sst</code>等组件, 我们却进一步将其封装在<code>LSM</code>中, 这样的目的就是在后续中加入其他同级别的组件, 例如本章的事务管理器, <code>LSM</code>的定义为:</p>
<pre><code class="language-cpp">class LSM {
private:
  std::shared_ptr&lt;LSMEngine&gt; engine;
  std::shared_ptr&lt;TranManager&gt; tran_manager_;

public:
  // ...
};
</code></pre>
<p>这里我们对<code>LSMEngine</code>和<code>TranManager</code>都使用了<code>shared_ptr</code>进行封装。<code>LSMEngine</code>我们之前已经介绍过了，而<code>TranManager</code>就是本章我们要实现的事务管理器。</p>
<h2 id="21-功能1-分配事务-id"><a class="header" href="#21-功能1-分配事务-id">2.1 功能1-分配事务 id</a></h2>
<p>首先事务管理器的基础职责之一就是分配事务<code>id</code>, 我们看看其中一个<code>put</code>接口:</p>
<pre><code class="language-cpp">class TranManager : public std::enable_shared_from_this&lt;TranManager&gt; {
public:
  // ...

  uint64_t getNextTransactionId();
  // ...

private:
  mutable std::mutex mutex_;
  std::shared_ptr&lt;LSMEngine&gt; engine_;
  std::shared_ptr&lt;WAL&gt; wal; // 暂时忽略
  std::string data_dir_;
  // std::atomic&lt;bool&gt; flush_thread_running_ = true; // 废弃的设计方案
  std::atomic&lt;uint64_t&gt; nextTransactionId_ = 1;
  std::atomic&lt;uint64_t&gt; max_flushed_tranc_id_ = 0;
  std::atomic&lt;uint64_t&gt; max_finished_tranc_id_ = 0;
  std::map&lt;uint64_t, std::shared_ptr&lt;TranContext&gt;&gt; activeTrans_;
  FileObj tranc_id_file_;
};

void LSM::put(const std::string &amp;key, const std::string &amp;value) {
  auto tranc_id = tran_manager_-&gt;getNextTransactionId();
  engine-&gt;put(key, value, tranc_id);
}
</code></pre>
<p>这里顺带补充我们的查询接口的设计, 你可以看到, 在没有开启事务的情况下, 即时是一次简单的<code>put</code>操作都会分配一个事务<code>id</code>, 因此这里的<code>tranc_id</code>是必须的, 其并不独属于我们的事务模块, 只是简单的<code>put/get/remove</code>操作数量只有一个而已(或者是一次性的<code>batch</code>接口, 总之不会有多步骤的操作)</p>
<h2 id="22-功能2-分配事务上下文"><a class="header" href="#22-功能2-分配事务上下文">2.2 功能2-分配事务上下文</a></h2>
<p>回顾我们之前的Demo:</p>
<pre><code class="language-cpp">auto tranc_hanlder = lsm.begin_tran();
</code></pre>
<p>这里的<code>begin_tran</code>会返回一个事务上下文(或者叫事务句柄也行), 我们可以在这个上下文中进行增删改查操作, 然后通过<code>commit</code>或<code>abort</code>函数完成提交事务或终结事务的流程. 我们看看这个上下文的定义:</p>
<pre><code class="language-cpp">class TranContext {
  friend class TranManager;

public:
  TranContext(uint64_t tranc_id, std::shared_ptr&lt;LSMEngine&gt; engine,
              std::shared_ptr&lt;TranManager&gt; tranManager,
              const enum IsolationLevel &amp;isolation_level);
  void put(const std::string &amp;key, const std::string &amp;value);
  void remove(const std::string &amp;key);
  std::optional&lt;std::string&gt; get(const std::string &amp;key);

  // ! test_fail = true 是测试中手动触发的崩溃
  bool commit(bool test_fail = false);
  bool abort();
  enum IsolationLevel get_isolation_level();

public:
  std::shared_ptr&lt;LSMEngine&gt; engine_;
  std::shared_ptr&lt;TranManager&gt; tranManager_;
  uint64_t tranc_id_;
  std::vector&lt;Record&gt; operations;
  std::unordered_map&lt;std::string, std::string&gt; temp_map_;
  bool isCommited = false;
  bool isAborted = false;
  enum IsolationLevel isolation_level_;

private:
  std::unordered_map&lt;std::string,
                     std::optional&lt;std::pair&lt;std::string, uint64_t&gt;&gt;&gt;
      read_map_;
  std::unordered_map&lt;std::string,
                     std::optional&lt;std::pair&lt;std::string, uint64_t&gt;&gt;&gt;
      rollback_map_;
};
</code></pre>
<p>可以看到, 事务上下文主要包含以下内容:</p>
<ol>
<li><code>tranc_id_</code>: 事务<code>id</code></li>
<li><code>engine_</code>: <code>LSM</code>引擎的指针, 需要保证其在自身生命周期内有效</li>
<li><code>tranManager_</code>: 事务管理器的指针, 需要保证其在自身生命周期内有效</li>
<li><code>operations</code>: 事务操作记录, 也就是后续转化为<code>WAL</code>日志的内容</li>
<li><code>temp_map_</code>: 事务上下文中的临时数据, 主要是实现事务的隔离性, 例如<code>Read Committed</code>和<code>Repeatable Read</code>隔离级别下, 我们需要将<code>get</code>的数据暂存到这个临时数据中, 避免被其他事务读取到未提交的数据</li>
<li><code>rollback_map_</code>: 事务回滚记录, 主要用于事务的回滚</li>
</ol>
<h2 id="23-功能3-事务状态的维护"><a class="header" href="#23-功能3-事务状态的维护">2.3 功能3-事务状态的维护</a></h2>
<p>我们继续看我们定义的事务管理器的其他成员:</p>
<pre><code class="language-cpp">```cpp
class TranManager : public std::enable_shared_from_this&lt;TranManager&gt; {
private:
  mutable std::mutex mutex_;
  std::shared_ptr&lt;LSMEngine&gt; engine_;
  std::shared_ptr&lt;WAL&gt; wal; // 暂时忽略
  std::string data_dir_;
  // std::atomic&lt;bool&gt; flush_thread_running_ = true; // 废弃的设计方案
  std::atomic&lt;uint64_t&gt; nextTransactionId_ = 1;
  std::atomic&lt;uint64_t&gt; max_flushed_tranc_id_ = 0;
  std::atomic&lt;uint64_t&gt; max_finished_tranc_id_ = 0;
  std::map&lt;uint64_t, std::shared_ptr&lt;TranContext&gt;&gt; activeTrans_;
  FileObj tranc_id_file_;
};
</code></pre>
<p>这里我们关注几个<code>std::atomic&lt;uint64_t</code>类型的原子变量, 他们的作用和含义解释如下:</p>
<ol>
<li>负责记录当前事务完成状态:
<ol>
<li><code>max_flushed_tranc_id_</code>: 最大的已经刷入<code>sst</code>中的事务</li>
<li><code>max_finished_tranc_id_</code>: 最大的已经完成的事务(但数据可能还存在于内存中)</li>
<li><code>nextTransactionId_</code>: 下一个分配事务的<code>id</code></li>
</ol>
</li>
<li>负责事务状态的持久化操作</li>
</ol>
<p>这里特别进行说明, 为什么要负责是事务的持久化操作, 因为我们后续会实现<code>WAL</code>(Write Ahead Log), 这个日志会记录每次的操作, 当我们的数据库崩溃后重启时, 会根据<code>WAL</code>中的操作记录进行恢复, 这里的操作记录是指<code>put</code>、<code>remove</code>等操作, 但是我们需要在重启时知道哪些操作是已经完成的, 哪些操作是未完成的, 因此我们需要在<code>WAL</code>中记录每个事务的状态, 这个状态就是<code>max_flushed_tranc_id_</code>, 因此在重放<code>WAL</code>的操作时, 我们需要根据这个状态来判断哪些操作是已经完成的, 哪些操作是未完成的。</p>
<h1 id="3-代码实现-1"><a class="header" href="#3-代码实现-1">3 代码实现</a></h1>
<p>这里我们进入今天的主题, 如何实现不同隔离级别下的事务操作。</p>
<p>本小节实验中，你需要修改的代码为：</p>
<ul>
<li><code>src/lsm/engine.cpp</code> (Optional, 你也许会自行设计<code>LSM</code>类中<code>TranManager</code>的初始化逻辑)</li>
<li><code>src/lsm/transation.cpp</code></li>
<li><code>include/lsm/transaction.h</code></li>
</ul>
<h2 id="31-事务上下文的创建和分配"><a class="header" href="#31-事务上下文的创建和分配">3.1 事务上下文的创建和分配</a></h2>
<h3 id="311-事务上下文的构造函数"><a class="header" href="#311-事务上下文的构造函数">3.1.1 事务上下文的构造函数</a></h3>
<p>这里我们从事务上下文的生命周期的历程逐步实现其关键的接口, 首先是构造函数:</p>
<pre><code class="language-cpp">TranContext::TranContext(uint64_t tranc_id, std::shared_ptr&lt;LSMEngine&gt; engine,
                         std::shared_ptr&lt;TranManager&gt; tranManager,
                         const enum IsolationLevel &amp;isolation_level) {
  // TODO: Lab 5.2 构造函数初始化
}
</code></pre>
<h3 id="312-事务上下文的分配"><a class="header" href="#312-事务上下文的分配">3.1.2 事务上下文的分配</a></h3>
<p>有了<code>TranContext</code>的构造函数中, 我们可以在<code>TranManager::new_tranc</code>接受外部请求完成事务上下文的分配:</p>
<pre><code class="language-cpp">std::shared_ptr&lt;TranContext&gt;
TranManager::new_tranc(const IsolationLevel &amp;isolation_level) {
  // TODO: Lab 5.2 事务上下文分配
  return nullptr;
}
</code></pre>
<p>介于之前已经进行了详细的理论介绍, 这里就不过多介绍你需要进行哪些元数据的记录操作了。此外，类定义中的成员变量你不一定需要全部使用，你可以按照自己的理解选择性地使用预定义的成员变量，也可以自行添加新的成员变量。</p>
<h2 id="32-事务上下文的接口"><a class="header" href="#32-事务上下文的接口">3.2 事务上下文的接口</a></h2>
<p>接下来是本小节内容的最重要部分，事务上下文接口的实现。这里不同隔离级别的事务操作实现会有所不同，你需要根据不同的事务隔离级别完成不同的<code>CRUD</code>逻辑:</p>
<blockquote>
<p>以下的接口在实现<code>WAL</code>后, 你需要在实现接口时考虑<code>WAL</code>的持久化操作, 本实验中你暂时不需要考虑<code>WAL</code>的持久化操作。</p>
</blockquote>
<h3 id="321-put"><a class="header" href="#321-put">3.2.1 put</a></h3>
<pre><code class="language-cpp">void TranContext::put(const std::string &amp;key, const std::string &amp;value) {
  // TODO: Lab 5.2 put 实现
}
</code></pre>
<p>这里有几个点需要你考虑:</p>
<ol>
<li>事务的可见性设计:
<ol>
<li><code>put</code>操作如何实现对其他事务的可见性?</li>
<li><code>put</code>操作如何实现对其他事务的隔离性?</li>
</ol>
</li>
<li>回滚设计
<ol>
<li>如果事务最后需要回滚, 如何实现?</li>
<li>回滚是否需要额外的数据结构?</li>
</ol>
</li>
</ol>
<h3 id="322-get"><a class="header" href="#322-get">3.2.2 get</a></h3>
<pre><code class="language-cpp">void TranContext::remove(const std::string &amp;key) {
  // TODO: Lab 5.2 remove 实现
}
</code></pre>
<p>由于<code>remove</code>本质上也是<code>put</code>, 因此这里的逻辑和<code>put</code>类似, 这里就不做过多解释了。</p>
<h3 id="323-get"><a class="header" href="#323-get">3.2.3 get</a></h3>
<pre><code class="language-cpp">std::optional&lt;std::string&gt; TranContext::get(const std::string &amp;key) {
  // TODO: Lab 5.2 get 实现
  return {};
}
</code></pre>
<p>这里需要考虑:</p>
<ol>
<li>如果是<code>Read UnCommitted</code>隔离级别, 需要考虑如何读取到最新的修改记录</li>
<li>如果是<code>Read Committed</code>隔离级别, 需要考虑如何避免读取到未提交的数据</li>
<li>如果是<code>Repeatable Read</code>隔离级别, 需要考虑如何避免不可重复读现象</li>
</ol>
<h3 id="324-commit"><a class="header" href="#324-commit">3.2.4 commit</a></h3>
<pre><code class="language-cpp">bool TranContext::commit(bool test_fail) {
  // TODO: Lab 5.2 commit 实现
  return true;
}
</code></pre>
<p><code>commit</code>函数应该是这里最复杂的, 这里的重点就是实现事务提交时的冲突检测, 如果检测无冲突且<code>WAL</code>持久化成功(后续<code>Lab</code>的内容), 返回<code>true</code>表示成功提交, 否则返回<code>false</code>表示提交失败。</p>
<p>本实验的设计采用了类似<code>乐观锁</code>的思想, 所有事务的更新记录只有在提交时才会进行冲突检测, 其逻辑为:</p>
<ol>
<li>如果隔离级别是<code>READ_UNCOMMITTED</code>, 因为之前就已经将更改的数据写入了<code>MemTable</code>, 现在只需要直接写入<code>wal</code>一个<code>Commit</code>记录(目前不涉及, 可先跳过)</li>
<li>如果隔离级别是<code>REPEATABLE_READ</code>或<code>SERIALIZABLE</code>, 需要遍历所有的操作记录, 判断是否存在冲突, 如果存在冲突则终止事务, 否则将所有的操作记录写入<code>wal</code>中, 然后将数据应用到数据库中</li>
<li>完成事务数据同步到<code>MemTable</code>后, 更新<code>max_finished_tranc_id_</code>并持久化数据</li>
</ol>
<blockquote>
<p>这里需要注意的是, 你在进行冲突检测时, <code>MemTable</code>和<code>SST</code>部分此时应该是不允许写入的, 否则存在并发冲突。这里你的加锁行为可能是类似侵入式的做法（即手动对其他类的内部成员变量进行加锁）</p>
<p>同样地, 这里设计<code>WAL</code>的部分可以先跳过</p>
</blockquote>
<h3 id="325-abort"><a class="header" href="#325-abort">3.2.5 abort</a></h3>
<p><code>abort</code> 方法用于回滚事务，具体的回滚逻辑取决于你之前对<code>put</code>函数的设计:</p>
<pre><code class="language-cpp">bool TranContext::abort() {
  // TODO: Lab 5.2 abort 实现
  return true;
}
</code></pre>
<p>这里同样用<code>true</code>表示成功回滚, 否则返回<code>false</code>表示回滚失败。</p>
<blockquote>
<p>在<code>commit</code>函数的冲突检测失败后, 也需要进行回滚操作, 不过其回滚是被动的</p>
<p>而<code>abort</code>函数是<code>client</code>主动发起的回滚操作</p>
</blockquote>
<h2 id="33-事务状态的维护"><a class="header" href="#33-事务状态的维护">3.3 事务状态的维护</a></h2>
<p>之前提到过, <code>TranManager</code>中定义了几个<code>std::atomic&lt;uint64_t&gt;</code>类型的原子变量, 这些变量用于记录事务的状态, 在事务的提交和回滚时, 需要更新这些变量的值, 以便在重启时进行恢复:</p>
<pre><code class="language-cpp">void TranManager::write_tranc_id_file() {
  // TODO: Lab 5.2 持久化事务状态信息
}

void TranManager::read_tranc_id_file() {
  // TODO: Lab 5.2 读取持久化的事务状态信息
}

void TranManager::update_max_finished_tranc_id(uint64_t tranc_id) {
  // TODO: Lab 5.2 更新持久化的事务状态信息
}

void TranManager::update_max_flushed_tranc_id(uint64_t tranc_id) {
  // TODO: Lab 5.2 更新持久化的事务状态信息
}
</code></pre>
<blockquote>
<p>在你操作原子变量时可以不使用锁而实现并发安全性, 不过你需要了解<a href="https://en.cppreference.com/w/cpp/atomic/memory_order"><strong>内存顺序</strong></a>的概念</p>
</blockquote>
<p>完成上面的持久化操作后, 你在存储引擎启动后也需要从持久化的文件中恢复这些元信息:</p>
<pre><code class="language-cpp">TranManager::TranManager(std::string data_dir) : data_dir_(data_dir) {
  auto file_path = get_tranc_id_file_path();

  // TODO: Lab 5.2 初始化时读取持久化的事务状态信息
}
</code></pre>
<p>试想, 你在第一次存储要求启动时进行了若干操作, 事务<code>id</code>已经分配到了100, 而之后你重启了数据库, 此时事务<code>id</code>如果又从0开始分配, 而不是从100开始分配, 会发生什么问题?</p>
<h1 id="4-测试-5"><a class="header" href="#4-测试-5">4 测试</a></h1>
<p>现在除了崩溃恢复的部分外, 你应该可以通过所有的<code>test_lsm</code>的测试:</p>
<pre><code class="language-bash">✗ xmake
[100%]: build ok, spent 0.595s
✗ xmake run test_lsm
[==========] Running 9 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 9 tests from LSMTest
[ RUN      ] LSMTest.BasicOperations
[       OK ] LSMTest.BasicOperations (10 ms)
[ RUN      ] LSMTest.Persistence
[       OK ] LSMTest.Persistence (1600 ms)
[ RUN      ] LSMTest.LargeScaleOperations
[       OK ] LSMTest.LargeScaleOperations (17 ms)
[ RUN      ] LSMTest.MixedOperations
[       OK ] LSMTest.MixedOperations (8 ms)
[ RUN      ] LSMTest.IteratorOperations
[       OK ] LSMTest.IteratorOperations (9 ms)
[ RUN      ] LSMTest.MonotonyPredicate
[       OK ] LSMTest.MonotonyPredicate (17 ms)
[ RUN      ] LSMTest.TrancIdTest
[       OK ] LSMTest.TrancIdTest (8 ms)
[ RUN      ] LSMTest.TranContextTest
[       OK ] LSMTest.TranContextTest (8 ms)
[ RUN      ] LSMTest.Recover
unknown file: Failure
C++ exception with description "bad optional access" thrown in the test body.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阶段2-wal和崩溃恢复"><a class="header" href="#阶段2-wal和崩溃恢复">阶段2-WAL和崩溃恢复</a></h1>
<p>首先恭喜你进入了<code>WAL</code>与包括恢复的阶段, 这一阶段是我们本课程早轮子部分的最后一个阶段, 再之后就是偏向业务层的<code>Redis</code>协议兼容了。</p>
<p>本阶段你将学习到</p>
<ul>
<li><code>WAL</code>的编解码设计</li>
<li>利用<code>WAL</code>进行崩溃恢复的策略</li>
</ul>
<blockquote>
<p>本实验的崩溃恢复是一个简易的实现</p>
</blockquote>
<blockquote>
<p>提示: 强烈建议你自己创建一个分组实现<code>Lab</code>的内容, 并在每次新的<code>Lab</code>开始时进行如下同步操作:</p>
<pre><code class="language-bash">git pull origin lab
git checkout your_branch
git merge lab
</code></pre>
<p>如果你发现项目仓库的代码没有指导书中的 TODO 标记的话, 证明你需要运行上述命令更新代码了</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-53-wal日志编解码"><a class="header" href="#lab-53-wal日志编解码">Lab 5.3 WAL日志编解码</a></h1>
<p>之前我们已经完成了数据库内存中和编码文件中事务信息的融入, 现在我们还需要加上<code>WAL</code>与崩溃恢复的内容。
这一小节我们主要对<code>WAL</code>中的单条日志记录 (即<code>Record</code>) 进行编解码设计和实现。</p>
<h1 id="1-record-编码设计"><a class="header" href="#1-record-编码设计">1 Record 编码设计</a></h1>
<h2 id="11-wal简介"><a class="header" href="#11-wal简介">1.1 WAL简介</a></h2>
<p>这里首先简单介绍下<strong>WAL（预写式日志）</strong> , <strong>WAL（预写式日志）</strong> 是数据库系统中保障数据一致性和事务可靠性的核心技术，核心思想是“<strong>日志先行</strong>”——任何数据修改必须先记录到日志中，确保日志持久化后，才允许实际数据写入磁盘。这种机制解决了两个关键问题：一是保证已提交的事务不会因系统崩溃而丢失（持久性），二是确保事务要么完全生效、要么完全回滚（原子性）。</p>
<p>具体来说，当一个事务提交时，数据库会先将事务的修改操作（例如数据修改前后的值、事务状态等）按顺序写入日志文件，并强制将日志刷到磁盘存储。由于日志是顺序写入，相比随机修改数据页的I/O操作，这种设计大幅提升了性能。之后，数据库可以灵活地将内存中的脏页批量刷新到磁盘，减少磁盘操作次数。</p>
<p>如果系统崩溃，重启后可通过日志恢复数据。恢复分为两个阶段：<strong>Redo</strong> 阶段会重放所有已提交但未落盘的日志，确保事务修改生效；<strong>Undo</strong> 阶段则回滚未提交事务的部分修改，消除中间状态。为了加速恢复，数据库会定期创建<strong>检查点（Checkpoint）</strong>，将当前内存中的脏页刷盘，并记录日志位置，这样恢复时只需处理检查点之后的日志。</p>
<p>WAL的优势不仅在于数据安全，还在于其高性能和可扩展性。例如，PostgreSQL、MySQL InnoDB等数据库依赖WAL实现事务和崩溃恢复；分布式系统（如Raft算法）也借鉴类似思想，通过日志复制保证一致性。不过，WAL的日志文件可能快速增长，需要定期清理或归档，且频繁刷盘可能带来性能损耗，因此在实际应用中需权衡同步/异步提交等策略。</p>
<h2 id="12-文件格式设计"><a class="header" href="#12-文件格式设计">1.2 文件格式设计</a></h2>
<p>根据之前的介绍, 我们的<code>WAL</code>文件中需要满足如下功能:</p>
<ol>
<li>描述事务的开始和结束</li>
<li>描述每次事务的操作内容</li>
</ol>
<p>在<code>KV</code>存储引擎这个领域, <code>WAL</code>的设计已经比关系型数据库简单很多了, 因为其操作类型就只有简单的基于键值对的<code>put/get/remove</code>. 与之相反, 关系型数据库的<code>WAL</code>就复杂很多了, 还涉及到物理日志和逻辑日志的区别</p>
<p>在KV存储引擎中，<code>WAL</code>的设计需要满足简洁性和高效性。由于操作类型仅限于<code>put</code>、<code>remove</code>（<code>get</code>通常不涉及数据修改，因此无需记录），日志结构可以大幅简化。以下是具体的设计要点：</p>
<p>每个日志条目需包含以下核心信息：</p>
<ol>
<li><strong>事务标识（Transaction ID）</strong>：唯一标识事务的ID，用于关联多个操作。</li>
<li><strong>操作类型（Operation Type）</strong>：如<code>PUT</code>、<code>REMOVE</code>、<code>GET</code>、<code>BEGIN</code>、<code>COMMIT</code>、<code>ABORT</code>等。</li>
<li><strong>键（Key）</strong>：操作的键值。</li>
<li><strong>值（Value）</strong>：对于<code>PUT</code>操作记录具体值；</li>
<li><strong>校验和（Checksum）(可选)</strong>：用于验证日志条目的完整性（如CRC32）。</li>
<li><strong>时间戳（可选）</strong>：记录操作时间，用于多版本控制或冲突解决。</li>
</ol>
<p>这样，我们可以通过每一个日志条目判断这个操作类型和数据、是哪一个事务进行操作。同时， 由于我们在上一章中将数据库的事务完成状态也进行了持久化, 因此在崩溃恢复时, 我们可以通过检查当前<code>WAL</code>条目的事务<code>id</code>和以刷盘的事务的状态进行对比, 来判断是否需要重放操作。</p>
<h2 id="13-record-代码概览"><a class="header" href="#13-record-代码概览">1.3 Record 代码概览</a></h2>
<p>基于我们之前的描述, 我们来看看<code>Record</code>中每一类记录项的定义:</p>
<pre><code class="language-cpp">// include/wal/record.h
class Record {
private:
  // 构造函数
  Record() = default;

public:
  // 操作类型枚举

  static Record createRecord(uint64_t tranc_id);
  static Record commitRecord(uint64_t tranc_id);
  static Record rollbackRecord(uint64_t tranc_id);
  static Record putRecord(uint64_t tranc_id, const std::string &amp;key,
                          const std::string &amp;value);
  static Record deleteRecord(uint64_t tranc_id, const std::string &amp;key);

  // 编码记录
  std::vector&lt;uint8_t&gt; encode() const;

  // 解码记录
  static std::vector&lt;Record&gt; decode(const std::vector&lt;uint8_t&gt; &amp;data);

  // ...

private:
  uint64_t tranc_id_;
  OperationType operation_type_;
  std::string key_;
  std::string value_;
  uint16_t record_len_;
};
</code></pre>
<p>这里展示了几个关键的成员变量和成员函数, 这里的<code>Record</code>表示的就是<code>WAL</code>中的单个日志条目, 操作类型为<code>OperationType</code>, 通过<code>OperationType</code>可以判断其是否有<code>key</code>, <code>value</code>等附加数据信息。同时，我们通过静态成员函数<code>createRecord</code>, <code>putRecord</code>等构造类的实例。最后，<code>encode</code>和<code>decode</code>函数用于将记录转换为字节流和从字节流恢复记录。</p>
<blockquote>
<p>这里的构造函数被标记为<code>private</code>, 你需要使用<code>createRecord</code>等静态成员函数来构造<code>Record</code>的实例。</p>
</blockquote>
<h2 id="14-record-文件格式"><a class="header" href="#14-record-文件格式">1.4 Record 文件格式</a></h2>
<p><code>Record</code>仅仅是内存中的一个类, 且其会因记录类型的不同导致占据的内存大小不同, 因此我们需要将采用某种编码格式将其序列化到磁盘上, 以便在崩溃恢复时能够从磁盘上恢复出<code>Record</code>。这里我们采用一种简单的序列化方式, 将每一个<code>Record</code>的长度和内容依次写入磁盘, 具体格式如下:</p>
<pre><code class="language-text">| record_len | tranc_id | operation_type | key_len(optional) | key(optional) | value_len(optional) | value(optional) |
</code></pre>
<p>这里, 当<code>operation_type</code>是<code>CREATE</code>, <code>ROLLBACK</code>, <code>COMMIT</code>时, 只需要记录<code>tranc_id</code>和<code>operation_type</code>即可, 其余的<code>optional</code>部分不存在, 当<code>operation_type</code>是<code>PUT</code>时, 需要记录<code>tranc_id</code>, <code>operation_type</code>, <code>key</code>, <code>value</code>; 当<code>operation_type</code>是<code>DELETE</code>时, 需要记录<code>tranc_id</code>, <code>operation_type</code>, <code>key</code>。'</p>
<p>每个条目的第一部分是<code>record_len</code>, 其记录了整个日志条目的长度(16位)。这里的编解码需要注意一下，<code>encode</code>函数是以单个<code>Record</code>为单位, 将其编码为字节流, 而<code>decode</code>函数是以字节流为单位, 将其解码为<code>Record</code>数组。</p>
<h1 id="2-代码实现-9"><a class="header" href="#2-代码实现-9">2 代码实现</a></h1>
<p>现在你已经了解了<code>Record</code>的设计和编码格式, 接下来你需要实现<code>Record</code>的基础构造函数和编解码函数。</p>
<p>你需要修改的文件包括：</p>
<ul>
<li><code>src/wal/record.cpp</code></li>
<li><code>include/wal/record.h</code> (Optional)</li>
</ul>
<h2 id="21-构造函数"><a class="header" href="#21-构造函数">2.1 构造函数</a></h2>
<p>这里的构造函数其实是一系列静态函数, 其们会根据不同的操作类型构造不同的<code>Record</code>实例, 你需要实现这些静态函数:</p>
<pre><code class="language-cpp">Record Record::createRecord(uint64_t tranc_id) {
  // TODO: Lab 5.3 实现创建事务的Record
  return {};
}
Record Record::commitRecord(uint64_t tranc_id) {
  // TODO: Lab 5.3 实现提交事务的Record
  return {};
}
Record Record::rollbackRecord(uint64_t tranc_id) {
  // TODO: Lab 5.3 实现回滚事务的Record
  return {};
}
Record Record::putRecord(uint64_t tranc_id, const std::string &amp;key,
                         const std::string &amp;value) {
  // TODO: Lab 5.3 实现插入键值对的Record
  return {};
}
Record Record::deleteRecord(uint64_t tranc_id, const std::string &amp;key) {
  // TODO: Lab 5.3 实现删除键值对的Record
  return {};
}
</code></pre>
<blockquote>
<p>之所以这样设计, 是因为不同类型的<code>Record</code>的成员变量数量不同, 比如<code>CREATE</code>类型的<code>Record</code>只需要<code>tranc_id</code>和<code>operation_type</code>两个成员变量, 而<code>PUT</code>类型的<code>Record</code>则需要<code>tranc_id</code>, <code>operation_type</code>, <code>key</code>, <code>value</code>四个成员变量, 因此我们通过静态函数来构造不同的<code>Record</code>实例, 这样可以避免构造函数的参数过多。</p>
</blockquote>
<h2 id="22-编解码函数"><a class="header" href="#22-编解码函数">2.2 编解码函数</a></h2>
<p>接下来是接触的编解码函数, 这里你只需要编解码成字节数组即可, 文件IO相关操作你在下一个<code>Lab</code>实现:</p>
<pre><code class="language-cpp">std::vector&lt;uint8_t&gt; Record::encode() const {
  // TODO: Lab 5.3 实现Record的编码函数
  return {};
}

std::vector&lt;Record&gt; Record::decode(const std::vector&lt;uint8_t&gt; &amp;data) {
  // TODO: Lab 5.3 实现Record的解码函数
  return {};
}
</code></pre>
<blockquote>
<p>TODO: 初版实验代码中, <code>encode</code>和<code>decode</code>是针对单个<code>Record</code>进行的, 后续版本应进行改进, 使编解码的数据以<code>std::vector&lt;Record&gt;</code>为单位, 这样可以避免内存的频繁分配和释放。</p>
</blockquote>
<h1 id="3-测试-10"><a class="header" href="#3-测试-10">3 测试</a></h1>
<p>本小节没有单元测试, 你在完成下一小节后会有统一的单元测试。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-54-wal-运行机制"><a class="header" href="#lab-54-wal-运行机制">Lab 5.4 WAL 运行机制</a></h1>
<p>上一小节的<code>Lab</code>你已经实现了单条<code>WAL</code>记录<code>Record</code>的设计, 这一小节我们将整合<code>Record</code>, 完成<code>WAL</code>组件的设计。</p>
<h1 id="1-wal-文件设计"><a class="header" href="#1-wal-文件设计">1 WAL 文件设计</a></h1>
<p>首先，<code>WAL</code>文件的内容本质上分就是<code>Record</code>的数组。但这里却不仅仅是对<code>Record</code>的简单存储，而是需要考虑<code>WAL</code>文件的时效性对其进行清理, 以及写入文件的方式。设计要点包括：</p>
<ol>
<li>刷盘的高效性
<ul>
<li>我们都知道，当一个事务完成时，必须保证其对应的<code>WAL</code>记录被写入磁盘，否则在系统崩溃时，事务的修改将无法恢复。因此，<code>WAL</code>记录的写入必须保证原子性。但保证原子性的开销是什么呢? 你需要保证你的<code>WAL</code>组件写入磁盘时的效率(例如设置缓冲区, 或者是异步刷盘)</li>
</ul>
</li>
<li>过时<code>WAL</code>记录的清理
<ul>
<li>事务操作的记录都会记录到<code>WAL</code>文件中进行持久化, 但其本身对数据库的操作也会随着刷盘形成<code>SST</code>完成真正的持久化, 此时之前的<code>WAL</code>记录已经不再需要, 需要被清理。因此，<code>WAL</code>文件需要有一个机制来清理过时的<code>WAL</code>记录。</li>
</ul>
</li>
</ol>
<h1 id="2-wal-组件的设计思路"><a class="header" href="#2-wal-组件的设计思路">2 WAL 组件的设计思路</a></h1>
<p>老规矩, 我们先看看<code>WAL</code>组件的定义:</p>
<pre><code class="language-cpp">class WAL {
public:
  WAL(const std::string &amp;log_dir, size_t buffer_size,
      uint64_t max_finished_tranc_id, uint64_t clean_interval,
      uint64_t file_size_limit);
  ~WAL();

  static std::map&lt;uint64_t, std::vector&lt;Record&gt;&gt;
  recover(const std::string &amp;log_dir, uint64_t max_finished_tranc_id);

  // 将记录添加到缓冲区
  void log(const std::vector&lt;Record&gt; &amp;records, bool force_flush = false);

  // 写入 WAL 文件
  void flush();

private:
  void cleaner();

protected:
  std::string active_log_path_;
  FileObj log_file_;
  size_t file_size_limit_;
  std::mutex mutex_;
  std::vector&lt;Record&gt; log_buffer_;
  size_t buffer_size_;
  std::thread cleaner_thread_;
  uint64_t max_finished_tranc_id_;
  uint64_t clean_interval_;
};
</code></pre>
<p>这里我们定义了<code>WAL</code>组件的几个关键成员变量和接口, 其设计思路为:</p>
<ol>
<li><code>active_log_path_</code>: 当前写入的<code>WAL</code>文件路径</li>
<li><code>log_file_</code>: 当前写入的<code>WAL</code>文件对象</li>
<li><code>file_size_limit_</code>: <code>WAL</code>文件的大小限制（选择性使用）</li>
<li><code>log_buffer_</code>: <code>WAL</code>记录的缓冲区（选择性使用）</li>
<li><code>buffer_size_</code>: 缓冲区的大小（选择性使用）</li>
<li><code>cleaner_thread_</code>: 清理线程（选择性使用）</li>
</ol>
<p>这里的成员变量只是给你一些提示, 你不一定需要使用, 但这些成员函数是必须的:</p>
<ol>
<li><code>WAL</code>: 构造函数, 初始化<code>WAL</code>组件</li>
<li><code>~WAL()</code>: 析构函数, 关闭<code>WAL</code>组件, 你需要保证析构时所有<code>WAL</code>内容都被持久化</li>
<li><code>recover</code>: 恢复<code>WAL</code>文件, 返回所有未完成的<code>WAL</code>记录(这是下一个<code>Lab</code>的内容)</li>
<li><code>log</code>: 将记录添加到缓冲区或者刷入磁盘 (取决于你的策略选择性使用)</li>
<li><code>flush</code>: 强制将缓冲区中的记录刷入磁盘 (取决于你的策略选择性使用)</li>
<li><code>cleaner</code>: 清理旧数据的线程（选择性使用）</li>
</ol>
<h1 id="3-代码实现-2"><a class="header" href="#3-代码实现-2">3 代码实现</a></h1>
<ul>
<li><code>src/wal/wal.cpp</code></li>
<li><code>include/wal/wal.h</code> (Optional)</li>
</ul>
<h2 id="31-wal-组件的接口实现"><a class="header" href="#31-wal-组件的接口实现">3.1 WAL 组件的接口实现</a></h2>
<p>你只需要实现下面几个必须实现的函数, 你可以选择性地添加其他功能函数:</p>
<pre><code class="language-cpp">WAL::WAL(const std::string &amp;log_dir, size_t buffer_size,
         uint64_t max_finished_tranc_id, uint64_t clean_interval,
         uint64_t file_size_limit) {
  // TODO Lab 5.4 : 实现WAL的初始化流程
}

WAL::~WAL() {
  // TODO Lab 5.4 : 实现WAL的清理流程
}

void WAL::log(const std::vector&lt;Record&gt; &amp;records, bool force_flush) {
  // TODO Lab 5.4 : 实现WAL的写入流程
}

// commit 时 强制写入
void WAL::flush() {
  // TODO Lab 5.4 : 强制刷盘
  // ? 取决于你的 log 实现是否使用了缓冲区或者异步的实现
}

void WAL::cleaner() {
  // TODO Lab 5.4 : 实现WAL的清理线程
}
</code></pre>
<h2 id="32-trancontext-逻辑更新"><a class="header" href="#32-trancontext-逻辑更新">3.2 TranContext 逻辑更新</a></h2>
<p>之前你实现的<code>TranContext</code>的<code>put</code>, <code>get</code>,<code>remove</code>, <code>commit</code>和<code>abort</code>等函数中, 你的实现仅仅是将操作记录记录在了<code>operations</code>数组中(甚至没有记录, 因为那时你可能不知道这个成员变量是做什么的)。</p>
<p>现在你已经实现的<code>WAL</code>的刷盘接口, 因此你需要更新<code>TranContext</code>的这些函数, 使其能够将操作记录写入<code>WAL</code>文件中。不过这里你需要尤其注意冲突检测的问题, 不同的策略的冲突检测实现难度大不相同</p>
<ul>
<li><code>commit</code>时统一进行冲突检测并写入<code>WAL</code>文件, 这种方式实现最简单, 但性能较差</li>
<li><code>put</code>, <code>get</code>, <code>remove</code>时进行就分批写入<code>WAL</code>文件, 这种方式实现需要你在从图检测时需要考虑<code>WAL</code>文件中的记录的有效性控制, 实现难度较大, 但性能较好</li>
</ul>
<p>你在更新<code>TranContext</code>的<code>put</code>, <code>get</code>,<code>remove</code>, <code>commit</code>和<code>abort</code>等函数中, 下面这个辅助函数也许对你有用:</p>
<pre><code class="language-cpp">bool TranManager::write_to_wal(const std::vector&lt;Record&gt; &amp;records) {
  // TODO: Lab 5.4

  return true;
}
</code></pre>
<h1 id="4-测试-6"><a class="header" href="#4-测试-6">4 测试</a></h1>
<p><code>WAL</code>组件的测试代码在<code>test/lab5/test_wal.cpp</code>中, 你需要保证你的<code>WAL</code>组件能够通过这些测试, 但这个测试文件编写其实非常粗糙, 因为本节<code>Lab</code>对你的实现方案没有做任何限制, 因此你的实现的元数据也不好测试。因此, 这个测试看看就行, 在你完成下一小节(也是本章最后一个<code>Lab</code>)的逻辑后, 你可以通过<code>test _lsm</code>的<code>LSMTest.Recover</code>判断你的实现是否正确。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-55-崩溃恢复"><a class="header" href="#lab-55-崩溃恢复">Lab 5.5 崩溃恢复</a></h1>
<h1 id="1-崩溃恢复运行机制"><a class="header" href="#1-崩溃恢复运行机制">1 崩溃恢复运行机制</a></h1>
<p>当某一时刻存储引擎发送崩溃时, 需要进行崩溃恢复，以恢复数据状态。崩溃恢复的关键是<strong>回放日志</strong>，以确定已提交的事务，并执行其操作。在这个描述中我们不难得到一个信息, 即成功执行的事务一定要先将操作记录持久化到日志中, 然后再在内存中进行操作, 最后返回成功信息给客户端或者调用者。这也是为什么这个机制称为<strong>预写式日志</strong>。其崩溃恢复的工作流程包括：</p>
<ol>
<li><strong>日志回放</strong>：从最后一个检查点开始扫描日志，按顺序处理所有已提交事务（<code>COMMIT</code>标记后的操作）。</li>
<li><strong>Redo阶段</strong>：重新执行所有已提交事务的<code>PUT/REMOVE</code>操作，覆盖当前数据状态。</li>
<li><strong>Undo阶段（可选）</strong>：若事务未提交（无<code>COMMIT</code>标记），则直接丢弃其操作记录。</li>
</ol>
<p><strong>示例场景</strong>
假设事务<code>TX100</code>依次执行<code>PUT key1=value1</code>和<code>REMOVE key2</code>，其日志内容如下：</p>
<pre><code class="language-plaintext">BEGIN TX100
PUT key1 5 value1
DELETE key2
COMMIT TX100
</code></pre>
<p>事务<code>TX100</code>在调用<code>commit</code>函数后, 需要将上述日志刷入<code>wal</code>文件完成预写这一步骤后, 才会返回<code>client</code>事务提交成功。一开始提交的事务，其数据一定是只存在于<code>MemTable</code>中的, 此时如果存储引擎崩溃, 刚刚完成的事务是没法刷入到<code>sst</code>文件的, 但我们重启时可以检查<code>wal</code>文件的内容, 将其与数据库持久化的状态进行比对(持久化的状态包括最大已完成的事务id、最大已经刷盘的事务id， 见上一章的内容)，如果其事务<code>id</code>比目前已经持久化到<code>sst</code>的最大事务<code>id</code>大，则说明该事务需要进行重放, 另一方面, 如果事务记录的最后一个条目是<code>Rollback</code>，则说明该事务需要被回滚, 则不需要在崩溃恢复时进行重放.</p>
<p>将上述流程总结如下:</p>
<p><strong>情形1: 正常提交事务、SST刷盘正常</strong></p>
<ol>
<li>事务开始, 写入<code>BEGIN</code>标记到<code>WAL</code>日志中。(此时的<code>WAL</code>日志可能存在于缓冲区, 没有刷入文件)</li>
<li>执行若干<code>PUT/DELETE</code>操作, 将操作记录写入<code>WAL</code>日志中。(此时的<code>WAL</code>日志可能存在于缓冲区, 没有刷入文件)
<ol>
<li>如果隔离级别是<code>Read Uncommitted</code>, 可以将<code>PUT/DELETE</code>操作直接应用到数据库</li>
<li>其他隔离级别则将<code>PUT/DELETE</code>操作暂存到事务管理的上下文内存中, 等待事务提交时再应用到数据库</li>
</ol>
</li>
<li>提交事务:
<ol>
<li>将<code>COMMIT</code>标记写入<code>WAL</code>日志中。(此时的<code>WAL</code>日志可能存在于缓冲区, 没有刷入文件)</li>
<li>将<code>WAL</code>日志刷入磁盘。(此时<code>WAL</code>日志已经刷入磁盘)</li>
<li>如果隔离级别不是<code>Read Uncommitted</code>, 则将暂存的<code>PUT/DELETE</code>操作应用到数据库</li>
<li>返回给<code>client</code>成功或失败</li>
</ol>
</li>
<li>之前事务的<code>PUT/DELETE</code>操作的变化应用到数据库仍然是位于<code>MemTable</code>中的, 其会稍后输入<code>SST</code></li>
</ol>
<p><strong>情形2: 正常提交事务、SST刷盘崩溃</strong></p>
<ol>
<li>事务开始, 写入<code>BEGIN</code>标记到<code>WAL</code>日志中。(此时的<code>WAL</code>日志可能存在于缓冲区, 没有刷入文件)</li>
<li>执行若干<code>PUT/DELETE</code>操作, 将操作记录写入<code>WAL</code>日志中。(此时的<code>WAL</code>日志可能存在于缓冲区, 没有刷入文件)
<ol>
<li>如果隔离级别是<code>Read Uncommitted</code>, 可以将<code>PUT/DELETE</code>操作直接应用到数据库</li>
<li>其他隔离级别则将<code>PUT/DELETE</code>操作暂存到事务管理的上下文内存中, 等待事务提交时再应用到数据库</li>
</ol>
</li>
<li>提交事务:
<ol>
<li>将<code>COMMIT</code>标记写入<code>WAL</code>日志中。(此时的<code>WAL</code>日志可能存在于缓冲区, 没有刷入文件)</li>
<li>将<code>WAL</code>日志刷入磁盘。(此时<code>WAL</code>日志已经刷入磁盘)</li>
<li>如果隔离级别不是<code>Read Uncommitted</code>, 则将暂存的<code>PUT/DELETE</code>操作应用到数据库</li>
<li>返回给<code>client</code>成功或失败</li>
</ol>
</li>
<li>之前事务的<code>PUT/DELETE</code>操作的变化应用到数据库仍然是位于<code>MemTable</code>中的, 其稍后刷入<code>SST</code>奔溃</li>
<li>数据库重启后执行崩溃回复
<ol>
<li>检查<code>WAL</code>文件的记录</li>
<li>整合事务<code>id</code>每条记录, 忽略以<code>Rollback</code>结尾的事务</li>
<li>若事务以<code>Commit</code>结尾, 则将事务<code>id</code>与已经刷盘的<code>SST</code>中的最大事务<code>id</code>进行比对
<ol>
<li>若事务<code>id</code>大于<code>SST</code>的最大事务<code>id</code>, 执行重放操作</li>
<li>若事务<code>id</code>小于<code>SST</code>的最大事务<code>id</code>, 则忽略该事务, 因为其已经被数据库执行过了</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>情形3: 事务回滚</strong></p>
<ol>
<li>事务开始, 写入<code>BEGIN</code>标记到<code>WAL</code>日志中。(此时的<code>WAL</code>日志可能存在于缓冲区, 没有刷入文件)</li>
<li>执行若干<code>PUT/DELETE</code>操作, 将操作记录写入<code>WAL</code>日志中。(此时的<code>WAL</code>日志可能存在于缓冲区, 没有刷入文件)
<ol>
<li>如果隔离级别是<code>Read Uncommitted</code>, 可以将<code>PUT/DELETE</code>操作直接应用到数据库</li>
<li>其他隔离级别则将<code>PUT/DELETE</code>操作暂存到事务管理的上下文内存中, 等待事务提交时再应用到数据库</li>
</ol>
</li>
<li>回滚事务:
<ol>
<li>将<code>Rollback</code>标记写入<code>WAL</code>日志中。(此时的<code>WAL</code>日志可能存在于缓冲区, 没有刷入文件)</li>
<li>将<code>WAL</code>日志刷入磁盘。(此时<code>WAL</code>日志已经刷入磁盘)</li>
<li>如果隔离级别不是<code>Read Uncommitted</code>, 则将暂存的<code>PUT/DELETE</code>操作简单丢弃即可</li>
<li>如果隔离级别是<code>Read Uncommitted</code>, 则将操作前的数据库状态进行还原(作者的设计是利用<code>TranContext</code>中的<code>rollback_map_</code>进行还原, 当然这取决于你之前的<code>Lab</code>实现)</li>
<li>返回给<code>client</code>成功或失败</li>
</ol>
</li>
</ol>
<h1 id="2-崩溃恢复代码实现"><a class="header" href="#2-崩溃恢复代码实现">2 崩溃恢复代码实现</a></h1>
<p>本小节实验, 你需要更改的代码文件包括:</p>
<ul>
<li><code>src/lsm/engine.cpp</code></li>
<li><code>include/lsm/engine.h</code> (Optional)</li>
<li><code>src/wal/wal.cpp</code></li>
<li><code>include/wal/wal.h</code> (Optional)</li>
<li><code>src/lsm/transation.cpp</code></li>
<li><code>include/lsm/transation.h</code> (Optional)</li>
</ul>
<h2 id="21-walrecover"><a class="header" href="#21-walrecover">2.1 WAL::recover</a></h2>
<p>这里的崩溃恢复需要在引擎启动时进行判断, 因此其与不同组件的构造函数息息相关, 由于这里不同组件的耦合程度较高, 故先统一介绍这流程:</p>
<pre><code class="language-text">-&gt; LSM::LSM 构造函数启动
   -&gt; 调用 LSMEngine 的构造函数
   -&gt; 调用 TranManager 的构造函数
      -&gt; TranManager 初始化除了 WAL 之外的组件
   -&gt; 调用 TranManager::check_recover 检查是否需要重放WAL日志
   -&gt; 将重放的 WAL 日志应用到 LSMEngine
   -&gt; 调用 TranManager::init_new_wal 初始化 WAL 组件
-&gt; LSM::LSM 的其他逻辑...
-&gt; LSM::LSM 构造函数结束
</code></pre>
<pre><code class="language-cpp">std::map&lt;uint64_t, std::vector&lt;Record&gt;&gt;
WAL::recover(const std::string &amp;log_dir, uint64_t max_flushed_tranc_id) {
  // TODO: Lab 5.5 检查需要重放的WAL日志
  return {};
}
</code></pre>
<p>这个函数是一个静态函数, 在你的引擎正式初始化前(或者初始化的过程中, 取决于你的实现)需要进行<code>WAL</code>文件的重放, 举个例子:</p>
<pre><code class="language-text">T1 ctx1 running, ctx2 running
T2 ctx1 commit, ctx2 running
T3 crash, both data from in ctx1 and ctx2 are not flushed to sst (in `MemTable`)
T4 recover
</code></pre>
<p>在这个例子中, <code>ctx1</code>在崩溃前成功提交但数据没有刷入<code>SST</code>, 存在与内存的<code>MemTable</code>中; <code>ctx2</code>在崩溃时仍未提交, 因此在<code>T4</code>进行崩溃恢复时, 属于<code>ctx1</code>的<code>WAL</code>日志需要进行重放, 而属于<code>ctx2</code>的<code>WAL</code>日志则不需要进行重放(因为其根本没有提交)</p>
<p><code>WAL::recover</code>函数就是整理需要重放的<code>WAL</code>日志, 返回一个<code>map</code>, 其中<code>key</code>为事务<code>id</code>, <code>value</code>为该事务的所有<code>WAL</code>操作记录</p>
<h2 id="22-tranmanagercheck_recover"><a class="header" href="#22-tranmanagercheck_recover">2.2 TranManager::check_recover</a></h2>
<pre><code class="language-cpp">std::map&lt;uint64_t, std::vector&lt;Record&gt;&gt; TranManager::check_recover() {
  // TODO: Lab 5.5
  return {};
}
</code></pre>
<p><code>TranManager::check_recover</code>的目的是调用底层<code>WAL</code>的<code>recover</code>函数, 将其返回的<code>map</code>保存到上层组件中, 由上层组件进行重放。</p>
<p>这里需要注意的是, 之前的<code>WAL::recover</code>函数是静态函数, 其会在<code>WAL</code>的类的实例化之前进行调用, 因此在<code>WAL</code>的实例化过程中, 需要调用<code>WAL::recover</code>函数, 并将返回的<code>map</code>保存到上层组件中使其进行重放, 这里在<code>recover</code>崩溃恢复之后进行<code>WAL</code>的初始化的函数是由<code>TranManager::init_new_wal</code>函数进行的:</p>
<h2 id="23-wal-初始化"><a class="header" href="#23-wal-初始化">2.3 WAL 初始化</a></h2>
<p>在重放完成后，需要重新初始化 WAL，以便后续事务的日志记录：</p>
<pre><code class="language-cpp">void TranManager::init_new_wal() {
  // TODO: Lab 5.5 初始化 wal
}
</code></pre>
<p>这里你也需要回顾一下<code>TranManager</code>的头文件定义:</p>
<pre><code class="language-cpp">class TranManager : public std::enable_shared_from_this&lt;TranManager&gt; {
public:
  // ...

private:
  // ...
  std::shared_ptr&lt;WAL&gt; wal;
  // ...
};
</code></pre>
<blockquote>
<p>这里的组件构成是: <code>TranManager</code>内部管理的<code>WAL</code>这个组件, 他们内部的耦合度还是比较高的, 后续的实验版本也需要进行优化</p>
</blockquote>
<h2 id="24-lsm-的构造函数"><a class="header" href="#24-lsm-的构造函数">2.4 LSM 的构造函数</a></h2>
<p>你需要在<code>LSM</code>的构造函数中调用之前实现的<code>WAL</code>重放检查相关的函数, 并将重放的<code>WAL</code>日志应用到<code>LSM</code>中, 在之后你需要重新初始化<code>WAL</code>组件:</p>
<pre><code class="language-cpp">LSM::LSM(std::string path)
    : engine(std::make_shared&lt;LSMEngine&gt;(path)),
      tran_manager_(std::make_shared&lt;TranManager&gt;(path)) {
  // TODO: Lab 5.5 控制WAL重放与组件的初始化
}
</code></pre>
<h1 id="3-事务id信息的维护"><a class="header" href="#3-事务id信息的维护">3 事务id信息的维护</a></h1>
<p>这里补充说明一个非常重要的细节。我们之前介绍的崩溃恢复重放流程是：</p>
<pre><code class="language-text">1. 检查WAL日志
2. 整合事务id每条记录, 忽略以Rollback结尾的事务
3. 若事务以Commit结尾, 则将事务id与已经刷盘的SST中的最大事务id进行比对
   1. 若事务id大于SST的最大事务id, 执行重放操作
   2. 若事务id小于SST的最大事务id, 则忽略该事务, 因为其已经被持久化到SST了
</code></pre>
<p>这里的问题包括:</p>
<ol>
<li>什么时候更新这个<code>已经刷盘的SST中的最大事务id</code>? (这个变量就是<code>max_flushed_tranc_id_</code>)</li>
<li><code>max_flushed_tranc_id_</code>意味着整个事务已经刷盘到<code>SST</code>, 这是如何保证的? 有没有坑出现下述情况
<ol>
<li>一部分属于该事务的键值对在刷盘时检查到其<code>tranc_id</code>比<code>max_flushed_tranc_id_</code>大, 因此更新了<code>max_flushed_tranc_id_</code></li>
<li>此时数据库崩溃, 改事务的剩余键值对因为在内存<code>MemTable</code>中而被丢弃, 但<code>WAL</code>中有对应的日志</li>
<li>崩溃恢复时, 由于<code>WAL</code>中属于该事务的事务的<code>tranc_id</code>等于<code>max_flushed_tranc_id_</code>而被忽略, 改事务尽管<code>commit</code>了, 但其数据还是发生了缺失</li>
</ol>
</li>
</ol>
<p>实验不限制你对上述问题的解决方案, 你能通过后续测试即可</p>
<h1 id="4-测试-7"><a class="header" href="#4-测试-7">4 测试</a></h1>
<p>现在你应该可以通过之前所有的测试了:</p>
<pre><code class="language-bash">✗ xmake
[100%]: build ok, spent 0.773s
✗ xmake run test_lsm
[==========] Running 9 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 9 tests from LSMTest
[ RUN      ] LSMTest.BasicOperations
[       OK ] LSMTest.BasicOperations (1003 ms)
[ RUN      ] LSMTest.Persistence
[       OK ] LSMTest.Persistence (2020 ms)
[ RUN      ] LSMTest.LargeScaleOperations
[       OK ] LSMTest.LargeScaleOperations (1000 ms)
[ RUN      ] LSMTest.IteratorOperations
[       OK ] LSMTest.IteratorOperations (1027 ms)
[ RUN      ] LSMTest.MixedOperations
[       OK ] LSMTest.MixedOperations (1001 ms)
[ RUN      ] LSMTest.MonotonyPredicate
[       OK ] LSMTest.MonotonyPredicate (1016 ms)
[ RUN      ] LSMTest.TrancIdTest
[       OK ] LSMTest.TrancIdTest (18 ms)
[ RUN      ] LSMTest.TranContextTest
[       OK ] LSMTest.TranContextTest (0 ms)
[ RUN      ] LSMTest.Recover
[       OK ] LSMTest.Recover (1001 ms)
[----------] 9 tests from LSMTest (8091 ms total)

[----------] Global test environment tear-down
[==========] 9 tests from 1 test suite ran. (8091 ms total)
[  PASSED  ] 9 tests.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-6-redis-兼容"><a class="header" href="#lab-6-redis-兼容">Lab 6 Redis 兼容</a></h1>
<p>之前章节的<code>Lab</code>, 你已经实现了一个功能较为完备的<code>LSM Tree</code>, 这一章我们将目光向上层移动, 来设计一个兼容<code>Redis</code>协议的服务层, 使其能替代<code>redis-server</code>处理<code>redis-cli</code>的请求。</p>
<p>需要注意的是，本章的实验实现了<code>Redis</code>的<code>RESP</code>协议的解析与命令功能的实现, 底层使用的是我们的<code>LSM Tree</code>存储引擎的<code>KV</code>接口。</p>
<p>此外本章不会额外介绍<code>Redis</code>是什么, 你可以参考<a href="https://redis.io/learn/howtos/quick-start">Redis官网</a>进行简短的学习(只需要了解基础命令的使用即可)。</p>
<h1 id="1-resp协议简介"><a class="header" href="#1-resp协议简介">1 Resp协议简介</a></h1>
<p>这里就不再对<code>Redis</code>本身的基础概念进行介绍了, 毕竟<code>Redis</code>是校招八股必背知识点, 大家想必都非常熟悉了. 但大多数朋友可能对<code>Redis</code>通信的<code>Resp</code>协议完全不熟悉, 这里简单介绍一下<code>Resp</code>协议.</p>
<p>Redis的RESP（REdis Serialization Protocol）是Redis客户端与服务器之间通信的协议, 也就是<code>redis-cli</code>和<code>redis-server</code>之间进行通信的协议，它简单、高效，支持多种数据类型。因此, 其只需要描述<code>Redis</code>中的数据类型和请求类型就可以了。</p>
<p>需要说明的是, <code>Resp</code>协议应该属于<code>TCP</code>这一层的协议, 其没有<code>HTTP</code>等协议的头, 实现时我们也不需要<code>http</code>层的框架</p>
<h2 id="11-一个简单的案例"><a class="header" href="#11-一个简单的案例">1.1 一个简单的案例</a></h2>
<p>假设你在 <code>redis-cli</code> 中输入了以下命令：</p>
<pre><code class="language-bash">SET k1 v1
</code></pre>
<p><code>redis-cli</code>客户端会将该命令转换为 <code>RESP</code> 协议格式并发送给 <code>Redis</code> 服务器。具体表示如下：</p>
<pre><code class="language-text">*3
$3
SET
$2
k1
$2
v1
</code></pre>
<blockquote>
<p>这里其实显式地表达了换行符<code>\r\n</code>, 真实的内容是: <code>*3\r\n$3\r\nSET\r\n$2\r\nk1\r\n$2\r\nv1\r\n</code></p>
</blockquote>
<p><strong>解释：</strong></p>
<ul>
<li><code>*3</code>：表示这是一个包含 3 个元素的数组。</li>
<li><code>$3</code>：表示第一个元素是一个长度为 3 的批量字符串（Bulk String），内容为 <code>SET</code>。</li>
<li><code>$2</code>：表示第二个元素是一个长度为 2 的批量字符串，内容为 <code>k1</code>。</li>
<li><code>$2</code>：表示第三个元素是一个长度为 2 的批量字符串，内容为 <code>v1</code>。</li>
</ul>
<blockquote>
<p><code>\r\n</code>为不同字段之间的分隔符, 且不计入长度</p>
</blockquote>
<p><code>Redis</code> 服务器接收到上述请求后，执行 <code>SET k1 v1</code> 操作，并返回响应。例如：</p>
<pre><code class="language-bash">+OK
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li><code>+OK</code>：表示这是一个简单字符串（Simple String），值为 <code>OK</code>，表示操作成功。</li>
</ul>
<p>如果客户端发送的命令或参数有误，<code>Redis</code> 服务器可能会返回错误信息。例如：</p>
<pre><code class="language-bash">-ERR syntax error
</code></pre>
<p><strong>解释：</strong></p>
<ul>
<li><code>-ERR</code>：表示这是一个错误消息（Error），内容为 <code>syntax error</code>。</li>
</ul>
<h2 id="12-数据类型语法"><a class="header" href="#12-数据类型语法">1.2 数据类型语法</a></h2>
<p>通过之前的案例我们可以看到, <code>RESP</code>使用一些符号来对数据类型进行标记, 这里简单总结如下:</p>
<ul>
<li><strong>简单字符串（Simple Strings）</strong>：以"+"开头，如<code>+OK\r\n</code>。</li>
<li><strong>错误（Errors）</strong>：以"-"开头，如<code>-ERR unknown command\r\n</code>。</li>
<li><strong>整数（Integers）</strong>：以":"开头，如<code>:1000\r\n</code>。</li>
<li><strong>批量字符串（Bulk Strings）</strong>：以"$"开头，如<code>$6\r\nfoobar\r\n</code>。</li>
<li><strong>数组（Arrays）</strong>：以"*"开头，如<code>*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n</code>。</li>
</ul>
<h1 id="2-redis实现思路"><a class="header" href="#2-redis实现思路">2 Redis实现思路</a></h1>
<p>这里我们将利用自身的<code>LSM Tree</code>接口来设计一个兼容<code>Redis</code>协议的服务层, 使其能替代<code>redis-server</code>处理<code>redis-cli</code>的请求.</p>
<p>首先我们回顾一下我们的<code>LSM Tree</code>接口支持什么api:</p>
<ol>
<li><code>Put(key, value)</code>: 将键值对插入到数据库中。</li>
<li><code>Get(key)</code>: 根据键获取对应的值。</li>
<li><code>Delete(key)</code>: 根据键删除对应的值。</li>
<li><code>Scan(start_key, end_key)</code>: 根据起始键和结束键范围获取键值对。(就是上一章实现的谓词查询, 这里的<code>Scan</code>是一个虚拟的接口)</li>
</ol>
<p>然后我们想一下<code>Redsis</code>的不同数据结构的接口</p>
<ol>
<li><strong>字符串（String）</strong>：和<code>LSM Tree</code>一样, 我们也只需要实现<code>Put(key, value)</code>和<code>Get(key)</code>即可</li>
<li><strong>列表（List）</strong>：相当于不同字符串之间有连接</li>
<li><strong>哈希（Hash）</strong>：一个哈希的<code>key</code>由很多个<code>filed</code>即<code>value</code>组成</li>
<li><strong>集合（Set）</strong>: 一个集合的<code>key</code>由很多个<code>member</code>, 但不需要排序</li>
<li><strong>有序集合（Sorted Set）</strong>: 集合的<code>key</code>由很多个<code>member</code>和<code>score</code>组成, 并且需要按照<code>score</code>排序</li>
</ol>
<p>同时很多<code>key</code>还有一些基础属性, 最常用的就是<code>TTL</code>(过期时间), 当<code>TTL</code>过期时, 该<code>key</code>将不再存在, 我们也可以通过<code>TTL</code>来判断一个<code>key</code>是否过期, 也可以使用<code>EXPIRE</code>来设置一个<code>key</code>的过期时间</p>
<p>其实本质上, 由于我们的存储引擎是<code>KV</code>存储, 我们的哈希的所有数据都将作为基础的<code>key</code>和<code>value</code>进行存储, 这与<code>Redis</code>中的<code>字符串</code>是一致的。而<code>List</code>, <code>Set</code>, <code>Sorted Set</code>等数据结构就需要将多对<code>key</code>进行组合, 并且需要根据一定的规则进行排序, 而且回想我的<code>LSM Tree</code>接口支持的api, 核心思路就只有2类:</p>
<ol>
<li><code>List</code>, <code>Set</code>, <code>Sorted Set</code>等数据结构的<code>key</code>的<code>value</code>中要记录所管理成员的元信息</li>
<li>归属于某个大数据结构(<code>List</code>, <code>Set</code>, <code>Sorted Set</code>等)的成员的<code>key</code>需要包含统一的前缀, 这样才能通过我的的存储引擎进行前缀查询</li>
</ol>
<p>现在你已经对<code>RESP</code>和<code>Redis</code>的兼容层的设计思想有一个大致的认知, 接下来我们就可以开始实现我们的兼容层了: <a href="lab6/./lab6.1-String.html">Lab 6.1 简单字符串</a></p>
<blockquote>
<p>!!! 你做<code>Lab</code>时如果对<code>RESP</code>协议的格式不熟悉, 可以参考附录中的<a href="lab6/../appendix/RESP.html">RESP 常见格式</a>进行学习</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-61-简单字符串"><a class="header" href="#lab-61-简单字符串">Lab 6.1 简单字符串</a></h1>
<h1 id="1-简单字符串的设计"><a class="header" href="#1-简单字符串的设计">1 简单字符串的设计</a></h1>
<p>你也许会认为, 简单字符串不就是调用我们<code>LSM Tree</code>的<code>get</code>和<code>put</code>方法吗? 其实不然, 你是否忘记了我们的<code>Redis</code>是支持对键值对进行过期时间设置的?</p>
<p>那么, 由于过期时间的存在, 你的代码实现需要解决以下几个难点:</p>
<h2 id="1-如何实现过期时间"><a class="header" href="#1-如何实现过期时间">1 如何实现过期时间?</a></h2>
<p>你也许会认为, 我们只需要在<code>value</code>或者<code>key</code>中拼接一个字段来表示过期时间即可, 但虽然是一个可行的方案, 但因为我们过期时间是支持重新设置的, 这样以来你在查询数据后需要进行一定的字符串处理流程。</p>
<p>另一种方案，是每个实际的键值对绑定一个表示其生命周期的额外键值对，比如你插入的键值对是 <code>(a, b)</code>, 那你可以同时插入一个键值对 <code>(expire_a, expire_time)</code>, 其中<code>expire_time</code>表示与键<code>a</code>的绑定的表示过期时间的<code>key</code>。这样，当你查询<code>a</code>时，只需要查询<code>expire_a</code>的表示过期时间的<code>expire_time</code>即可，如果过期时间小于当前时间，则删除<code>a</code>和<code>expire_a</code>，并返回<code>nil</code>。</p>
<p>上面两种方案是最简单且容易想到的方案, 当然你也不一定局限于作者推荐的实现方案, 可以有自己的设计</p>
<h2 id="2-采取何种过期清理策略"><a class="header" href="#2-采取何种过期清理策略">2 采取何种过期清理策略?</a></h2>
<p>那么<code>key</code>只要存在过期时间, 你的实现策略有以下3种:</p>
<ul>
<li>惰性检查: 相同的<code>key</code>在下一次被查询时, 检查是否过期, 如果过期则删除, 返回<code>nil</code>
<ul>
<li>优点: 实现简单</li>
<li>缺点: 如果这个<code>key</code>是个冷<code>key</code>(即访问频率低), 那么即时其过期很久之后, 仍然占据了内存(虽然我们的<code>LSM Tree</code>是追加写入的, 但在<code>Compact</code>时, 我们是需要移除已经完成的事务且被覆写的键值对的)</li>
</ul>
</li>
<li>后台线程检查: 在后台开启一个线程, 每隔一段时间检查所有键值对, 如果过期则删除
<ul>
<li>优点: 过期的<code>key</code>能较为及时地被删除</li>
<li>缺点: 需要额外的线程, 代码组织和并发控制复杂</li>
</ul>
</li>
<li>前两种结合: 惰性检查+后台线程检查</li>
</ul>
<h1 id="3-代码组织简介"><a class="header" href="#3-代码组织简介">3 代码组织简介</a></h1>
<p>这一小节我们首先对<code>Redis</code>的兼容层代码进行简要介绍, 我们的代码组织为:</p>
<pre><code class="language-bash">├── config.toml # 配置文件的常量 (你需要复制到单元测试编译的目录下才能生效)
├── include
│   ├── redis_wrapper # Redis 兼容层的头文件定义
│   │   └── redis_wrapper.h
├── server # 调用 Redis 兼容层的 Webserver
│   ├── include
│   │   └── handler.h # Redis 命令处理函数的声明
│   └── src
│       ├── handler.cpp # Redis 命令处理函数的实现, 就是对 redis_wrapper 的转发
│       └── server.cpp # Webserver 的实现
├── src
│   ├── redis_wrapper
│   │   └── redis_wrapper.cpp # Redis 兼容层的实现
├── test
│   ├── test_redis.cpp # Redis 兼容层的单元测试
└── xmake.lua
</code></pre>
<p>各个代码文件的作用如上所示, 这里我们主要介绍今天要修改的<code>redis_wrapper.cpp</code>和<code>redis_wrapper.h</code>文件。</p>
<p>首先看<code>redis_wrapper.h</code>文件:</p>
<pre><code class="language-cpp">class RedisWrapper {
private:
  std::unique_ptr&lt;LSM&gt; lsm;
  std::shared_mutex redis_mtx;

public:
  RedisWrapper(const std::string &amp;db_path);
  void clear();
  void flushall();

  // ************************* Redis Command Parser *************************
  // ...

private:
  // ************************* Redis Command Handler *************************
  // 基础操作
  std::string redis_incr(const std::string &amp;key);
  std::string redis_decr(const std::string &amp;key);
  std::string redis_expire(const std::string &amp;key, std::string seconds_count);
  std::string redis_set(std::string &amp;key, std::string &amp;value);
  std::string redis_get(std::string &amp;key);
  std::string redis_del(std::vector&lt;std::string&gt; &amp;args);
  std::string redis_ttl(std::string &amp;key);

  // 哈希操作
  std::string redis_hset(const std::string &amp;key, const std::string &amp;field,
                         const std::string &amp;value);
  std::string redis_hset_batch(
      const std::string &amp;key,
      std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; &amp;field_value_pairs);
  std::string redis_hget(const std::string &amp;key, const std::string &amp;field);
  std::string redis_hdel(const std::string &amp;key, const std::string &amp;field);
  std::string redis_hkeys(const std::string &amp;key);
  // 链表操作
  std::string redis_lpush(const std::string &amp;key, const std::string &amp;value);
  std::string redis_rpush(const std::string &amp;key, const std::string &amp;value);
  std::string redis_lpop(const std::string &amp;key);
  std::string redis_rpop(const std::string &amp;key);
  std::string redis_llen(const std::string &amp;key);
  std::string redis_lrange(const std::string &amp;key, int start, int stop);
  // 有序集合操作
  std::string redis_zadd(std::vector&lt;std::string&gt; &amp;args);
  std::string redis_zrem(std::vector&lt;std::string&gt; &amp;args);
  std::string redis_zrange(std::vector&lt;std::string&gt; &amp;args);
  std::string redis_zcard(const std::string &amp;key);
  std::string redis_zscore(const std::string &amp;key, const std::string &amp;elem);
  std::string redis_zincrby(const std::string &amp;key,
                            const std::string &amp;increment,
                            const std::string &amp;elem);
  std::string redis_zrank(const std::string &amp;key, const std::string &amp;elem);
  // 无序集合操作
  std::string redis_sadd(std::vector&lt;std::string&gt; &amp;args);
  std::string redis_srem(std::vector&lt;std::string&gt; &amp;args);
  std::string redis_sismember(const std::string &amp;key,
                              const std::string &amp;member);
  std::string redis_scard(const std::string &amp;key);
  std::string redis_smembers(const std::string &amp;key);
};
</code></pre>
<p>这里的成员变量只有一把锁和一个<code>LSM</code>对象, 锁用于保护<code>LSM</code>对象, 防止并发访问。不过这个锁的只是一个可选的使用项, 如果你之前的<code>LSMEngine</code>的接口实现了对某些批量化操作的并发控制, 那么你可以直接使用<code>LSMEngine</code>的接口, 而不需要使用<code>RedisWrapper</code>的锁。</p>
<p>其余部分的<code>redis_xxx</code>函数都是你需要在本大章节的<code>Lab</code>中需要实现的, 其对应于具体的<code>Redis</code>命令</p>
<h1 id="4-代码实现-1"><a class="header" href="#4-代码实现-1">4 代码实现</a></h1>
<p>本小节我们实现字符串处理相关命令函数, 你需要修改的代码文件包括:</p>
<ul>
<li><code>src/redis_wrapper/redis_wrapper.cpp</code></li>
<li><code>include/redis_wrapper/redis_wrapper.h</code> (Optional)</li>
</ul>
<h2 id="41-set"><a class="header" href="#41-set">4.1 set</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_set(std::string &amp;key, std::string &amp;value) {
  // TODO: Lab 6.1 新建(或更改)一个`key`的值
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return "+OK\r\n";
}
</code></pre>
<p>这里我们不需要你支持在<code>set</code>一个<code>key</code>时就指定其过期时间, 我们的单元测试只会在<code>expire</code>中手动设置过期时间。</p>
<h2 id="42-expire"><a class="header" href="#42-expire">4.2 expire</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_expire(const std::string &amp;key,
                                       std::string seconds_count) {
  // TODO: Lab 6.1 设置一个`key`的过期时间
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return ":1\r\n";
}
</code></pre>
<p>该命令用于设置一个<code>key</code>的过期时间, 单位为秒。</p>
<p>如同之前理论部分的介绍, 你既可以选择为其额外设置一个表示过期时间的键值对, 也可以在键值对的字符串中拼接表示过期时间的部分, 亦或是其他方案。</p>
<h3 id="43-ttl"><a class="header" href="#43-ttl">4.3 ttl</a></h3>
<pre><code class="language-cpp">std::string RedisWrapper::redis_ttl(std::string &amp;key) {
  // TODO: Lab 6.1 获取一个`key`的剩余过期时间
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return ":1\r\n"; // 表示键不存在
}
</code></pre>
<p>该命令是与<code>expire</code>成对的, 你在<code>expire</code>中如何设置过期时间, 就需要在<code>ttl</code>中如何获取剩余过期时间。</p>
<h2 id="44-get"><a class="header" href="#44-get">4.4 get</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_get(std::string &amp;key) {
  // TODO: Lab 6.1 获取一个`key`的值
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return "$-1\r\n"; // 表示键不存在
}
</code></pre>
<p>查询一个<code>key</code>的值, 如果不存在则返回<code>nil</code>。</p>
<p>你可能需要再此时判断一下<code>key</code>是否已经过期, 如果已经过期则删除该<code>key</code>。</p>
<h2 id="45-incr--decr"><a class="header" href="#45-incr--decr">4.5 incr &amp;&amp; decr</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_incr(const std::string &amp;key) {
  // TODO: Lab 6.1 自增一个值类型的key
  // ? 不存在则新建一个值为1的key
  return "1";
}

std::string RedisWrapper::redis_decr(const std::string &amp;key) {
  // TODO: Lab 6.1 自增一个值类型的key
  // ? 不存在则新建一个值为-1的key
  return "-1";
}
</code></pre>
<p>对一个值类型的<code>key</code>进行自增或自减操作, 如果不存在则新建一个值为1或-1的<code>key</code>。</p>
<p>如果该键值对的值不是数值类型, 则返回<code>error</code>。在<code>RESP</code>中如何表示<code>error</code>你需要自行回顾<a href="lab6/./lab6-Redis.html">Lab 6 Redis 兼容</a>中的简单介绍, 或者看官方文档(甚至是问LLM)。</p>
<h2 id="46-del"><a class="header" href="#46-del">4.6 del</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_del(std::vector&lt;std::string&gt; &amp;args) {
  // TODO: Lab 6.1 删除一个key
  int del_count = 0;
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return ":" + std::to_string(del_count) + "\r\n";
}
</code></pre>
<p>删除一个<code>key</code>。</p>
<h1 id="5-测试-3"><a class="header" href="#5-测试-3">5 测试</a></h1>
<p>完成上面的代码后, 你可以运行以下命令并通过对应的测试:</p>
<pre><code class="language-bash">✗ xmake
[100%]: build ok, spent 2.013s
✗ xmake run test_redis
[==========] Running 11 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 11 tests from RedisCommandsTest
[ RUN      ] RedisCommandsTest.SetAndGet
[       OK ] RedisCommandsTest.SetAndGet (12 ms)
[ RUN      ] RedisCommandsTest.IncrAndDecr
[       OK ] RedisCommandsTest.IncrAndDecr (9 ms)
[ RUN      ] RedisCommandsTest.Expire
[       OK ] RedisCommandsTest.Expire (2014 ms)
[ RUN      ] RedisCommandsTest.HSetAndHGet # Failed
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-62-哈希表"><a class="header" href="#lab-62-哈希表">Lab 6.2 哈希表</a></h1>
<h1 id="1-redis-实现思路"><a class="header" href="#1-redis-实现思路">1 Redis 实现思路</a></h1>
<p><code>Redis</code>的哈希结构就是一个<code>key</code>中管理了一个哈希表, 这里的实现有以下方案
<strong>方案1-序列化整个哈希数据结构到value</strong>
你可以采用自己编码或者引入第三方库的形式, 将整个哈希数据结构序列化成字符串, 然后存储到<code>value</code>中, 这样查询的时候直接反序列化即可。</p>
<ul>
<li><strong>优点</strong>: 查询方便, 不需要关心序列化功能的具体实现</li>
<li><strong>缺点</strong>: 序列化/反序列化耗时, 占用内存, 不利于扩展。比如，你对哈希结构中的一个<code>filed</code>进行修改, 需要重新序列化整个哈希数据结构</li>
</ul>
<p><strong>方案2-filed分离存储</strong>
这里的方案类似我们之前设置超时时间的一种解决方案, 你可以将每个<code>filed</code>作为额外的键值对进行存储, 然后代表整个哈希结构的<code>key</code>的<code>value</code>中可以存储这些<code>filed</code>的元信息, 下面给出一种具体的实现思路供你参考:</p>
<ol>
<li>整个<code>hash</code>数据结构的<code>key</code>存储的<code>value</code>是其所有<code>filed</code>的集合拼接的字符串</li>
<li>每个<code>filed</code>的<code>value</code>单独用另一个键值对存储, 但<code>filed</code>不能直接作为一个<code>key</code>, 而是需要加上指定的前缀以标识这是一个哈希结构的<code>filed</code></li>
</ol>
<p>那么查询的逻辑就是, 将<code>key</code>和<code>filed</code>拼接起来形成实际存储的<code>key</code>, 然后查询对应的<code>value</code>即可</p>
<h1 id="2-ttl-设计"><a class="header" href="#2-ttl-设计">2 TTL 设计</a></h1>
<p>同样, 你的哈希结构也需要支持<code>TTL</code>和<code>Expire</code>命令, 不过这2个命令针对的对象是整个哈希结构, 你不需要考虑对哈希中的一个<code>filed</code>设计超时时间。</p>
<p>需要注意的是，你的实现方案同样需要考虑到旧数据的清理流程。</p>
<p>最后， 如果你的哈希结构采用的是分离存储<code>filed</code>的方式（这个方式其实更推荐），你需要对内部函数的并发控制进行处理，因为这里你操作的对象可能涉及底层<code>LSM Tree</code>中的多个<code>Key</code>, 因此你需要灵活地利用批量化的操作接口, 以及自身组件的上锁与解锁逻辑控制。</p>
<blockquote>
<p>你在不同操作时, 建议利用好读写锁相比独占锁的优势, 以及在必要时进行锁升级</p>
</blockquote>
<h1 id="3-代码实现-3"><a class="header" href="#3-代码实现-3">3 代码实现</a></h1>
<p>你需要修改的代码文件包括:</p>
<ul>
<li><code>src/redis_wrapper/redis_wrapper.cpp</code></li>
<li><code>include/redis_wrapper/redis_wrapper.h</code> (Optional)</li>
</ul>
<blockquote>
<p>下面的接口中, 你仍然需要进行<code>TTL</code>超时时间的判断, 同时你可能需要更新之前的<code>redis_ttl</code>和<code>redis_expire</code>以兼容<code>Hash</code>的<code>TTL</code>机制。</p>
</blockquote>
<h2 id="31-hset"><a class="header" href="#31-hset">3.1 hset</a></h2>
<pre><code class="language-cpp">
std::string RedisWrapper::redis_hset_batch(
    const std::string &amp;key,
    std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; &amp;field_value_pairs) {
  std::shared_lock&lt;std::shared_mutex&gt; rlock(redis_mtx);
  // TODO: Lab 6.2 批量设置一个哈希类型的`key`的多个字段值
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  int added_count = 0;
  return ":" + std::to_string(added_count) + "\r\n";
}
std::string RedisWrapper::redis_hset(const std::string &amp;key,
                                     const std::string &amp;field,
                                     const std::string &amp;value) {
  std::shared_lock&lt;std::shared_mutex&gt; rlock(redis_mtx); // 读锁线判断是否过期
  // TODO: Lab 6.2 设置一个哈希类型的`key`的某个字段值
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return "+OK\r\n";
}
</code></pre>
<p><code>hset</code>允许单次的<code>filed</code>设置, 也可以批量设置多个<code>filed</code>。</p>
<h2 id="32-hget"><a class="header" href="#32-hget">3.2 hget</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_hget(const std::string &amp;key,
                                     const std::string &amp;field) {
  // TODO: Lab 6.2 获取一个哈希类型的`key`的某个字段值
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return "$-1\r\n"; // 表示键不存在
}
</code></pre>
<p>类似之前的简单字符串的<code>get</code>操作, 你可能需要再此时判断一下<code>key</code>是否已经过期, 如果已经过期则删除该<code>key</code>及其<code>filed</code>(如果是分离存储的实现方案)。</p>
<h2 id="33-hdel"><a class="header" href="#33-hdel">3.3 hdel</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_hdel(const std::string &amp;key,
                                     const std::string &amp;field) {
  // TODO: Lab 6.2 删除一个哈希类型的`key`的某个字段
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return ":1\r\n";
}
</code></pre>
<p>你需要删除单个哈希结构的<code>filed</code>。</p>
<h2 id="34-hkeys"><a class="header" href="#34-hkeys">3.4 hkeys</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_hkeys(const std::string &amp;key) {
  // TODO: Lab 6.2 获取一个哈希类型的`key`的所有字段
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return "*0\r\n";
}
</code></pre>
<p><code>_hkeys</code>就是返回哈希结构中所有的<code>filed</code>。</p>
<p>同时,这也是为什么在之前的理论介绍中 (在分离存储<code>filed</code>的实现方案中), 为什么建议你在代表整个哈希结构的大<code>key</code>的<code>value</code>中存储所有<code>filed</code>的元信息。长这样你在实现 <code>hkeys</code>的时候就会方便很多, 只需要查询单个<code>key</code>就可以了。否则你需要调用前缀查询来获取所有的<code>filed</code>的键值对。</p>
<blockquote>
<p><code>Redis</code>中涉及哈希的命令还有很多, 这里并没有完全实现, 毕竟本<code>Lab</code>的主题是介绍实现<code>Redis</code>命令的设计方法, 有了上述基础命令, 其他的命令实现应该非常简单了, 都是简单重复的操作了, 有兴趣你可以自己补充其余命令</p>
</blockquote>
<h1 id="4-测试-8"><a class="header" href="#4-测试-8">4 测试</a></h1>
<p>在完成上面的功能后, 你应该能通过下面的测试:</p>
<pre><code class="language-bash">✗ xmake
✗ xmake run test_redis
[==========] Running 11 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 11 tests from RedisCommandsTest
[ RUN      ] RedisCommandsTest.SetAndGet
[       OK ] RedisCommandsTest.SetAndGet (14 ms)
[ RUN      ] RedisCommandsTest.IncrAndDecr
[       OK ] RedisCommandsTest.IncrAndDecr (9 ms)
[ RUN      ] RedisCommandsTest.Expire
[       OK ] RedisCommandsTest.Expire (2009 ms)
[ RUN      ] RedisCommandsTest.HSetAndHGet
[       OK ] RedisCommandsTest.HSetAndHGet (17 ms)
[ RUN      ] RedisCommandsTest.HDel
[       OK ] RedisCommandsTest.HDel (9 ms)
[ RUN      ] RedisCommandsTest.HKeys
[       OK ] RedisCommandsTest.HKeys (9 ms)
[ RUN      ] RedisCommandsTest.HGetWithTTL
[       OK ] RedisCommandsTest.HGetWithTTL (2113 ms)
[ RUN      ] RedisCommandsTest.HExpire
[       OK ] RedisCommandsTest.HExpire (1111 ms)
[ RUN      ] RedisCommandsTest.ListOperations
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-63-无序集合"><a class="header" href="#lab-63-无序集合">Lab 6.3 无序集合</a></h1>
<h1 id="1-实现原理"><a class="header" href="#1-实现原理">1 实现原理</a></h1>
<p>相比之前实现的哈希, <code>Redis</code>的无序数据结构功能简单不少, 其只需要将字符串存储在这个<code>Set</code>中即可, 也不要求数据的有序性, 其行为类似<code>C++</code>中的<code>std::unordered_set</code>。</p>
<p>因此, 这里你需要面对的问题就是, 如何组织这么多个字符串, 并且保证其唯一性?</p>
<p>在这里就不建议将<code>Set</code>中所有的字符串都编码或者拼接后存储在单个键值对的<code>value</code>中, 因为通常的业务中, 一个<code>Set</code>中的字符串数量是远大于哈希结构的<code>filed</code>的, 这里若还采用整体编码存储在单个键值对中, 在<code>CRUD</code>的过程中, 编解码会消耗大量的时间。</p>
<blockquote>
<p>我们最后会兼容<code>Redis</code>的官方压测工具<code>redis-benchmark</code>, 你可以用这个测试工具比较不同实现方案的性能差距</p>
</blockquote>
<p>这里唯一推荐的方式就是利用我们的<code>LSM Tree</code>中实现的谓词查询接口(这里的谓词就是判断前缀是否匹配), 为同一<code>Set</code>的所有字符串添加相同的前缀后进行分离的键值对存储, 然后通过这个前缀进行范围查询, 这样就可以保证查询的效率, 并且保证唯一性。</p>
<h1 id="2-代码实现-10"><a class="header" href="#2-代码实现-10">2 代码实现</a></h1>
<p>你需要修改的代码文件包括:</p>
<ul>
<li><code>src/redis_wrapper/redis_wrapper.cpp</code></li>
<li><code>include/redis_wrapper/redis_wrapper.h</code> (Optional)</li>
</ul>
<blockquote>
<p>下面的接口中, 你仍然需要进行<code>TTL</code>超时时间的判断, 同时你可能需要更新之前的<code>redis_ttl</code>和<code>redis_expire</code>以兼容<code>Set</code>的<code>TTL</code>机制。</p>
</blockquote>
<h2 id="21-sadd"><a class="header" href="#21-sadd">2.1 sadd</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_sadd(std::vector&lt;std::string&gt; &amp;args) {
  // TODO: Lab 6.3 如果集合不存在则新建，添加一个元素到集合中
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return ":1\r\n";
}
</code></pre>
<p>需要注意的是, <code>sadd</code>是支持一次性在集合中新增多个元素的, 这里你可能需要调用批量化操作的接口提高以性能。</p>
<h2 id="22-srem"><a class="header" href="#22-srem">2.2 srem</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_srem(std::vector&lt;std::string&gt; &amp;args) {
  // TODO: Lab 6.3 删除集合中的元素
  int removed_count = 0;
  return ":" + std::to_string(removed_count) + "\r\n";
}
</code></pre>
<p>需要注意的是, <code>srem</code>是支持一次性从集合中删除多个元素的, 这里你可能需要调用批量化操作的接口提高以性能。</p>
<h2 id="23-sismember"><a class="header" href="#23-sismember">2.3 sismember</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_sismember(const std::string &amp;key,
                                          const std::string &amp;member) {
  // TODO: Lab 6.3 判断集合中是否存在某个元素
  return ":1\r\n";
}
</code></pre>
<p>对于查询单个字符串是否在集合中, 你只需要按照规则拼接这个分离存储的<code>key</code>, 再从<code>Lsm Tree</code>中查询即可。</p>
<h2 id="24-scard"><a class="header" href="#24-scard">2.4 scard</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_scard(const std::string &amp;key) {
  // TODO: Lab 6.3 获取集合的元素个数
  return ":1\r\n";
}
</code></pre>
<p>这里同样, 你可以直接在代表整个集合的大<code>key</code>中, 通过<code>value</code>中的元信息直接获取到集合的元素个数。如果你没有在大<code>key</code>中存储元信息, 调用谓词查询接口也可以获取到所有元素, 然后返回元素个数即可。</p>
<h2 id="25-smembers"><a class="header" href="#25-smembers">2.5 smembers</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_smembers(const std::string &amp;key) {
  // TODO: Lab 6.3 获取集合的所有元素
  return "*0\r\n";
}
</code></pre>
<p><code>smembers</code>用于获取所有的元素, 这里你可以直接调用<code>LSM Tree</code>的谓词查询接口, 查询所有前缀匹配的键值对, 然后从这些键值对的<code>value</code>构造<code>RESP</code>协议的数组返回即可。</p>
<h1 id="3-测试-11"><a class="header" href="#3-测试-11">3 测试</a></h1>
<p>在完成上面的功能后, 你应该能通过下面的测试:</p>
<pre><code class="language-bash">✗ xmake
✗ xmake run test_redis
[==========] Running 11 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 11 tests from RedisCommandsTest
[ RUN      ] RedisCommandsTest.SetAndGet
[       OK ] RedisCommandsTest.SetAndGet (14 ms)
[ RUN      ] RedisCommandsTest.IncrAndDecr
[       OK ] RedisCommandsTest.IncrAndDecr (9 ms)
[ RUN      ] RedisCommandsTest.Expire
[       OK ] RedisCommandsTest.Expire (2009 ms)
[ RUN      ] RedisCommandsTest.HSetAndHGet
[       OK ] RedisCommandsTest.HSetAndHGet (17 ms)
[ RUN      ] RedisCommandsTest.HDel
[       OK ] RedisCommandsTest.HDel (9 ms)
[ RUN      ] RedisCommandsTest.HKeys
[       OK ] RedisCommandsTest.HKeys (9 ms)
[ RUN      ] RedisCommandsTest.HGetWithTTL
[       OK ] RedisCommandsTest.HGetWithTTL (2113 ms)
[ RUN      ] RedisCommandsTest.HExpire
[       OK ] RedisCommandsTest.HExpire (1111 ms)
[ RUN      ] RedisCommandsTest.ListOperations
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-64-有序集合"><a class="header" href="#lab-64-有序集合">Lab 6.4 有序集合</a></h1>
<h1 id="1-redis-zset-实现思路"><a class="header" href="#1-redis-zset-实现思路">1 Redis ZSet 实现思路</a></h1>
<h2 id="11-实现思路"><a class="header" href="#11-实现思路">1.1 实现思路</a></h2>
<p>这里也不介绍<code>Redis zset</code>的语法了, 既然看这篇文章, 相比大家对<code>Redis</code>非常熟悉了, 这里本实验选择实现如下常见的<code>api</code>:</p>
<ul>
<li><code>zadd</code></li>
<li><code>zrem</code></li>
<li><code>zrange</code></li>
<li><code>zcard</code></li>
<li><code>zscore</code></li>
<li><code>zincrby</code></li>
<li><code>zrank</code></li>
</ul>
<p>相较于之前实现的<code>set</code>, <code>zset</code>额外加入了了<code>score</code>字段, 并且需要支持按照<code>score</code>排序的查询, 因此这里的实现又类似于<code>hash</code>的实现, 因为存储的<code>filed</code>(就是集合中的数据成员)和<code>score</code>正好可以构成分离存储的一对键值对。</p>
<p>在分离存储键值对的方案下, <code>zset</code>最大的难点就是需要双向的查询索引: 既要能够通过<code>zscore</code>查询指定成员的分数, 也要能够通过<code>zrank</code>、<code>zrange</code>按照分数排序。对于按照分数排序查询, 由于我们的<code>LSM Tree</code>本来就是按照<code>key</code>排序的, 所以我们只需要将所有的成员按照他们的分数构建一个符合顺序的<code>key</code>就可以了; 对于按照成员查询分数, 我们只能再额外存储一个<code>key</code>.</p>
<p>因此我们使用如下的方案:</p>
<ol>
<li>整个<code>zset</code>控制结构的键值对只标记其存在, 不在<code>value</code>中存储有效信息(但不能为空, 因为<code>value</code>为空表示被删除)</li>
<li>需要存储<code>(score, elem)</code>键值对, <code>score</code>为固定的前缀+<code>key</code>+真正的<code>score</code>拼接而成</li>
<li>需要存储<code>(elem, score)</code>键值对, <code>elem</code>为固定的前缀+<code>key</code>+真正的<code>elem</code>拼接而成</li>
</ol>
<blockquote>
<p>需要注意的是<code>score</code>为固定的前缀+<code>key</code>+真正的<code>score</code>拼接而成, 为保证这个<code>key</code>在我们的<code>LSM Rree</code>中排序符合<code>score</code>的顺序, 这个<code>score</code>我们限制器为整型数, 且其长度对其到32位, 否则如果支持小数的话, 排序和解析就会复杂很多</p>
</blockquote>
<h2 id="12-ttl"><a class="header" href="#12-ttl">1.2 TTL</a></h2>
<p>类似上一章的<code>TTL</code>设计, 我们需要为这个<code>zset</code>也实现<code>TTL</code>机制. 首先需要明白, <code>Redis</code> 的 <code>TTL</code> 只能对整个键（<code>key</code>）设置过期时间，而不能针对列表（<code>list</code>）、集合（<code>set</code>）、哈希（<code>hash</code>）等数据结构中的单个成员单独设置过期时间。</p>
<p>类似上一章节的<code>lsit</code>和<code>hash</code>的工作流程, 我们每次读写<code>zset</code>时, 都需要检查<code>TTL</code>是否过期, 如果过期, 则删除<code>zset</code></p>
<h1 id="2-一个存储案例"><a class="header" href="#2-一个存储案例">2 一个存储案例</a></h1>
<p>这里<code>zset</code>应该是最复杂的数据结构, 因此这里用一个<code>demo</code>详细说明下作者推荐的实现方案是如何工作的:</p>
<pre><code class="language-bash">ZADD student 100 tom # 添加一个学生及其成绩
# 主key: (student, 1) 1 表示成员的数量
#   -&gt; 分离存储的key1:   (student_score_000100, tom) # 支持从分数查找 student, 这里填充为六位数`000100`, 保证字符串排序
#   -&gt; 分离存储的key2:   (student_tom, 100) # 支持从 tom 分数查找分数

ZADD student 90 jerry # 添加一个学生及其成绩
# 主key: (student, 2) 2 表示成员的数量
#   -&gt; 分离存储的key1:   (student_score_000100, tom)
#   -&gt; 分离存储的key2:   (student_filed_tom, 100)
#   -&gt; 分离存储的key1:   (student_score_000090, jerry)
#   -&gt; 分离存储的key2:   (student_filed_jerry, 90)

ZSCORE student tom # 查询 tom 的成绩
# 直接调用kv引擎的 get接口, 查询 (student_tom, 100) 即可

ZCARD student # 查询学生数量
# 直接调用kv引擎的 get接口, 查询 (student, 2) 返回2

ZINCRBY student 10 tom # tom 成绩加10分
# 1. 先查询 tom 的成绩
# 2. 将 tom 的成绩加10分
# 3. 更新 (student_filed_tom, 110)
# 4. 插入 (student_score_000110, tom) , 删除 (student_score_000100, tom)
# PS: 如果 tom 不存在则直接新建

ZRANGE student 0 1 # 查询前两名学生
# 使用谓词查询, 谓词为查询所有前缀为 student_score_ 的key, 并按照key排序, 返回前两个key中的value即可
</code></pre>
<h1 id="3-代码实现-4"><a class="header" href="#3-代码实现-4">3 代码实现</a></h1>
<p>通过上面的理论讲解和案例说明, 你应该对此非常熟悉了...</p>
<p>你需要修改的代码文件包括:</p>
<ul>
<li><code>src/redis_wrapper/redis_wrapper.cpp</code></li>
<li><code>include/redis_wrapper/redis_wrapper.h</code> (Optional)</li>
</ul>
<blockquote>
<p>下面的接口中, 你仍然需要进行<code>TTL</code>超时时间的判断, 同时你可能需要更新之前的<code>redis_ttl</code>和<code>redis_expire</code>以兼容<code>ZSet</code>的<code>TTL</code>机制。</p>
</blockquote>
<h2 id="31-zadd"><a class="header" href="#31-zadd">3.1 zadd</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_zadd(std::vector&lt;std::string&gt; &amp;args) {
  // TODO: Lab 6.4 如果有序集合不存在则新建，添加一个元素到有序集合中
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return ":1\r\n";
}
</code></pre>
<p>注意, 这里支持一次性添加多个<code>filed</code>, 返回值表示多少个<code>filed</code>添加成功</p>
<h2 id="32-zrem"><a class="header" href="#32-zrem">3.2 zrem</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_zrem(std::vector&lt;std::string&gt; &amp;args) {
  // TODO: Lab 6.4 删除有序集合中的元素
  int removed_count = 0;
  return ":" + std::to_string(removed_count) + "\r\n";
}
</code></pre>
<p>注意, 这里支持一次性删除多个<code>filed</code>, 返回值表示多少个<code>filed</code>删除成功</p>
<h2 id="33-zrange"><a class="header" href="#33-zrange">3.3 zrange</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_zrange(std::vector&lt;std::string&gt; &amp;args) {
  // TODO: Lab 6.4 获取有序集合中指定范围内的元素
  return "*0\r\n";
}
</code></pre>
<p>查询指定范围的元素, 返回值表示查询到的元素的数组(<code>RESP</code>格式), 你需要使用<code>LSM</code>的谓词查询接口</p>
<h2 id="34-zcard"><a class="header" href="#34-zcard">3.4 zcard</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_zcard(const std::string &amp;key) {
  // TODO: Lab 6.4 获取有序集合的元素个数
  return ":1\r\n";
}
</code></pre>
<p>查询有序集合的元素个数</p>
<h2 id="35-zscore"><a class="header" href="#35-zscore">3.5 zscore</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_zscore(const std::string &amp;key,
                                       const std::string &amp;elem) {
  // TODO: Lab 6.4 获取有序集合中元素的分数
  return "$-1\r\n";
}
</code></pre>
<p>查询有序集合中指定<code>filed</code>的分数, 你只需要按照指定格式拼接<code>key</code>进行查询即可</p>
<h2 id="36-zincrby"><a class="header" href="#36-zincrby">3.6 zincrby</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_zincrby(const std::string &amp;key,
                                        const std::string &amp;increment,
                                        const std::string &amp;elem) {
  // TODO: Lab 6.4 对有序集合中元素的分数进行增加
  return "$-1\r\n";
}
</code></pre>
<p>对有序集合中指定元素的分数进行增加, 返回值表示增加后的分数</p>
<h2 id="37-zrank"><a class="header" href="#37-zrank">3.7 zrank</a></h2>
<pre><code class="language-cpp">std::string RedisWrapper::redis_zrank(const std::string &amp;key,
                                      const std::string &amp;elem) {
  //  TODO: Lab 6.4 获取有序集合中元素的排名
  return "$-1\r\n";
}
</code></pre>
<p>获取有序集合中指定元素的排名, 返回值表示排名</p>
<h1 id="4-测试-9"><a class="header" href="#4-测试-9">4 测试</a></h1>
<p>在完成上面的功能后, 你应该能通过下面的测试:</p>
<pre><code class="language-bash">✗ xmake
✗ xmake run test_redis
✗ xmake run test_redis
[==========] Running 11 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 11 tests from RedisCommandsTest
[ RUN      ] RedisCommandsTest.SetAndGet
[       OK ] RedisCommandsTest.SetAndGet (13 ms)
[ RUN      ] RedisCommandsTest.IncrAndDecr
[       OK ] RedisCommandsTest.IncrAndDecr (9 ms)
[ RUN      ] RedisCommandsTest.Expire
[       OK ] RedisCommandsTest.Expire (2011 ms)
[ RUN      ] RedisCommandsTest.HSetAndHGet
[       OK ] RedisCommandsTest.HSetAndHGet (17 ms)
[ RUN      ] RedisCommandsTest.HDel
[       OK ] RedisCommandsTest.HDel (9 ms)
[ RUN      ] RedisCommandsTest.HKeys
[       OK ] RedisCommandsTest.HKeys (9 ms)
[ RUN      ] RedisCommandsTest.HGetWithTTL
[       OK ] RedisCommandsTest.HGetWithTTL (2111 ms)
[ RUN      ] RedisCommandsTest.HExpire
[       OK ] RedisCommandsTest.HExpire (1109 ms)
[ RUN      ] RedisCommandsTest.SetOperations
[       OK ] RedisCommandsTest.SetOperations (8 ms)
[ RUN      ] RedisCommandsTest.ZSetOperations
[       OK ] RedisCommandsTest.ZSetOperations (8 ms)
[ RUN      ] RedisCommandsTest.ListOperations # failed
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-65-链表"><a class="header" href="#lab-65-链表">Lab 6.5 链表</a></h1>
<p>最后我们来实现<code>Redis</code>中的链表。之前的<code>Lab</code>中, 作者对设计方案都进行了详细的介绍, 也许你觉得这限制了你自己的设计, 因此这一小节作者打算不给你任何提示, 你需要自己设计并实现一个链表, 并通过对应的单元测试。</p>
<h1 id="1-代码实现"><a class="header" href="#1-代码实现">1 代码实现</a></h1>
<p>你需要修改的代码文件包括:</p>
<ul>
<li><code>src/redis_wrapper/redis_wrapper.cpp</code></li>
<li><code>include/redis_wrapper/redis_wrapper.h</code> (Optional)</li>
</ul>
<blockquote>
<p>下面的接口中, 你仍然需要进行<code>TTL</code>超时时间的判断, 同时你可能需要更新之前的<code>redis_ttl</code>和<code>redis_expire</code>以兼容<code>List</code>的<code>TTL</code>机制。</p>
</blockquote>
<pre><code class="language-cpp">// 链表操作
std::string RedisWrapper::redis_lpush(const std::string &amp;key,
                                      const std::string &amp;value) {
  // TODO: Lab 6.5 新建一个链表类型的`key`，并添加一个元素到链表头部
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return ":" + std::to_string(1) + "\r\n";
}

std::string RedisWrapper::redis_rpush(const std::string &amp;key,
                                      const std::string &amp;value) {
  // TODO: Lab 6.5 新建一个链表类型的`key`，并添加一个元素到链表尾部
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return ":" + std::to_string(1) + "\r\n";
}

std::string RedisWrapper::redis_lpop(const std::string &amp;key) {
  // TODO: Lab 6.5 获取一个链表类型的`key`的头部元素
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return "$-1\r\n"; // 表示链表不存在
}

std::string RedisWrapper::redis_rpop(const std::string &amp;key) {
  // TODO: Lab 6.5 获取一个链表类型的`key`的尾部元素
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return "$-1\r\n"; // 表示链表不存在
}

std::string RedisWrapper::redis_llen(const std::string &amp;key) {
  // TODO: Lab 6.5 获取一个链表类型的`key`的长度
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return ":1\r\n"; // 表示链表不存在
}

std::string RedisWrapper::redis_lrange(const std::string &amp;key, int start,
                                       int stop) {
  // TODO: Lab 6.5 获取一个链表类型的`key`的指定范围内的元素
  // ? 返回值的格式, 你需要查询 RESP 官方文档或者问 LLM
  return "*0\r\n"; // 表示链表不存在或者范围无效
}
</code></pre>
<h1 id="2-测试-1"><a class="header" href="#2-测试-1">2 测试</a></h1>
<p>现在你应该可以通过所有的单元测试:</p>
<pre><code class="language-bash">✗ xmake
[100%]: build ok, spent 0.607s
✗ xmake run test_redis
[==========] Running 11 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 11 tests from RedisCommandsTest
[ RUN      ] RedisCommandsTest.SetAndGet
[       OK ] RedisCommandsTest.SetAndGet (10 ms)
[ RUN      ] RedisCommandsTest.IncrAndDecr
[       OK ] RedisCommandsTest.IncrAndDecr (8 ms)
[ RUN      ] RedisCommandsTest.Expire
[       OK ] RedisCommandsTest.Expire (2011 ms)
[ RUN      ] RedisCommandsTest.HSetAndHGet
[       OK ] RedisCommandsTest.HSetAndHGet (8 ms)
[ RUN      ] RedisCommandsTest.HDel
[       OK ] RedisCommandsTest.HDel (8 ms)
[ RUN      ] RedisCommandsTest.HKeys
[       OK ] RedisCommandsTest.HKeys (8 ms)
[ RUN      ] RedisCommandsTest.HGetWithTTL
[       OK ] RedisCommandsTest.HGetWithTTL (2108 ms)
[ RUN      ] RedisCommandsTest.HExpire
[       OK ] RedisCommandsTest.HExpire (1121 ms)
[ RUN      ] RedisCommandsTest.SetOperations
[       OK ] RedisCommandsTest.SetOperations (8 ms)
[ RUN      ] RedisCommandsTest.ZSetOperations
[       OK ] RedisCommandsTest.ZSetOperations (9 ms)
[ RUN      ] RedisCommandsTest.ListOperations
[       OK ] RedisCommandsTest.ListOperations (8 ms)
[----------] 11 tests from RedisCommandsTest (5314 ms total)

[----------] Global test environment tear-down
[==========] 11 tests from 1 test suite ran. (5314 ms total)
[  PASSED  ] 11 tests
</code></pre>
<p>此外, 不出意外, 整个<code>Lab</code>的所有单元测试你应该都能正常通过:</p>
<pre><code class="language-bash">✗ xmake run test_redis
# ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-66-redis-server实现"><a class="header" href="#lab-66-redis-server实现">Lab 6.6 redis-server实现</a></h1>
<h1 id="1-概述-14"><a class="header" href="#1-概述-14">1 概述</a></h1>
<p>之前我们完成了利用<code>KV</code>接口实现常见<code>Redis</code>命令的常见命令, 我们的<code>Lab</code>即将迎来最后一个部分, 即实现<code>Redis</code>服务器的部分。</p>
<p>这一部分内容其实也很简单，网络框架作者已经为你搭建好了，你只需要实现<code>Resp</code>请求的解析, 利用解析出的参数调用我们之前实现的各个命令的接口即可。</p>
<blockquote>
<p>在初版的<code>Lab</code>中, 我们使用了<code>muduo</code>作为网络框架, 但由于<code>muduo</code>仅支持<code>Linux</code>, 因此在后续版本中我们将其替换为<code>asio</code>, 这是一个跨平台的网络库, 支持<code>Windows</code>, <code>MacOS</code>和<code>Linux</code>。使用<code>asio</code>后，本实验可以在所有主流操作系统上运行: <code>Linux</code>+<code>MacOS</code>+<code>Windows</code>(<code>Wsl</code>)</p>
</blockquote>
<h1 id="2-代码实现-11"><a class="header" href="#2-代码实现-11">2 代码实现</a></h1>
<p>这节课你可以修改<code>server</code>文件夹下的任何文件</p>
<pre><code class="language-bash">├── server # 调用 Redis 兼容层的 Webserver
│   ├── include
│   │   └── handler.h # Redis 命令处理函数的声明
│   └── src
│       ├── handler.cpp # Redis 命令处理函数的实现, 就是对 redis_wrapper 的转发
│       └── server.cpp # Webserver 的实现
</code></pre>
<p>你需要实现的接口为:</p>
<pre><code class="language-cpp">  std::string handleRequest(const std::string &amp;request) {
    // TODO: Lab 6.6 处理网络传输的RESP字节流
    // TODO: Lab 6.6 形成参数并调用 redis_wrapper 的api
    // TODO: Lab 6.6 返回结果
    return "";
  }
</code></pre>
<blockquote>
<p>如果你做得是初版的<code>Lab</code>, 这里实现的接口有所差异:</p>
<pre><code class="language-cpp">// server/src/server.cpp
std::string handleRequest(const std::string &amp;request) {
  // TODO: Lab 6.6 处理网络传输的RESP字节流
  // TODO: Lab 6.6 形成参数并调用 redis_wrapper 的api
  // TODO: Lab 6.6 返回结果
return "";
}
</code></pre>
</blockquote>
<p><code>handleRequest</code>前后的网络包收发逻辑已经为你写好, 你只需要在这个函数中解析<code>RESP</code>协议, 调用<code>redis_wrapper</code>的接口即可。当然, 你也可以直接新增各种辅助函数。</p>
<blockquote>
<p>除了我们之前实现的各种命令外, 你还需要实现<code>PING</code>命令, 这个命令不需要任何参数, 只需要返回<code>"+PONG\r\n"</code>即可。其内在含义表示服务器正在运行。</p>
</blockquote>
<h1 id="3-测试-12"><a class="header" href="#3-测试-12">3 测试</a></h1>
<p>你可以安装并使用<code>redis-cli</code>来测试你的<code>Redis</code>服务器, 过程为</p>
<pre><code class="language-bash">cd  tiny-lsm
xmake
xmake run server
</code></pre>
<p>上述操作将启动你实现的<code>Redis</code>服务器</p>
<p>然后在另一个终端中运行:</p>
<pre><code class="language-bash">redis-cli 
</code></pre>
<p>此时你就可以在<code>redis-cli</code>中输入我们之前<code>Lab</code>实现的命令和<code>server</code>进行交互了</p>
<p>预期的结果应该如下所示:</p>
<p><img src="lab6/../images/lab6/redis-example.png" alt="redis-example" /></p>
<h1 id="4-redis-benchmark-压测"><a class="header" href="#4-redis-benchmark-压测">4 redis-benchmark 压测</a></h1>
<p>由于我们已经实现了支持<code>Resp</code>的服务器, 其提供类似官方的<code>redis-server</code>的服务。同时， <code>redis</code>官方提供了压测工具<code>redis-benchmark</code>, 我们可以利用其进行压测。</p>
<h2 id="41-redis-benchmark-安装"><a class="header" href="#41-redis-benchmark-安装">4.1 redis-benchmark 安装</a></h2>
<p><code>redis-benchmark</code>是一个官方的压测工具，无论你是从<code>apt/yum</code>等源安装的<code>redis</code>，还是从源码编译的，其默认安装选项中都提供了<code>redis-benchmark</code>。</p>
<h2 id="42-redis-benchmark-使用"><a class="header" href="#42-redis-benchmark-使用">4.2 redis-benchmark 使用</a></h2>
<p><code>redis-benchmark</code>的使用非常简单，只需要指定<code>-h</code>参数，指定redis服务器的ip地址，然后就可以进行压测了。</p>
<p><code>redis-benchmark</code> 是 Redis 官方自带的性能测试工具，用于模拟多个客户端同时向 Redis 服务器发送命令，并评估其性能表现。它可以帮助你了解 Redis 在不同负载下的吞吐量和延迟情况。</p>
<p>基本的命令格式如下：</p>
<pre><code class="language-bash">redis-benchmark [选项] [测试]
</code></pre>
<p>如果不带任何选项，<code>redis-benchmark</code> 会使用默认设置连接到本地 (127.0.0.1) 的 6379 端口，并执行一组预定义的测试。</p>
<hr />
<h3 id="常用选项"><a class="header" href="#常用选项">常用选项</a></h3>
<p>以下是一些常用的 <code>redis-benchmark</code> 选项：</p>
<ul>
<li>
<p><strong>主机和端口:</strong></p>
<ul>
<li><code>-h &lt;hostname&gt;</code>: 指定要连接的 Redis 服务器的主机名或 IP 地址 (默认为 <code>127.0.0.1</code>)。</li>
<li><code>-p &lt;port&gt;</code>: 指定 Redis 服务器的端口号 (默认为 <code>6379</code>)。</li>
<li><code>-a &lt;password&gt;</code>: 如果 Redis 服务器设置了密码，使用此选项进行身份验证。</li>
<li><code>--tls</code>: 如果 Redis 服务器启用了 TLS/SSL 加密，使用此选项。</li>
</ul>
</li>
<li>
<p><strong>并发和请求数:</strong></p>
<ul>
<li><code>-c &lt;clients&gt;</code>: 指定并发客户端的数量 (默认为 <code>50</code>)。这模拟了同时有多少个连接在向 Redis 发送请求。</li>
<li><code>-n &lt;requests&gt;</code>: 指定总的请求数量 (默认为 <code>100000</code>)。</li>
</ul>
</li>
<li>
<p><strong>数据大小:</strong></p>
<ul>
<li><code>-d &lt;size&gt;</code>: 指定 SET/GET 命令操作的数据大小，单位是字节 (默认为 <code>3</code>)。</li>
</ul>
</li>
<li>
<p><strong>测试命令:</strong></p>
<ul>
<li><code>-t &lt;tests&gt;</code>: 指定要执行的测试命令列表，用逗号分隔。例如 <code>-t SET,GET,LPUSH</code>。如果不指定，则执行默认的测试集 (PING_INLINE, PING_BULK, SET, GET, INCR, LPUSH, RPUSH, LPOP, RPOP, SADD, HSET, SPOP, LRANGE_100, LRANGE_300, LRANGE_500, LRANGE_600, MSET)。</li>
</ul>
</li>
<li>
<p><strong>Pipeline:</strong></p>
<ul>
<li><code>-P &lt;numreq&gt;</code>: 指定每个连接 pipeline 的请求数量 (默认为 <code>1</code>)。Pipeline 可以显著提高吞吐量，因为它允许客户端在等待前一个命令的响应之前发送多个命令。</li>
</ul>
</li>
<li>
<p><strong>随机性:</strong></p>
<ul>
<li><code>-r &lt;keyspacelen&gt;</code>: 对 SET/GET/INCR 等命令使用随机的 key，对 SADD 等命令使用随机的 value。<code>&lt;keyspacelen&gt;</code> 定义了随机 key 的范围后缀。例如，<code>-r 100000</code> 会生成类似 <code>mykey_rand:000000000000</code> 到 <code>mykey_rand:000000099999</code> 这样的 key。这有助于模拟更真实的缓存场景，避免总是命中同一个 key。</li>
</ul>
</li>
<li>
<p><strong>安静模式:</strong></p>
<ul>
<li><code>-q</code>: 安静模式，只输出 QPS (每秒查询数) 结果。</li>
</ul>
</li>
<li>
<p><strong>线程 (较新版本):</strong></p>
<ul>
<li><code>--threads &lt;num&gt;</code>: 指定使用的线程数 (默认为 <code>1</code>)。对于多核 CPU，使用多线程可以更好地压测 Redis。</li>
</ul>
</li>
<li>
<p><strong>集群模式:</strong></p>
<ul>
<li><code>--cluster</code>: 如果测试的是 Redis 集群，需要添加此参数。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="输出结果解析"><a class="header" href="#输出结果解析">输出结果解析</a></h3>
<p><code>redis-benchmark</code> 会为每个测试的命令输出类似以下的信息：</p>
<pre><code>====== SET ======
  100000 requests completed in 1.23 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

99.76% &lt;= 1 milliseconds
100.00% &lt;= 1 milliseconds
81300.81 requests per second
</code></pre>
<p>关键指标包括：</p>
<ul>
<li><strong>requests completed in ... seconds</strong>: 完成指定请求数所花费的时间。</li>
<li><strong>parallel clients</strong>: 并发客户端数量。</li>
<li><strong>bytes payload</strong>: 数据负载大小。</li>
<li><strong>...% &lt;= ... milliseconds</strong>: 不同百分位的请求延迟。例如，<code>99.76% &lt;= 1 milliseconds</code> 表示 99.76% 的请求在 1 毫秒内完成。这有助于了解延迟的分布情况。</li>
<li><strong>requests per second (QPS)</strong>: 每秒处理的请求数。这是衡量 Redis 吞吐量的主要指标。</li>
</ul>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<ul>
<li>
<p><strong>测试本地 Redis 默认端口，执行默认测试集：</strong></p>
<pre><code class="language-bash">redis-benchmark
</code></pre>
</li>
<li>
<p><strong>测试特定主机和端口，使用 100 个并发连接，总共 100 万个请求：</strong></p>
<pre><code class="language-bash">redis-benchmark -h myredishost -p 6380 -c 100 -n 1000000
</code></pre>
</li>
<li>
<p><strong>只测试 SET 和 GET 命令，数据大小为 256 字节，使用 pipeline (每个 pipeline 16 个请求)：</strong></p>
<pre><code class="language-bash">redis-benchmark -t SET,GET -d 256 -P 16
</code></pre>
</li>
<li>
<p><strong>安静模式，只看 QPS：</strong></p>
<pre><code class="language-bash">redis-benchmark -q
</code></pre>
</li>
</ul>
<h2 id="43-测试结果"><a class="header" href="#43-测试结果">4.3 测试结果</a></h2>
<p>我们指定如下测试选项:</p>
<pre><code class="language-bash"># 1. 在一个 Terminal 中启动 server
➜  ~ xmake run server
# 2. 在另一个 Terminal 开启 redis-benchmark
➜  ~ redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000 -q -t SET,GET,INCR,SADD,HSET,ZADD
WARNING: Could not fetch server CONFIG
SET: 142653.36 requests per second, p50=0.527 msec
GET: 134589.50 requests per second, p50=0.503 msec
INCR: 132802.12 requests per second, p50=0.503 msec
SADD: 131233.59 requests per second, p50=0.519 msec
HSET: 123456.79 requests per second, p50=0.583 msec
ZADD: 126422.25 requests per second, p50=0.615 msec
</code></pre>
<blockquote>
<p>启动测试时, 你需要确保以下几点:</p>
<ol>
<li>使用<code>release</code>模型编译</li>
<li>更改日志级别为<code>info</code>, 否则会输出大量日志, 影响测试结果。你如果确定代码没有bug，甚至可以关闭日志输出</li>
<li>日志输出使用<code>reset_log_level</code>进行</li>
</ol>
</blockquote>
<p>这是作者的实现的测试结果, 同时我们可以用官方的<code>redis-server</code>测试进行对比:</p>
<pre><code class="language-bash"># 1. 在一个 Terminal 中启动 server
➜  ~ redis-server
# 2. 在另一个 Terminal 开启 redis-benchmark
➜  ~  redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000 -q -t SET,GET,INCR,SADD,HSET,ZADD
SET: 117647.05 requests per second, p50=0.527 msec
GET: 134228.19 requests per second, p50=0.527 msec
INCR: 132450.33 requests per second, p50=0.535 msec
SADD: 125628.14 requests per second, p50=0.551 msec
HSET: 128205.13 requests per second, p50=0.527 msec
ZADD: 137362.64 requests per second, p50=0.535 msec
</code></pre>
<p>这里我们对<code>SET,GET,INCR,SADD,HSET,ZADD</code>命令的实现的性能与<code>redis-server</code>的性能相近, 且有些许性能优势。你可以对比你自己的实现和<code>redis-server</code>的QPS, 预期的结果是与<code>redis-server</code>的QPS在同一数量级。</p>
<p><strong>压测之后呢?</strong>
这里的压测本身不是我们的目的, 你需要关注的是压测反映出的性能不足问题, 并修改相应代码的实现。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结语"><a class="header" href="#结语">结语</a></h1>
<p>本项目的初衷是作为<code>LSM Tree</code>的入门课程, 使参与者入门数据存储领域。这个<code>Lab</code>从代码实现, 到最后<code>Lab</code>文档的设计, 耗时半年, 花费了作者非常多的心血。因此, 如果您觉得这个<code>Lab</code>对您有帮助, 请在<code>GitHub</code>上给这个<code>Lab</code>一个<code>Star</code>。</p>
<h1 id="致谢"><a class="header" href="#致谢">致谢</a></h1>
<p>感谢网友<a href="https://github.com/koi2000">koi</a>对本项目文档的校正与补全, 让这个<code>Lab</code>的文档更加完善。</p>
<p>同时感谢以下为本项目贡献过源码的网友:</p>
<a href="https://github.com/Vanilla-Beauty/tiny-lsm/contributors">
  <img src="https://contrib.rocks/image?repo=Vanilla-Beauty/tiny-lsm" />
</a>
<h1 id="下一步"><a class="header" href="#下一步">下一步？</a></h1>
<p>当然，这个项目的定位只是让你初步入门<code>LSM Tree和存储领域</code>, 如果你想深入理解<code>LSM Tree</code>，建议阅读<code>leveldb/rocksdb</code>的源码。</p>
<p>此外，以下是一些存储领域的开源学习资料和项目，供进一步学习：</p>
<ul>
<li><strong><a href="https://cassandra.apache.org/">Apache Cassandra</a></strong>: 一个分布式 NoSQL 数据库，广泛使用 LSM Tree 作为其存储引擎的核心。</li>
<li><strong><a href="https://hbase.apache.org/">HBase</a></strong>: 一个基于 Hadoop 的分布式数据库，适合处理大规模结构化数据。</li>
<li><strong><a href="https://github.com/pingcap/tidb">TiDB</a></strong>: 一个开源的分布式 SQL 数据库，支持水平扩展和强一致性。</li>
<li><strong><a href="https://clickhouse.com/">ClickHouse</a></strong>: 一个用于在线分析处理 (OLAP) 的列式数据库管理系统。</li>
<li><strong><a href="https://github.com/apple/foundationdb">FoundationDB</a></strong>: 一个分布式数据库，提供事务支持，适合构建复杂的存储系统。</li>
<li><strong><a href="https://duckdb.org/">DuckDB</a></strong>: 一个嵌入式分析数据库，适合处理小型到中型数据集。</li>
<li><strong><a href="https://sqlite.org/">SQLite</a></strong>: 一个轻量级嵌入式数据库，适合学习存储引擎的基础知识。</li>
<li><strong><a href="https://github.com/etcd-io/bbolt">bbolt</a></strong>: 一个嵌入式键值数据库，基于 B+ 树实现，适合学习与 LSM Tree 不同的存储结构。</li>
<li><strong><a href="https://ceph.io/">Ceph</a></strong>: 一个统一的分布式存储系统，支持对象存储、块存储和文件存储，广泛应用于云计算和大规模存储场景。</li>
</ul>
<p>通过研究这些项目的源码和文档，你可以更全面地了解存储系统的设计与实现。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<p>这里列出一些学习资源或参考资料，供读者参考。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resp-常见格式"><a class="header" href="#resp-常见格式">RESP 常见格式</a></h1>
<h3 id="常见-redis-命令及其-resp-编码"><a class="header" href="#常见-redis-命令及其-resp-编码">常见 Redis 命令及其 RESP 编码</a></h3>
<h4 id="1-set"><a class="header" href="#1-set">1. <strong>SET</strong></a></h4>
<p>设置指定键的值。</p>
<ul>
<li>
<p><strong>命令格式</strong>：</p>
<pre><code class="language-text">*3
$3
SET
$3
key
$5
value
</code></pre>
</li>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>*3</code> 表示接下来有 3 个元素。</li>
<li><code>$3</code> 表示第一个元素是长度为 3 的字符串 <code>"SET"</code>。</li>
<li><code>$3</code> 表示第二个元素是长度为 3 的字符串 <code>"key"</code>.</li>
<li><code>$5</code> 表示第三个元素是长度为 5 的字符串 <code>"value"</code>。</li>
</ul>
</li>
</ul>
<h4 id="2-get"><a class="header" href="#2-get">2. <strong>GET</strong></a></h4>
<p>获取指定键的值。</p>
<ul>
<li>
<p><strong>命令格式</strong>：</p>
<pre><code class="language-text">*2
$3
GET
$3
key
</code></pre>
</li>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>*2</code> 表示接下来有 2 个元素。</li>
<li><code>$3</code> 表示第一个元素是长度为 3 的字符串 <code>"GET"</code>.</li>
<li><code>$3</code> 表示第二个元素是长度为 3 的字符串 <code>"key"</code>.</li>
</ul>
</li>
</ul>
<h4 id="3-del"><a class="header" href="#3-del">3. <strong>DEL</strong></a></h4>
<p>删除一个或多个键。</p>
<ul>
<li>
<p><strong>命令格式</strong>：</p>
<pre><code class="language-text">*3
$3
DEL
$3
key1
$3
key2
</code></pre>
</li>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>*3</code> 表示接下来有 3 个元素。</li>
<li><code>$3</code> 表示第一个元素是长度为 3 的字符串 <code>"DEL"</code>.</li>
<li><code>$3</code> 表示第二个元素是长度为 3 的字符串 <code>"key1"</code>.</li>
<li><code>$3</code> 表示第三个元素是长度为 3 的字符串 <code>"key2"</code>.</li>
</ul>
</li>
</ul>
<h4 id="4-incr"><a class="header" href="#4-incr">4. <strong>INCR</strong></a></h4>
<p>将键存储的数字值增加 1。</p>
<ul>
<li>
<p><strong>命令格式</strong>：</p>
<pre><code class="language-text">*2
$4
INCR
$3
key
</code></pre>
</li>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>*2</code> 表示接下来有 2 个元素。</li>
<li><code>$4</code> 表示第一个元素是长度为 4 的字符串 <code>"INCR"</code>.</li>
<li><code>$3</code> 表示第二个元素是长度为 3 的字符串 <code>"key"</code>.</li>
</ul>
</li>
</ul>
<h4 id="5-decr"><a class="header" href="#5-decr">5. <strong>DECR</strong></a></h4>
<p>将键存储的数字值减少 1。</p>
<ul>
<li>
<p><strong>命令格式</strong>：</p>
<pre><code class="language-text">*2
$4
DECR
$3
key
</code></pre>
</li>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>*2</code> 表示接下来有 2 个元素。</li>
<li><code>$4</code> 表示第一个元素是长度为 4 的字符串 <code>"DECR"</code>.</li>
<li><code>$3</code> 表示第二个元素是长度为 3 的字符串 <code>"key"</code>.</li>
</ul>
</li>
</ul>
<h4 id="6-expire"><a class="header" href="#6-expire">6. <strong>EXPIRE</strong></a></h4>
<p>设置键的过期时间（秒）。</p>
<ul>
<li>
<p><strong>命令格式</strong>：</p>
<pre><code class="language-text">*3
$7
EXPIRE
$3
key
$2
60
</code></pre>
</li>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>*3</code> 表示接下来有 3 个元素。</li>
<li><code>$7</code> 表示第一个元素是长度为 7 的字符串 <code>"EXPIRE"</code>.</li>
<li><code>$3</code> 表示第二个元素是长度为 3 的字符串 <code>"key"</code>.</li>
<li><code>$2</code> 表示第三个元素是长度为 2 的字符串 <code>"60"</code>.</li>
</ul>
</li>
</ul>
<h4 id="7-ttl"><a class="header" href="#7-ttl">7. <strong>TTL</strong></a></h4>
<p>获取键的剩余生存时间（秒）。</p>
<ul>
<li>
<p><strong>命令格式</strong>：</p>
<pre><code class="language-text">*2
$3
TTL
$3
key
</code></pre>
</li>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>*2</code> 表示接下来有 2 个元素。</li>
<li><code>$3</code> 表示第一个元素是长度为 3 的字符串 <code>"TTL"</code>.</li>
<li><code>$3</code> 表示第二个元素是长度为 3 的字符串 <code>"key"</code>.</li>
</ul>
</li>
</ul>
<h4 id="8-hset"><a class="header" href="#8-hset">8. <strong>HSET</strong></a></h4>
<p>设置哈希表中字段的值。</p>
<ul>
<li>
<p><strong>命令格式</strong>：</p>
<pre><code class="language-text">*4
$4
HSET
$3
hash
$3
field
$5
value
</code></pre>
</li>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>*4</code> 表示接下来有 4 个元素。</li>
<li><code>$4</code> 表示第一个元素是长度为 4 的字符串 <code>"HSET"</code>.</li>
<li><code>$3</code> 表示第二个元素是长度为 3 的字符串 <code>"hash"</code>.</li>
<li><code>$3</code> 表示第三个元素是长度为 3 的字符串 <code>"field"</code>.</li>
<li><code>$5</code> 表示第四个元素是长度为 5 的字符串 <code>"value"</code>.</li>
</ul>
</li>
</ul>
<h4 id="9-hget"><a class="header" href="#9-hget">9. <strong>HGET</strong></a></h4>
<p>获取哈希表中字段的值。</p>
<ul>
<li>
<p><strong>命令格式</strong>：</p>
<pre><code class="language-text">*3
$4
HGET
$3
hash
$5
field
</code></pre>
</li>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>*3</code> 表示接下来有 3 个元素。</li>
<li><code>$4</code> 表示第一个元素是长度为 4 的字符串 <code>"HGET"</code>.</li>
<li><code>$3</code> 表示第二个元素是长度为 3 的字符串 <code>"hash"</code>.</li>
<li><code>$5</code> 表示第三个元素是长度为 5 的字符串 <code>"field"</code>.</li>
</ul>
</li>
</ul>
<h4 id="10-lpush"><a class="header" href="#10-lpush">10. <strong>LPUSH</strong></a></h4>
<p>将一个或多个值插入列表头部。</p>
<ul>
<li>
<p><strong>命令格式</strong>：</p>
<pre><code class="language-text">*3
$5
LPUSH
$5
mylist
$4
item
</code></pre>
</li>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>*3</code> 表示接下来有 3 个元素。</li>
<li><code>$5</code> 表示第一个元素是长度为 5 的字符串 <code>"LPUSH"</code>.</li>
<li><code>$5</code> 表示第二个元素是长度为 5 的字符串 <code>"mylist"</code>.</li>
<li><code>$4</code> 表示第三个元素是长度为 4 的字符串 <code>"item"</code>.</li>
</ul>
</li>
</ul>
<h4 id="11-lrange"><a class="header" href="#11-lrange">11. <strong>LRANGE</strong></a></h4>
<p>获取列表中指定范围的元素。</p>
<ul>
<li>
<p><strong>命令格式</strong>：</p>
<pre><code class="language-text">*4
$6
LRANGE
$5
mylist
$1
0
$1
1
</code></pre>
</li>
<li>
<p><strong>解释</strong>：</p>
<ul>
<li><code>*4</code> 表示接下来有 4 个元素。</li>
<li><code>$6</code> 表示第一个元素是长度为 6 的字符串 <code>"LRANGE"</code>.</li>
<li><code>$5</code> 表示第二个元素是长度为 5 的字符串 <code>"mylist"</code>.</li>
<li><code>$1</code> 表示第三个元素是长度为 1 的字符串 <code>"0"</code>.</li>
<li><code>$1</code> 表示第四个元素是长度为 1 的字符串 <code>"1"</code>.</li>
</ul>
</li>
</ul>
<h3 id="测试与验证"><a class="header" href="#测试与验证">测试与验证</a></h3>
<p>你可以使用 <code>redis-cli</code> 来测试这些新实现的命令：</p>
<pre><code class="language-bash"># 测试 DEL
redis-cli -p 6379 SET key1 "value1"
redis-cli -p 6379 SET key2 "value2"
redis-cli -p 6379 DEL key1 key2

# 测试 INCR 和 DECR
redis-cli -p 6379 SET counter 10
redis-cli -p 6379 INCR counter
redis-cli -p 6379 DECR counter

# 测试 EXPIRE 和 TTL
redis-cli -p 6379 SET tempKey "tempValue"
redis-cli -p 6379 EXPIRE tempKey 60
redis-cli -p 6379 TTL tempKey

# 测试 HSET 和 HGET
redis-cli -p 6379 HSET myhash field1 "Hello"
redis-cli -p 6379 HGET myhash field1

# 测试 LPUSH 和 LRANGE
redis-cli -p 6379 LPUSH mylist item1 item2 item3
redis-cli -p 6379 LRANGE mylist 0 2
</code></pre>
<p>通过这些测试命令，你可以验证你的服务器是否正确实现了这些 Redis 命令。如果有任何问题，请检查日志输出并进行相应的调试。</p>
<div style="break-before: page; page-break-before: always;"></div><p>本实验的<code>1.0</code>版本已经完成，但目前该实验存在以下优化方向:</p>
<ol>
<li>自由度提升: <code>1.0</code>版本的<code>Lab</code>, 基本上就是在既有的项目代码下进行关键函数的挖空, 在组件设计层面没有给实验参与者太多的发挥空间, 后续应该添加更多的自由度, 允许实验者自由设计组件, 并且在组件设计中添加更多的测试用例。</li>
<li>测试用例覆盖率不足: <code>1.0</code>版本的<code>Lab</code>中, 测试用例的覆盖率比较低, 比如对崩溃恢复的各种边界条件的考虑不足, 当然这确实也比较难控制就是了。</li>
<li>各个<code>Lab</code>工作量不尽相同, 现在的<code>Lab</code>设计是按照功能模块进行划分的, 但这导致<a href="./lab5/lab5-Tranc-MVCC.html">Lab 5</a>和<a href="./lab6/lab6-Redis.html">Lab 6</a>的测代码量和难度远大于之前的<code>Lab</code>, 难度曲线可能不太合理, 后续应考虑对各个<code>Lab</code>进行更加均衡的划分。</li>
<li>进一步补充一些背景理论知识, 尤其是实际场景中的各种性能优化方案。</li>
</ol>
<p>如果你有兴趣参与本实验的建设，欢迎在下面的分支上提交PR:</p>
<ul>
<li><a href="https://github.com/Vanilla-Beauty/tiny-lsm/tree/lab">Lab代码分支</a></li>
<li><a href="https://github.com/Vanilla-Beauty/tiny-lsm/tree/lab-doc">Lab文档分支</a></li>
<li><a href="https://github.com/Vanilla-Beauty/tiny-lsm/tree/master">代码开发分支</a></li>
</ul>
<p>如果你有什么问题，可以通过 <a href="https://qm.qq.com/q/wDZQfaNNw6">QQ讨论群</a> 或者 <a href="mailto:807077266@qq.com">📧邮件</a> 联系到作者。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="./src/giscus.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
